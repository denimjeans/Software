 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _Status::
 0000 00                .byte 0
 0001                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
 0001                   .dbsym e Status _Status c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
 0000           _Zustand_Output::
 0000 01                .byte 1
 0001                   .dbsym e Zustand_Output _Zustand_Output c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
 0000           _Zustand_Input::
 0000 00                .byte 0
 0001                   .dbsym e Zustand_Input _Zustand_Input c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
 0000           _LM75_Data::
 0000 00                .byte 0
 0001                   .dbsym e LM75_Data _LM75_Data c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
 0000           _WhichButton::
 0000 00                .byte 0
 0001                   .dbsym e WhichButton _WhichButton c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\I2C\I2C\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 23
 0000           ; #include <m8c.h>                                                                                              // Part specific constants and Macros
 0000           ; #include "PSoCAPI.h"                                                                                          // PSoC API definitions for all User Modules
 0000           ; #include "stdlib.h"
 0000           ; #pragma interrupt_handler Timer16
 0000           ; 
 0000           ; void I2C_Init(void);
 0000           ; void Write_PCF(char *Port);   
 0000           ; void Read_PCF(char *Pin);
 0000           ; void Read_LM75(char *Temperatur);
 0000           ; void Read_PSoCSlave(char *Button);
 0000           ; 
 0000           ; char Status = 0x00;
 0000           ; char Zustand_Output = 0x01;
 0000           ; char Zustand_Input = 0x00;
 0000           ; char LM75_Data = 0x00;
 0000           ; char WhichButton = 0x00;
 0000           ; 
 0000           ; #define PSoC_Addr 0x40
 0000           ; #define PCF_Addr 0x20                                                                                 // Konstante Variable
 0000           ; #define LM75_Addr 0x9E
 0000           ;                                                                                                                               
 0000           ; void main(void)
 0000           ; {
 0000                   .dbline 24
 0000           ;       M8C_EnableGInt;                                                                                         // Globale Interrupts erlauben
 0000 7101                      or  F, 01h
 0002           
 0002                   .dbline 25
 0002           ;       LCD_Start();                                                                            // LCD initialisieren
 0002 10                push X
 0003 7C0000            xcall _LCD_Start
 0006                   .dbline 26
 0006           ;       Timer16_EnableInt();                                                                            // Timer16 Interrupts aktivieren
 0006 7C0000            xcall _Timer16_EnableInt
 0009                   .dbline 27
 0009           ;     Timer16_Start();                                                                                          // Timer16 starten
 0009 7C0000            xcall _Timer16_Start
 000C 20                pop X
 000D                   .dbline 44
 000D           ;       
 000D           ;       //LCD_Control(0x20);                                                                                    // Adresse für CGRAM (Character Generator RAM)
 000D           ;       //LCD_Delay50u();                                                                                               // 50us warten
 000D           ;       //LCD_WriteData(31);
 000D           ;       //LCD_WriteData(24);
 000D           ;       //LCD_WriteData(25);
 000D           ;       //LCD_WriteData(27);
 000D           ;       //LCD_WriteData(31);
 000D           ;       //LCD_WriteData(31);
 000D           ;       //LCD_WriteData(31);
 000D           ;       //LCD_WriteData(32);
 000D           ; 
 000D           ;       //LCD_Control(0x80);                                                                                    // Set DDRAM as target of data writes
 000D           ;       //LCD_Position(0,0);                                                                                    // Set cursor in DDRAM
 000D           ;       //LCD_WriteData(0);                                                                                     // Display the CGRAM[0] character there
 000D           ;       
 000D           ;       I2C_Init();
 000D 90CA              xcall _I2C_Init
 000F 803A              xjmp L3
 0011           L2:
 0011                   .dbline 47
 0011           ; 
 0011           ;       while(1)
 0011           ;       {
 0011                   .dbline 61
 0011           ;               //Write_PCF(&Zustand_Output);   
 0011           ;               //LCD_Position(0,0);
 0011           ;               //LCD_PrCString("Temperatur: ");
 0011           ;               //LCD_Position(1,0);
 0011           ;               //LCD_PrHexInt(LM75_Data);
 0011           ;               
 0011           ;               //Read_PCF(&Zustand_Input);
 0011           ;               //LCD_Position(2,0);
 0011           ;               //LCD_PrCString("Input: ");
 0011           ;               //LCD_Position(3,0);
 0011           ;               //LCD_PrHexInt(Zustand_Input);
 0011           ;               
 0011           ;               //Read_LM75(&LM75_Data);
 0011           ;               Read_PSoCSlave(&WhichButton);
 0011 5000              mov A,>_WhichButton
 0013 08                push A
 0014 5000              mov A,<_WhichButton
 0016 08                push A
 0017 9156              xcall _Read_PSoCSlave
 0019 38FE              add SP,-2
 001B                   .dbline 62
 001B           ;               LCD_Position(0,0);
 001B 10                push X
 001C 5000              mov A,0
 001E 5700              mov X,0
 0020 7C0000            xcall _LCD_Position
 0023                   .dbline 63
 0023           ;               LCD_PrCString("Button:");
 0023 5008              mov A,>L5
 0025 08                push A
 0026 5008              mov A,<L5
 0028 5C                mov X,A
 0029 18                pop A
 002A 7C0000            xcall _LCD_PrCString
 002D                   .dbline 64
 002D           ;               LCD_Position(1,0);
 002D 5700              mov X,0
 002F 5001              mov A,1
 0031 7C0000            xcall _LCD_Position
 0034 20                pop X
 0035                   .dbline 65
 0035           ;               LCD_PrHexInt(WhichButton);
 0035 62D000            mov REG[0xd0],>_WhichButton
 0038 5100              mov A,[_WhichButton]
 003A 62D000            mov REG[0xd0],>__r0
 003D 5300              mov [__r1],A
 003F 10                push X
 0040 5000              mov A,0
 0042 08                push A
 0043 5100              mov A,[__r1]
 0045 20                pop X
 0046 7C0000            xcall _LCD_PrHexInt
 0049 20                pop X
 004A                   .dbline 66
 004A           ;       }
 004A           L3:
 004A                   .dbline 46
 004A 8FC6              xjmp L2
 004C           X0:
 004C                   .dbline -2
 004C           L1:
 004C                   .dbline 0 ; func end
 004C 8FFF              jmp .
 004E                   .dbend
 004E                   .dbfunc e Timer16 _Timer16 fV
 004E           _Timer16::
 004E                   .dbline -1
 004E 71C0              or F,-64
 0050 08                push A
 0051 5DD0              mov A,REG[0xd0]
 0053 08                push A
 0054 5DD3              mov A,REG[0xd3]
 0056 08                push A
 0057 5DD4              mov A,REG[0xd4]
 0059 08                push A
 005A 5DD5              mov A,REG[0xd5]
 005C 08                push A
 005D 62D000            mov REG[0xd0],>__r0
 0060 5100              mov A,[__r0]
 0062 08                push A
 0063 5100              mov A,[__r1]
 0065 08                push A
 0066 5100              mov A,[__r2]
 0068 08                push A
 0069 5100              mov A,[__r3]
 006B 08                push A
 006C 5100              mov A,[__r4]
 006E 08                push A
 006F 5100              mov A,[__r5]
 0071 08                push A
 0072 5100              mov A,[__r6]
 0074 08                push A
 0075 5100              mov A,[__r7]
 0077 08                push A
 0078 5100              mov A,[__r8]
 007A 08                push A
 007B 5100              mov A,[__r9]
 007D 08                push A
 007E 5100              mov A,[__r10]
 0080 08                push A
 0081 5100              mov A,[__r11]
 0083 08                push A
 0084 5100              mov A,[__rX]
 0086 08                push A
 0087 5100              mov A,[__rY]
 0089 08                push A
 008A 5100              mov A,[__rZ]
 008C 08                push A
 008D                   .dbline 71
 008D           ; }
 008D           ; 
 008D           ; 
 008D           ; void Timer16(void)
 008D           ; {
 008D                   .dbline 72
 008D           ;       Zustand_Output++;
 008D 62D000            mov REG[0xd0],>_Zustand_Output
 0090 7600              inc [_Zustand_Output]
 0092                   .dbline 73
 0092           ;       Timer16_WritePeriod(32768); 
 0092 10                push X
 0093 5780              mov X,-128
 0095 5000              mov A,0
 0097 7C0000            xcall _Timer16_WritePeriod
 009A 20                pop X
 009B                   .dbline -2
 009B           L6:
 009B 62D000            mov REG[0xD0],>__r0
 009E 18                pop A
 009F 5300              mov [__rZ],A
 00A1 18                pop A
 00A2 5300              mov [__rY],A
 00A4 18                pop A
 00A5 5300              mov [__rX],A
 00A7 18                pop A
 00A8 5300              mov [__r11],A
 00AA 18                pop A
 00AB 5300              mov [__r10],A
 00AD 18                pop A
 00AE 5300              mov [__r9],A
 00B0 18                pop A
 00B1 5300              mov [__r8],A
 00B3 18                pop A
 00B4 5300              mov [__r7],A
 00B6 18                pop A
 00B7 5300              mov [__r6],A
 00B9 18                pop A
 00BA 5300              mov [__r5],A
 00BC 18                pop A
 00BD 5300              mov [__r4],A
 00BF 18                pop A
 00C0 5300              mov [__r3],A
 00C2 18                pop A
 00C3 5300              mov [__r2],A
 00C5 18                pop A
 00C6 5300              mov [__r1],A
 00C8 18                pop A
 00C9 5300              mov [__r0],A
 00CB 18                pop A
 00CC 60D5              mov REG[213],A
 00CE 18                pop A
 00CF 60D4              mov REG[212],A
 00D1 18                pop A
 00D2 60D3              mov REG[211],A
 00D4 18                pop A
 00D5 60D0              mov REG[208],A
 00D7 18                pop A
 00D8                   .dbline 0 ; func end
 00D8 7E                reti
 00D9                   .dbend
 00D9                   .dbfunc e I2C_Init _I2C_Init fV
 00D9           _I2C_Init::
 00D9                   .dbline -1
 00D9                   .dbline 77
 00D9           ; }
 00D9           ; 
 00D9           ; void I2C_Init(void)
 00D9           ; {
 00D9                   .dbline 78
 00D9           ;       I2CHW_Start();                                                                                                                                  // I²C Modul starten
 00D9 10                push X
 00DA 7C0000            xcall _I2CHW_Start
 00DD                   .dbline 79
 00DD           ;       I2CHW_EnableInt();                                                                                                                              // I²C Interrupts aktivieren
 00DD 7C0000            xcall _I2CHW_EnableInt
 00E0                   .dbline 80
 00E0           ;       I2CHW_EnableMstr();                                                                                                                             // Modul auf "Master" stellen
 00E0 7C0000            xcall _I2CHW_EnableMstr
 00E3 20                pop X
 00E4                   .dbline -2
 00E4           L7:
 00E4                   .dbline 0 ; func end
 00E4 7F                ret
 00E5                   .dbend
 00E5                   .dbfunc e Write_PCF _Write_PCF fV
 00E5           ;           Port -> X-5
 00E5           _Write_PCF::
 00E5                   .dbline -1
 00E5 10                push X
 00E6 4F                mov X,SP
 00E7                   .dbline 84
 00E7           ; }
 00E7           ; 
 00E7           ; void Write_PCF(char *Port)
 00E7           ; {
 00E7                   .dbline 85
 00E7           ;       I2CHW_bWriteBytes(PCF_Addr, Port, 1, I2CHW_CompleteXfer);
 00E7 10                push X
 00E8 5000              mov A,0
 00EA 08                push A
 00EB 5001              mov A,1
 00ED 08                push A
 00EE 52FB              mov A,[X-5]
 00F0 08                push A
 00F1 52FC              mov A,[X-4]
 00F3 08                push A
 00F4 5020              mov A,32
 00F6 08                push A
 00F7 7C0000            xcall _I2CHW_bWriteBytes
 00FA 38FB              add SP,-5
 00FC 20                pop X
 00FD           L9:
 00FD                   .dbline 86
 00FD           ;       while(!(I2CHW_bReadI2CStatus() & I2CHW_WR_COMPLETE));
 00FD           L10:
 00FD                   .dbline 86
 00FD 10                push X
 00FE 7C0000            xcall _I2CHW_bReadI2CStatus
 0101 20                pop X
 0102 62D000            mov REG[0xd0],>__r0
 0105 5300              mov [__r0],A
 0107 470040            tst [__r0],64
 010A AFF2              jz L9
 010C                   .dbline 87
 010C           ;       I2CHW_ClrWrStatus();                                                                                                            
 010C 10                push X
 010D 7C0000            xcall _I2CHW_ClrWrStatus
 0110 20                pop X
 0111                   .dbline -2
 0111           L8:
 0111 20                pop X
 0112                   .dbline 0 ; func end
 0112 7F                ret
 0113                   .dbsym l Port -5 pc
 0113                   .dbend
 0113                   .dbfunc e Read_PCF _Read_PCF fV
 0113           ;            Pin -> X-5
 0113           _Read_PCF::
 0113                   .dbline -1
 0113 10                push X
 0114 4F                mov X,SP
 0115                   .dbline 91
 0115           ; }
 0115           ; 
 0115           ; void Read_PCF(char *Pin)
 0115           ; {
 0115                   .dbline 92
 0115           ;       I2CHW_fReadBytes(PCF_Addr, Pin, 1, I2CHW_CompleteXfer);
 0115 10                push X
 0116 5000              mov A,0
 0118 08                push A
 0119 5001              mov A,1
 011B 08                push A
 011C 52FB              mov A,[X-5]
 011E 08                push A
 011F 52FC              mov A,[X-4]
 0121 08                push A
 0122 5020              mov A,32
 0124 08                push A
 0125 7C0000            xcall _I2CHW_fReadBytes
 0128 38FB              add SP,-5
 012A 20                pop X
 012B           L13:
 012B                   .dbline 93
 012B           ;       while(!(I2CHW_bReadI2CStatus() & I2CHW_RD_COMPLETE));                                                   // Warten bis der Lesevorgang abgeschlossen ist
 012B           L14:
 012B                   .dbline 93
 012B 10                push X
 012C 7C0000            xcall _I2CHW_bReadI2CStatus
 012F 20                pop X
 0130 62D000            mov REG[0xd0],>__r0
 0133 5300              mov [__r0],A
 0135 470004            tst [__r0],4
 0138 AFF2              jz L13
 013A                   .dbline 94
 013A           ;       I2CHW_ClrRdStatus();
 013A 10                push X
 013B 7C0000            xcall _I2CHW_ClrRdStatus
 013E 20                pop X
 013F                   .dbline -2
 013F           L12:
 013F 20                pop X
 0140                   .dbline 0 ; func end
 0140 7F                ret
 0141                   .dbsym l Pin -5 pc
 0141                   .dbend
 0141                   .dbfunc e Read_LM75 _Read_LM75 fV
 0141           ;     Temperatur -> X-5
 0141           _Read_LM75::
 0141                   .dbline -1
 0141 10                push X
 0142 4F                mov X,SP
 0143                   .dbline 98
 0143           ; }
 0143           ; 
 0143           ; void Read_LM75(char *Temperatur)
 0143           ; {
 0143                   .dbline 99
 0143           ;       I2CHW_fReadBytes(LM75_Addr, Temperatur, 1, I2CHW_CompleteXfer);
 0143 10                push X
 0144 5000              mov A,0
 0146 08                push A
 0147 5001              mov A,1
 0149 08                push A
 014A 52FB              mov A,[X-5]
 014C 08                push A
 014D 52FC              mov A,[X-4]
 014F 08                push A
 0150 509E              mov A,-98
 0152 08                push A
 0153 7C0000            xcall _I2CHW_fReadBytes
 0156 38FB              add SP,-5
 0158 20                pop X
 0159           L17:
 0159                   .dbline 100
 0159           ;       while(!(I2CHW_bReadI2CStatus() & I2CHW_RD_COMPLETE));                                                   // Warten bis der Lesevorgang abgeschlossen ist
 0159           L18:
 0159                   .dbline 100
 0159 10                push X
 015A 7C0000            xcall _I2CHW_bReadI2CStatus
 015D 20                pop X
 015E 62D000            mov REG[0xd0],>__r0
 0161 5300              mov [__r0],A
 0163 470004            tst [__r0],4
 0166 AFF2              jz L17
 0168                   .dbline 101
 0168           ;       I2CHW_ClrRdStatus();
 0168 10                push X
 0169 7C0000            xcall _I2CHW_ClrRdStatus
 016C 20                pop X
 016D                   .dbline -2
 016D           L16:
 016D 20                pop X
 016E                   .dbline 0 ; func end
 016E 7F                ret
 016F                   .dbsym l Temperatur -5 pc
 016F                   .dbend
 016F                   .dbfunc e Read_PSoCSlave _Read_PSoCSlave fV
 016F           ;         Button -> X-5
 016F           _Read_PSoCSlave::
 016F                   .dbline -1
 016F 10                push X
 0170 4F                mov X,SP
 0171                   .dbline 105
 0171           ; }
 0171           ; 
 0171           ; void Read_PSoCSlave(char *Button)
 0171           ; {
 0171                   .dbline 106
 0171           ;       I2CHW_fReadBytes(PSoC_Addr, Button, 1, I2CHW_CompleteXfer);
 0171 10                push X
 0172 5000              mov A,0
 0174 08                push A
 0175 5001              mov A,1
 0177 08                push A
 0178 52FB              mov A,[X-5]
 017A 08                push A
 017B 52FC              mov A,[X-4]
 017D 08                push A
 017E 5040              mov A,64
 0180 08                push A
 0181 7C0000            xcall _I2CHW_fReadBytes
 0184 38FB              add SP,-5
 0186                   .dbline 107
 0186           ;       Status = I2CHW_bReadI2CStatus();
 0186 7C0000            xcall _I2CHW_bReadI2CStatus
 0189 20                pop X
 018A 62D000            mov REG[0xd0],>_Status
 018D 5300              mov [_Status],A
 018F                   .dbline 108
 018F           ;       LCD_Position(2,0);
 018F 10                push X
 0190 5700              mov X,0
 0192 5002              mov A,2
 0194 7C0000            xcall _LCD_Position
 0197                   .dbline 109
 0197           ;       LCD_PrCString("Status:");
 0197 5000              mov A,>L21
 0199 08                push A
 019A 5000              mov A,<L21
 019C 5C                mov X,A
 019D 18                pop A
 019E 7C0000            xcall _LCD_PrCString
 01A1                   .dbline 110
 01A1           ;       LCD_Position(3,0);
 01A1 5700              mov X,0
 01A3 5003              mov A,3
 01A5 7C0000            xcall _LCD_Position
 01A8 20                pop X
 01A9                   .dbline 111
 01A9           ;       LCD_PrHexInt(Status);
 01A9 62D000            mov REG[0xd0],>_Status
 01AC 5100              mov A,[_Status]
 01AE 62D000            mov REG[0xd0],>__r0
 01B1 5300              mov [__r1],A
 01B3 10                push X
 01B4 5000              mov A,0
 01B6 08                push A
 01B7 5100              mov A,[__r1]
 01B9 20                pop X
 01BA 7C0000            xcall _LCD_PrHexInt
 01BD 20                pop X
 01BE           L22:
 01BE                   .dbline 112
 01BE           ;       while(!(I2CHW_bReadI2CStatus() & I2CHW_RD_COMPLETE));                                                   // Warten bis der Lesevorgang abgeschlossen ist
 01BE           L23:
 01BE                   .dbline 112
 01BE 10                push X
 01BF 7C0000            xcall _I2CHW_bReadI2CStatus
 01C2 20                pop X
 01C3 62D000            mov REG[0xd0],>__r0
 01C6 5300              mov [__r0],A
 01C8 470004            tst [__r0],4
 01CB AFF2              jz L22
 01CD                   .dbline 113
 01CD           ;       I2CHW_ClrRdStatus();
 01CD 10                push X
 01CE 7C0000            xcall _I2CHW_ClrRdStatus
 01D1 20                pop X
 01D2                   .dbline -2
 01D2           L20:
 01D2 20                pop X
 01D3                   .dbline 0 ; func end
 01D3 7F                ret
 01D4                   .dbsym l Button -5 pc
 01D4                   .dbend
                        .area lit(rom, con, rel, lit)
 0000           L21:
 0000 5374617475733A00  .byte 'S,'t,'a,'t,'u,'s,58,0
 0008           L5:
 0008 427574746F6E3A00  .byte 'B,'u,'t,'t,'o,'n,58,0
