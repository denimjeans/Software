 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\DS1307\DS1307\DS1307\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 48
 0000           ; // Write a value 0x10 to the control register of the RTC
 0000           ; // This will set the clock SQW/OUT to 1Hz and enable the output
 0000           ; // SQWE = 1 and output freq is set as 1Hz.
 0000           ; // OUT  0   0    SQWE   0   0   RS1   RS0
 0000           ; //  0   0   0     1     0   0    0     0 => 0001 0000 (0x10)
 0000           ; //
 0000           ; //    RS1   RS0   SQW/OUT O/P    SQWE   OUT
 0000           ; //   0     0      1Hz           1      X
 0000           ; //   0     1      4.096KHz      1      X
 0000           ; //   1           0      8.192KHz              1      X
 0000           ; //     1         1     32.768KHz      1      X
 0000           ; //     X         X      0             0      0
 0000           ; //     X         X      1             0      0
 0000           ;       
 0000           ; #include <m8c.h>                                                                                                                                      // Part specific constants and macros
 0000           ; #include "PSoCAPI.h"                                                                                                                          // PSoC API definitions for all User Modules
 0000           ; #pragma interrupt_handler RTC_Read_ISR                                                                                                // Declares the interrupt handler for the timer interrupt 
 0000           ; 
 0000           ; typedef struct{                                                                                                                                               // Deffiniert einen Variablentypen vom Aufbau eines Structs
 0000           ;       BYTE Address;                                                                                                                                   // welche 8 Variablen enthält und "RTC_Struct" heißt
 0000           ;       BYTE Seconds;
 0000           ;       BYTE Minutes;
 0000           ;       BYTE Hours;
 0000           ;       BYTE Day;
 0000           ;       BYTE Date;
 0000           ;       BYTE Month;
 0000           ;       BYTE Year;
 0000           ; }RTC_Struct;
 0000           ; 
 0000           ; // Funktionen deklarieren
 0000           ; void I2C_Init(void);
 0000           ; void RTC_WriteReg(BYTE RegAddress, BYTE RegData);                                                                     // Deffiniert eine Funktion. Diese erwartet als Übergabewerte zwei Bytes
 0000           ; void RTC_SetRegAddress(BYTE RegAddress);
 0000           ; void RTC_ReadTime(RTC_Struct *pTime);
 0000           ; void RTC_SetTime(RTC_Struct *pTime);                                                                                          // Deffiniert eine Funktion wo ein Pointer rein übergeben wird der vom Typ "RTC_Struct" ist
 0000           ; void Print_Time(RTC_Struct *pTime);
 0000           ; 
 0000           ; unsigned char bRTC_RegPointer ;                                                                                                               // Contains the address of the register from/to which data has to be read/written
 0000           ; unsigned char fReadRTC;                                                                                                                               // Flags used to indicate occurence of various events
 0000           ; 
 0000           ; RTC_Struct Time;                                                                                                                                      // Erzeugt eine Variable mit Namen "Time" vom Typen RTC_Struct
 0000           ; RTC_Struct SetTime;                                                                                                                                   // Erzeugt eine Variable mit Namen "SetTime" vom Typen RTC_Struct
 0000           ; 
 0000           ; #define RTC_Addr 0x68                                                                                                                         // Konstante Variable
 0000           ; #define TIME_LEN sizeof(Time)                                                                                                         // Konstante Variable die die Größe von der Variable "Time" enthält
 0000           ; 
 0000           ; void main(void)
 0000           ; {
 0000                   .dbline 49
 0000           ;     M8C_EnableGInt;                                                                                                                                   // Globale Interrupts aktivieren
 0000 7101                      or  F, 01h
 0002           
 0002                   .dbline 50
 0002           ;       LCD_Start();                                                                                                                                    // LCD starten und initialisieren
 0002 10                push X
 0003 7C0000            xcall _LCD_Start
 0006 20                pop X
 0007                   .dbline 51
 0007           ;       I2C_Init();                                                                                                                                             // I²C Modul starten und initialisieren
 0007 904B              xcall _I2C_Init
 0009                   .dbline 53
 0009           ;       
 0009           ;       RTC_WriteReg(0x07, 0x11);                                                                                                               // Ruft die Funktion "RTC_WriteReg" auf und übergibt die Zahl 0x07 als "RegAdress"
 0009 5011              mov A,17
 000B 08                push A
 000C 5007              mov A,7
 000E 08                push A
 000F 90BD              xcall _RTC_WriteReg
 0011                   .dbline 55
 0011           ;                                                                                                                                                                       // sowie die Zahl 0x10 als RegData
 0011           ;       SetTime.Address = 0x00;                                                                                                                 // Schreibt in das Struct "SetTime" eine 0x00 in die Variable "Adress"
 0011 62D000            mov REG[0xd0],>_SetTime
 0014 550000            mov [_SetTime],0
 0017                   .dbline 58
 0017           ;       
 0017           ;       // Hier wird die Zeit und das Datum eingestellt
 0017           ;       SetTime.Seconds = 0x00;                                                                                                                 // Setzt die Sekunden (BCD Format)      
 0017 550100            mov [_SetTime+1],0
 001A                   .dbline 60
 001A           ;       
 001A           ;       SetTime.Minutes = 0x20;                                                                                                                 // Setzt die Minuten (BCD Format) 
 001A 550220            mov [_SetTime+2],32
 001D                   .dbline 62
 001D           ;       
 001D           ;       SetTime.Hours = 0x10;                                                                                                                   // Setzt die Uhr in den 12-Stunden Modus und aktiviert PM. Setzt die Stunden
 001D 550310            mov [_SetTime+3],16
 0020                   .dbline 66
 0020           ;                                                                                                                                                                       //  0     12/24     10 Hour/(PM/AM)  10 Hour     Hours
 0020           ;                                                                                                                                                                       //  0     1(12)         1(PM)           0       0 1 0 0 => 0110 0100 (0x64)
 0020           ;       
 0020           ;       SetTime.Day = 0x07;                                                                                                                             // Setzt den Wochentag. 1 = Sonntag und 7 = Samstag
 0020 550407            mov [_SetTime+4],7
 0023                   .dbline 68
 0023           ;       
 0023           ;       SetTime.Date = 0x30;                                                                                                                    // Setzt den Tag als Datum  (BCD Format)
 0023 550530            mov [_SetTime+5],48
 0026                   .dbline 70
 0026           ;       
 0026           ;       SetTime.Month = 0x07;                                                                                                                   // Setzt den Monat (BCD Format 1 = Januar und 12 = Dezember
 0026 550607            mov [_SetTime+6],7
 0029                   .dbline 72
 0029           ;       
 0029           ;       SetTime.Year = 0x11;                                                                                                                    // setzt das Jahr (BCD Format)
 0029 550711            mov [_SetTime+7],17
 002C                   .dbline 74
 002C           ;       
 002C           ;       RTC_SetTime(&SetTime);                                                                                                          // Ruft die Funktion "RTC_SetTime" auf. Übergibt die Adresse von "SetTime" in die Funktion
 002C 5000              mov A,>_SetTime
 002E 08                push A
 002F 5000              mov A,<_SetTime
 0031 08                push A
 0032 906C              xcall _RTC_SetTime
 0034 38FC              add SP,-4
 0036                   .dbline 76
 0036           ;               
 0036           ;       M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);                                                                             // GPIO Interrupts aktivieren
 0036 43E020            or REG[0xe0],32
 0039 8016              xjmp L11
 003B           L10:
 003B                   .dbline 79
 003B           ; 
 003B           ;       while(1)
 003B           ;       {
 003B                   .dbline 80
 003B           ;               if(fReadRTC)                                                                                                                            // If interrupt has occured
 003B 62D000            mov REG[0xd0],>_fReadRTC
 003E 3C0000            cmp [_fReadRTC],0
 0041 A00E              jz L13
 0043                   .dbline 82
 0043           ;               {
 0043           ;                       fReadRTC = 0x00;                                                                                                                // Clear the Read Flag
 0043                   .dbline 82
 0043 550000            mov [_fReadRTC],0
 0046                   .dbline 83
 0046           ;                       RTC_ReadTime(&Time);                                                                                                    // Ruft die Funktion "RTC_ReadTime" auf und übergibt die Adresse von "Time" in die Funktion
 0046 5000              mov A,>_Time
 0048 08                push A
 0049 5000              mov A,<_Time
 004B 08                push A
 004C 9012              xcall _RTC_ReadTime
 004E 38FE              add SP,-2
 0050                   .dbline 84
 0050           ;               }
 0050           L13:
 0050                   .dbline 85
 0050           ;       }
 0050           L11:
 0050                   .dbline 78
 0050 8FEA              xjmp L10
 0052           X0:
 0052                   .dbline -2
 0052           L2:
 0052                   .dbline 0 ; func end
 0052 8FFF              jmp .
 0054                   .dbend
 0054                   .dbfunc e I2C_Init _I2C_Init fV
 0054           _I2C_Init::
 0054                   .dbline -1
 0054                   .dbline 90
 0054           ; }
 0054           ; 
 0054           ; 
 0054           ; void I2C_Init(void)                                                                                                                                   // Funktion um das I²C Modul zu initialisieren
 0054           ; {
 0054                   .dbline 91
 0054           ;       I2CHW_Start();                                                                                                                                  // I²C Modul starten
 0054 10                push X
 0055 7C0000            xcall _I2CHW_Start
 0058                   .dbline 92
 0058           ;       I2CHW_EnableInt();                                                                                                                              // I²C Interrupts aktivieren
 0058 7C0000            xcall _I2CHW_EnableInt
 005B                   .dbline 93
 005B           ;       I2CHW_EnableMstr();                                                                                                                             // Modul auf "Master" stellen
 005B 7C0000            xcall _I2CHW_EnableMstr
 005E 20                pop X
 005F                   .dbline -2
 005F           L15:
 005F                   .dbline 0 ; func end
 005F 7F                ret
 0060                   .dbend
 0060                   .dbfunc e RTC_ReadTime _RTC_ReadTime fV
 0060                   .dbstruct 0 8 .1
 0060                   .dbfield 0 Address c
 0060                   .dbfield 1 Seconds c
 0060                   .dbfield 2 Minutes c
 0060                   .dbfield 3 Hours c
 0060                   .dbfield 4 Day c
 0060                   .dbfield 5 Date c
 0060                   .dbfield 6 Month c
 0060                   .dbfield 7 Year c
 0060                   .dbend
 0060           ;          pTime -> X-5
 0060           _RTC_ReadTime::
 0060                   .dbline -1
 0060 10                push X
 0061 4F                mov X,SP
 0062                   .dbline 99
 0062           ; }
 0062           ; 
 0062           ; // Diese Funktion ließt die Zeit aus dem DS1307 und speichert diese in dem Buffer
 0062           ; // dessen Adresse mit in die Funktion übergeben wurde
 0062           ; void RTC_ReadTime(RTC_Struct *pTime)
 0062           ; {
 0062                   .dbline 100
 0062           ;       RTC_SetRegAddress(0x00);                                                                                                                // Ruft die Funktion "RTC_SetRegAdress" auf und übergibt eine 0x00 (Register für die Sekunden)
 0062 5000              mov A,0
 0064 08                push A
 0065 90A2              xcall _RTC_SetRegAddress
 0067 38FF              add SP,-1
 0069                   .dbline 101
 0069           ;       I2CHW_fReadBytes(RTC_Addr, (char*)&(pTime->Seconds), 7, I2CHW_CompleteXfer);    // Ließt 7 Bytes aus der RTC und speichert sie unter pTime, beginnend bei "Seconds"
 0069 10                push X
 006A 5000              mov A,0
 006C 08                push A
 006D 5007              mov A,7
 006F 08                push A
 0070 62D000            mov REG[0xd0],>__r0
 0073 52FC              mov A,[X-4]
 0075 0101              add A,1
 0077 5300              mov [__r1],A
 0079 52FB              mov A,[X-5]
 007B 0900              adc A,0
 007D 08                push A
 007E 5100              mov A,[__r1]
 0080 08                push A
 0081 5068              mov A,104
 0083 08                push A
 0084 7C0000            xcall _I2CHW_fReadBytes
 0087 38FB              add SP,-5
 0089 20                pop X
 008A           L17:
 008A                   .dbline 102
 008A           ;       while(!(I2CHW_bReadI2CStatus() & I2CHW_RD_COMPLETE));                                                   // Warten bis der Lesevorgang abgeschlossen ist
 008A           L18:
 008A                   .dbline 102
 008A 10                push X
 008B 7C0000            xcall _I2CHW_bReadI2CStatus
 008E 20                pop X
 008F 62D000            mov REG[0xd0],>__r0
 0092 5300              mov [__r0],A
 0094 470004            tst [__r0],4
 0097 AFF2              jz L17
 0099                   .dbline 103
 0099           ;       I2CHW_ClrRdStatus();                                                                                                                    // Löscht das "Read Complete" Flag
 0099 10                push X
 009A 7C0000            xcall _I2CHW_ClrRdStatus
 009D 20                pop X
 009E                   .dbline -2
 009E           L16:
 009E 20                pop X
 009F                   .dbline 0 ; func end
 009F 7F                ret
 00A0                   .dbsym l pTime -5 pS[.1]
 00A0                   .dbend
 00A0                   .dbfunc e RTC_SetTime _RTC_SetTime fV
 00A0           ;          pTime -> X-5
 00A0           _RTC_SetTime::
 00A0                   .dbline -1
 00A0 10                push X
 00A1 4F                mov X,SP
 00A2                   .dbline 108
 00A2           ; }
 00A2           ; 
 00A2           ; // Diese Funktion speichert die Zeit und das Datum in der RTC
 00A2           ; void RTC_SetTime(RTC_Struct *pTime)
 00A2           ; {     
 00A2                   .dbline 109
 00A2           ;     I2CHW_bWriteBytes(RTC_Addr, (char *)pTime, TIME_LEN, I2CHW_CompleteXfer);         // Schreibt die Daten in die RTC. Das erste Byte von pTime (vom Typ RTC_Struct) 
 00A2 10                push X
 00A3 5000              mov A,0
 00A5 08                push A
 00A6 5008              mov A,8
 00A8 08                push A
 00A9 52FB              mov A,[X-5]
 00AB 08                push A
 00AC 52FC              mov A,[X-4]
 00AE 08                push A
 00AF 5068              mov A,104
 00B1 08                push A
 00B2 7C0000            xcall _I2CHW_bWriteBytes
 00B5 38FB              add SP,-5
 00B7 20                pop X
 00B8           L21:
 00B8                   .dbline 111
 00B8           ;                                                                                                                                                                       // ist das RTC Regster "Adress" und wird gefolgt von 7 Bytes (Datum und Uhrzeit)
 00B8           ;       while(!(I2CHW_bReadI2CStatus() & I2CHW_WR_COMPLETE));                                                   // Warten bis die Übertragung abgeschlossen wurde
 00B8           L22:
 00B8                   .dbline 111
 00B8 10                push X
 00B9 7C0000            xcall _I2CHW_bReadI2CStatus
 00BC 20                pop X
 00BD 62D000            mov REG[0xd0],>__r0
 00C0 5300              mov [__r0],A
 00C2 470040            tst [__r0],64
 00C5 AFF2              jz L21
 00C7                   .dbline 112
 00C7           ;       I2CHW_ClrWrStatus();                                                                                                                    // Löscht das "Write Complete" Flag
 00C7 10                push X
 00C8 7C0000            xcall _I2CHW_ClrWrStatus
 00CB 20                pop X
 00CC                   .dbline -2
 00CC           L20:
 00CC 20                pop X
 00CD                   .dbline 0 ; func end
 00CD 7F                ret
 00CE                   .dbsym l pTime -5 pS[.1]
 00CE                   .dbend
 00CE                   .dbfunc e RTC_WriteReg _RTC_WriteReg fV
 00CE           ;        RTCData -> X+0
 00CE           ;        RegData -> X-5
 00CE           ;     RegAddress -> X-4
 00CE           _RTC_WriteReg::
 00CE                   .dbline -1
 00CE 10                push X
 00CF 4F                mov X,SP
 00D0 3802              add SP,2
 00D2                   .dbline 117
 00D2           ; }
 00D2           ; 
 00D2           ; // Diese Funktion wird verwendet um ein einzelnes Register der RTC zu beschreiben
 00D2           ; void RTC_WriteReg(BYTE RegAddress, BYTE RegData)
 00D2           ; {
 00D2                   .dbline 120
 00D2           ;       BYTE RTCData[2];                                                                                                                                // Deffiniert ein lokales Array mit Namen "RTCData". Dieses Feld
 00D2           ;                                                                                                                                                                       // ist zwei Byte groß
 00D2           ;       RTCData[0] = RegAddress;                                                                                                                // Schreibt an die 1. Stelle (0) des Feldes das was unter "RegAdress" in die Funktion
 00D2 52FC              mov A,[X-4]
 00D4 5400              mov [X+0],A
 00D6                   .dbline 122
 00D6           ;                                                                                                                                                                       // übergeben wurde
 00D6           ;       RTCData[1] = RegData;                                                                                                                   // Schreibt an die 2. Stelle (1) des Feldes das was unter "RegData" in die Funktion
 00D6 52FB              mov A,[X-5]
 00D8 5401              mov [X+1],A
 00DA                   .dbline 124
 00DA           ;                                                                                                                                                                       // übergeben wurde
 00DA           ;     I2CHW_bWriteBytes(RTC_Addr, RTCData, 2, I2CHW_CompleteXfer);                                      // Schreibt den Inhalt des Feldes "RTCData" in die RTC
 00DA 10                push X
 00DB 5000              mov A,0
 00DD 08                push A
 00DE 5002              mov A,2
 00E0 08                push A
 00E1 62D000            mov REG[0xd0],>__r0
 00E4 5007              mov A,7
 00E6 08                push A
 00E7 10                push X
 00E8 5068              mov A,104
 00EA 08                push A
 00EB 7C0000            xcall _I2CHW_bWriteBytes
 00EE 38FB              add SP,-5
 00F0 20                pop X
 00F1           L26:
 00F1                   .dbline 125
 00F1           ;       while(!(I2CHW_bReadI2CStatus() & I2CHW_WR_COMPLETE));                                                   // Warten bis die Übertragung abgeschlossen wurde
 00F1           L27:
 00F1                   .dbline 125
 00F1 10                push X
 00F2 7C0000            xcall _I2CHW_bReadI2CStatus
 00F5 20                pop X
 00F6 62D000            mov REG[0xd0],>__r0
 00F9 5300              mov [__r0],A
 00FB 470040            tst [__r0],64
 00FE AFF2              jz L26
 0100                   .dbline 126
 0100           ;       I2CHW_ClrWrStatus();                                                                                                                    // Löscht das "Write Complete" Flag
 0100 10                push X
 0101 7C0000            xcall _I2CHW_ClrWrStatus
 0104 20                pop X
 0105                   .dbline -2
 0105           L24:
 0105 38FE              add SP,-2
 0107 20                pop X
 0108                   .dbline 0 ; func end
 0108 7F                ret
 0109                   .dbsym l RTCData 0 A[2:2]c
 0109                   .dbsym l RegData -5 c
 0109                   .dbsym l RegAddress -4 c
 0109                   .dbend
 0109                   .dbfunc e RTC_SetRegAddress _RTC_SetRegAddress fV
 0109           ;     RegAddress -> X-4
 0109           _RTC_SetRegAddress::
 0109                   .dbline -1
 0109 10                push X
 010A 4F                mov X,SP
 010B                   .dbline 131
 010B           ; }
 010B           ; 
 010B           ; // Diese Funktion wird verwendet um die Registeradresse zu setzen
 010B           ; void RTC_SetRegAddress(BYTE RegAddress)
 010B           ; {
 010B                   .dbline 132
 010B           ;     I2CHW_bWriteBytes(RTC_Addr, &RegAddress, 1, I2CHW_CompleteXfer);                          // Schreibt die Registeradresse in die RTC
 010B 10                push X
 010C 5000              mov A,0
 010E 08                push A
 010F 5001              mov A,1
 0111 08                push A
 0112 62D000            mov REG[0xd0],>__r0
 0115 5A00              mov [__r1],X
 0117 160004            sub [__r1],4
 011A 5007              mov A,7
 011C 08                push A
 011D 5100              mov A,[__r1]
 011F 08                push A
 0120 5068              mov A,104
 0122 08                push A
 0123 7C0000            xcall _I2CHW_bWriteBytes
 0126 38FB              add SP,-5
 0128 20                pop X
 0129           L30:
 0129                   .dbline 133
 0129           ;       while(!(I2CHW_bReadI2CStatus() & I2CHW_WR_COMPLETE));                                                   // Wartet bis die Übertragung abgeschlossen wurde
 0129           L31:
 0129                   .dbline 133
 0129 10                push X
 012A 7C0000            xcall _I2CHW_bReadI2CStatus
 012D 20                pop X
 012E 62D000            mov REG[0xd0],>__r0
 0131 5300              mov [__r0],A
 0133 470040            tst [__r0],64
 0136 AFF2              jz L30
 0138                   .dbline 134
 0138           ;       I2CHW_ClrWrStatus();                                                                                                                    // Löscht das "Write Complete" Flag
 0138 10                push X
 0139 7C0000            xcall _I2CHW_ClrWrStatus
 013C 20                pop X
 013D                   .dbline -2
 013D           L29:
 013D 20                pop X
 013E                   .dbline 0 ; func end
 013E 7F                ret
 013F                   .dbsym l RegAddress -4 c
 013F                   .dbend
 013F                   .dbfunc e Print_Time _Print_Time fV
 013F           ;          pTime -> X-5
 013F           _Print_Time::
 013F                   .dbline -1
 013F 10                push X
 0140 4F                mov X,SP
 0141 3802              add SP,2
 0143                   .dbline 139
 0143           ; }
 0143           ; 
 0143           ; // Zeit und Datum auf dem LCD anzeigen
 0143           ; void Print_Time(RTC_Struct *pTime)
 0143           ; {
 0143                   .dbline 140
 0143           ;       LCD_Position(0,0);                                                                                                                              // Position the cursor on the LCD for displaying data
 0143 10                push X
 0144 5000              mov A,0
 0146 5700              mov X,0
 0148 7C0000            xcall _LCD_Position
 014B 20                pop X
 014C                   .dbline 141
 014C           ;       if(pTime->Hours & 0x40)                                                                                                                 // True if 12 hours format is used and false if 24 hours format is used                                                                                                                                                         
 014C 62D000            mov REG[0xd0],>__r0
 014F 52FC              mov A,[X-4]
 0151 0103              add A,3
 0153 5300              mov [__r1],A
 0155 52FB              mov A,[X-5]
 0157 0900              adc A,0
 0159 60D4              mov REG[0xd4],A
 015B 3E00              mvi A,[__r1]
 015D 5300              mov [__r0],A
 015F 470040            tst [__r0],64
 0162 A01D              jz L34
 0164                   .dbline 143
 0164           ;       {                                                                                                                                                               // Display Hours on the LCD
 0164           ;               LCD_PrHexByte(pTime->Hours & 0x1F);
 0164                   .dbline 143
 0164 52FC              mov A,[X-4]
 0166 0103              add A,3
 0168 5300              mov [__r1],A
 016A 52FB              mov A,[X-5]
 016C 0900              adc A,0
 016E 60D4              mov REG[0xd4],A
 0170 3E00              mvi A,[__r1]
 0172 5300              mov [__r0],A
 0174 26001F            and [__r0],31
 0177 10                push X
 0178 5100              mov A,[__r0]
 017A 7C0000            xcall _LCD_PrHexByte
 017D 20                pop X
 017E                   .dbline 144
 017E           ;       }
 017E 801E              xjmp L35
 0180           L34:
 0180                   .dbline 146
 0180           ;       else
 0180           ;       {
 0180                   .dbline 147
 0180           ;               LCD_PrHexByte(pTime->Hours & 0x3F);
 0180 62D000            mov REG[0xd0],>__r0
 0183 52FC              mov A,[X-4]
 0185 0103              add A,3
 0187 5300              mov [__r1],A
 0189 52FB              mov A,[X-5]
 018B 0900              adc A,0
 018D 60D4              mov REG[0xd4],A
 018F 3E00              mvi A,[__r1]
 0191 5300              mov [__r0],A
 0193 26003F            and [__r0],63
 0196 10                push X
 0197 5100              mov A,[__r0]
 0199 7C0000            xcall _LCD_PrHexByte
 019C 20                pop X
 019D                   .dbline 148
 019D           ;       }       
 019D           L35:
 019D                   .dbline 150
 019D           ;       
 019D           ;       LCD_PrCString(":");                                                                                                                             // Zeigt einen ":" an
 019D 10                push X
 019E 503B              mov A,>L36
 01A0 08                push A
 01A1 503B              mov A,<L36
 01A3 5C                mov X,A
 01A4 18                pop A
 01A5 7C0000            xcall _LCD_PrCString
 01A8 20                pop X
 01A9                   .dbline 152
 01A9           ;       
 01A9           ;       LCD_PrHexByte(pTime->Minutes);                                                                                                  // Zeigt die Minuten auf dem LCD an
 01A9 62D000            mov REG[0xd0],>__r0
 01AC 52FC              mov A,[X-4]
 01AE 0102              add A,2
 01B0 5300              mov [__r1],A
 01B2 52FB              mov A,[X-5]
 01B4 0900              adc A,0
 01B6 60D4              mov REG[0xd4],A
 01B8 3E00              mvi A,[__r1]
 01BA 10                push X
 01BB 7C0000            xcall _LCD_PrHexByte
 01BE                   .dbline 153
 01BE           ;       LCD_PrCString(":");
 01BE 503B              mov A,>L36
 01C0 08                push A
 01C1 503B              mov A,<L36
 01C3 5C                mov X,A
 01C4 18                pop A
 01C5 7C0000            xcall _LCD_PrCString
 01C8 20                pop X
 01C9                   .dbline 155
 01C9           ;       
 01C9           ;       LCD_PrHexByte(pTime->Seconds);                                                                                                  // Zeigt die Sekunden auf dem LCD an
 01C9 62D000            mov REG[0xd0],>__r0
 01CC 52FC              mov A,[X-4]
 01CE 0101              add A,1
 01D0 5300              mov [__r1],A
 01D2 52FB              mov A,[X-5]
 01D4 0900              adc A,0
 01D6 60D4              mov REG[0xd4],A
 01D8 3E00              mvi A,[__r1]
 01DA 10                push X
 01DB 7C0000            xcall _LCD_PrHexByte
 01DE 20                pop X
 01DF                   .dbline 157
 01DF           ;               
 01DF           ;       if(pTime->Hours & 0x40)                                                                                                                 // Der Zeiger "pTime" zeigt auf die Stelle "Hours" und es 
 01DF 62D000            mov REG[0xd0],>__r0
 01E2 52FC              mov A,[X-4]
 01E4 0103              add A,3
 01E6 5300              mov [__r1],A
 01E8 52FB              mov A,[X-5]
 01EA 0900              adc A,0
 01EC 60D4              mov REG[0xd4],A
 01EE 3E00              mvi A,[__r1]
 01F0 5300              mov [__r0],A
 01F2 470040            tst [__r0],64
 01F5 A030              jz L37
 01F7                   .dbline 159
 01F7           ;       {                                                                                                                                                               // wird entschieden ob 12h oder 24h Modus
 01F7           ;               if(pTime->Hours & 0x20)                                                                                                         // Prüft ob "PM" oder "AM" angezeigt werden muss
 01F7                   .dbline 159
 01F7 52FC              mov A,[X-4]
 01F9 0103              add A,3
 01FB 5300              mov [__r1],A
 01FD 52FB              mov A,[X-5]
 01FF 0900              adc A,0
 0201 60D4              mov REG[0xd4],A
 0203 3E00              mvi A,[__r1]
 0205 5300              mov [__r0],A
 0207 470020            tst [__r0],32
 020A A00F              jz L39
 020C                   .dbline 160
 020C           ;               LCD_PrCString(" PM");
 020C 10                push X
 020D 5037              mov A,>L41
 020F 08                push A
 0210 5037              mov A,<L41
 0212 5C                mov X,A
 0213 18                pop A
 0214 7C0000            xcall _LCD_PrCString
 0217 20                pop X
 0218 800D              xjmp L40
 021A           L39:
 021A                   .dbline 162
 021A           ;               else
 021A           ;               LCD_PrCString(" AM");
 021A 10                push X
 021B 5033              mov A,>L42
 021D 08                push A
 021E 5033              mov A,<L42
 0220 5C                mov X,A
 0221 18                pop A
 0222 7C0000            xcall _LCD_PrCString
 0225 20                pop X
 0226           L40:
 0226                   .dbline 163
 0226           ;       }
 0226           L37:
 0226                   .dbline 166
 0226           ;       
 0226           ;       // Zeigt das Datum an
 0226           ;       LCD_Position(1,0);
 0226 10                push X
 0227 5700              mov X,0
 0229 5001              mov A,1
 022B 7C0000            xcall _LCD_Position
 022E 20                pop X
 022F                   .dbline 167
 022F           ;       LCD_PrHexByte(pTime->Date);
 022F 62D000            mov REG[0xd0],>__r0
 0232 52FC              mov A,[X-4]
 0234 0105              add A,5
 0236 5300              mov [__r1],A
 0238 52FB              mov A,[X-5]
 023A 0900              adc A,0
 023C 60D4              mov REG[0xd4],A
 023E 3E00              mvi A,[__r1]
 0240 10                push X
 0241 7C0000            xcall _LCD_PrHexByte
 0244                   .dbline 168
 0244           ;       LCD_PrCString("/");
 0244 5031              mov A,>L43
 0246 08                push A
 0247 5031              mov A,<L43
 0249 5C                mov X,A
 024A 18                pop A
 024B 7C0000            xcall _LCD_PrCString
 024E 20                pop X
 024F                   .dbline 171
 024F           ;       
 024F           ;       // Zeigt den Monat an
 024F           ;       LCD_PrHexByte(pTime->Month);
 024F 62D000            mov REG[0xd0],>__r0
 0252 52FC              mov A,[X-4]
 0254 0106              add A,6
 0256 5300              mov [__r1],A
 0258 52FB              mov A,[X-5]
 025A 0900              adc A,0
 025C 60D4              mov REG[0xd4],A
 025E 3E00              mvi A,[__r1]
 0260 10                push X
 0261 7C0000            xcall _LCD_PrHexByte
 0264                   .dbline 172
 0264           ;       LCD_PrCString("/");
 0264 5031              mov A,>L43
 0266 08                push A
 0267 5031              mov A,<L43
 0269 5C                mov X,A
 026A 18                pop A
 026B 7C0000            xcall _LCD_PrCString
 026E 20                pop X
 026F                   .dbline 175
 026F           ;       
 026F           ;       // Zeigt das Jahr an
 026F           ;       LCD_PrHexByte(pTime->Year);
 026F 62D000            mov REG[0xd0],>__r0
 0272 52FC              mov A,[X-4]
 0274 0107              add A,7
 0276 5300              mov [__r1],A
 0278 52FB              mov A,[X-5]
 027A 0900              adc A,0
 027C 60D4              mov REG[0xd4],A
 027E 3E00              mvi A,[__r1]
 0280 10                push X
 0281 7C0000            xcall _LCD_PrHexByte
 0284 20                pop X
 0285                   .dbline 178
 0285           ;       
 0285           ;       // Zeigt den Wochentag an
 0285           ;       switch(pTime->Day)
 0285 62D000            mov REG[0xd0],>__r0
 0288 52FC              mov A,[X-4]
 028A 0104              add A,4
 028C 5300              mov [__r1],A
 028E 52FB              mov A,[X-5]
 0290 0900              adc A,0
 0292 60D4              mov REG[0xd4],A
 0294 3E00              mvi A,[__r1]
 0296 5401              mov [X+1],A
 0298 560000            mov [X+0],0
 029B 3D0000            cmp [X+0],0
 029E B006              jnz X1
 02A0 3D0101            cmp [X+1],1
 02A3 A03F              jz L47
 02A5           X1:
 02A5 3D0000            cmp [X+0],0
 02A8 B006              jnz X2
 02AA 3D0102            cmp [X+1],2
 02AD A043              jz L49
 02AF           X2:
 02AF 3D0000            cmp [X+0],0
 02B2 B006              jnz X3
 02B4 3D0103            cmp [X+1],3
 02B7 A047              jz L51
 02B9           X3:
 02B9 3D0000            cmp [X+0],0
 02BC B006              jnz X4
 02BE 3D0104            cmp [X+1],4
 02C1 A04B              jz L53
 02C3           X4:
 02C3 3D0000            cmp [X+0],0
 02C6 B006              jnz X5
 02C8 3D0105            cmp [X+1],5
 02CB A04F              jz L55
 02CD           X5:
 02CD 3D0000            cmp [X+0],0
 02D0 B006              jnz X6
 02D2 3D0106            cmp [X+1],6
 02D5 A053              jz L57
 02D7           X6:
 02D7 3D0000            cmp [X+0],0
 02DA B006              jnz X7
 02DC 3D0107            cmp [X+1],7
 02DF A057              jz L59
 02E1           X7:
 02E1 8061              xjmp L44
 02E3           L47:
 02E3                   .dbline 180
 02E3           ;       {
 02E3           ;               case 1: LCD_PrCString(" (SUN)");
 02E3 10                push X
 02E4 502A              mov A,>L48
 02E6 08                push A
 02E7 502A              mov A,<L48
 02E9 5C                mov X,A
 02EA 18                pop A
 02EB 7C0000            xcall _LCD_PrCString
 02EE 20                pop X
 02EF                   .dbline 181
 02EF           ;                               break;
 02EF 8053              xjmp L45
 02F1           L49:
 02F1                   .dbline 183
 02F1           ;                               
 02F1           ;               case 2: LCD_PrCString(" (MON)");
 02F1 10                push X
 02F2 5023              mov A,>L50
 02F4 08                push A
 02F5 5023              mov A,<L50
 02F7 5C                mov X,A
 02F8 18                pop A
 02F9 7C0000            xcall _LCD_PrCString
 02FC 20                pop X
 02FD                   .dbline 184
 02FD           ;                               break;
 02FD 8045              xjmp L45
 02FF           L51:
 02FF                   .dbline 186
 02FF           ;                               
 02FF           ;               case 3: LCD_PrCString(" (TUE)");
 02FF 10                push X
 0300 501C              mov A,>L52
 0302 08                push A
 0303 501C              mov A,<L52
 0305 5C                mov X,A
 0306 18                pop A
 0307 7C0000            xcall _LCD_PrCString
 030A 20                pop X
 030B                   .dbline 187
 030B           ;                               break;
 030B 8037              xjmp L45
 030D           L53:
 030D                   .dbline 189
 030D           ;                               
 030D           ;               case 4: LCD_PrCString(" (WED)");
 030D 10                push X
 030E 5015              mov A,>L54
 0310 08                push A
 0311 5015              mov A,<L54
 0313 5C                mov X,A
 0314 18                pop A
 0315 7C0000            xcall _LCD_PrCString
 0318 20                pop X
 0319                   .dbline 190
 0319           ;                               break;
 0319 8029              xjmp L45
 031B           L55:
 031B                   .dbline 192
 031B           ;                               
 031B           ;               case 5: LCD_PrCString(" (THU)");
 031B 10                push X
 031C 500E              mov A,>L56
 031E 08                push A
 031F 500E              mov A,<L56
 0321 5C                mov X,A
 0322 18                pop A
 0323 7C0000            xcall _LCD_PrCString
 0326 20                pop X
 0327                   .dbline 193
 0327           ;                               break;
 0327 801B              xjmp L45
 0329           L57:
 0329                   .dbline 195
 0329           ;               
 0329           ;               case 6: LCD_PrCString(" (FRI)");
 0329 10                push X
 032A 5007              mov A,>L58
 032C 08                push A
 032D 5007              mov A,<L58
 032F 5C                mov X,A
 0330 18                pop A
 0331 7C0000            xcall _LCD_PrCString
 0334 20                pop X
 0335                   .dbline 196
 0335           ;                               break;
 0335 800D              xjmp L45
 0337           L59:
 0337                   .dbline 198
 0337           ;                               
 0337           ;               case 7: LCD_PrCString(" (SAT)");
 0337 10                push X
 0338 5000              mov A,>L60
 033A 08                push A
 033B 5000              mov A,<L60
 033D 5C                mov X,A
 033E 18                pop A
 033F 7C0000            xcall _LCD_PrCString
 0342 20                pop X
 0343                   .dbline 199
 0343           ;                               break;
 0343           L44:
 0343           L45:
 0343                   .dbline -2
 0343           L33:
 0343 38FE              add SP,-2
 0345 20                pop X
 0346                   .dbline 0 ; func end
 0346 7F                ret
 0347                   .dbsym l pTime -5 pS[.1]
 0347                   .dbend
 0347                   .dbfunc e RTC_Read_ISR _RTC_Read_ISR fV
 0347           ;          dummy -> X+0
 0347           _RTC_Read_ISR::
 0347                   .dbline -1
 0347 71C0              or F,-64
 0349 08                push A
 034A 5DD0              mov A,REG[0xd0]
 034C 08                push A
 034D 5DD3              mov A,REG[0xd3]
 034F 08                push A
 0350 5DD4              mov A,REG[0xd4]
 0352 08                push A
 0353 5DD5              mov A,REG[0xd5]
 0355 08                push A
 0356 62D000            mov REG[0xd0],>__r0
 0359 5100              mov A,[__r0]
 035B 08                push A
 035C 5100              mov A,[__r1]
 035E 08                push A
 035F 5100              mov A,[__r2]
 0361 08                push A
 0362 5100              mov A,[__r3]
 0364 08                push A
 0365 5100              mov A,[__r4]
 0367 08                push A
 0368 5100              mov A,[__r5]
 036A 08                push A
 036B 5100              mov A,[__r6]
 036D 08                push A
 036E 5100              mov A,[__r7]
 0370 08                push A
 0371 5100              mov A,[__r8]
 0373 08                push A
 0374 5100              mov A,[__r9]
 0376 08                push A
 0377 5100              mov A,[__r10]
 0379 08                push A
 037A 5100              mov A,[__r11]
 037C 08                push A
 037D 5100              mov A,[__rX]
 037F 08                push A
 0380 5100              mov A,[__rY]
 0382 08                push A
 0383 5100              mov A,[__rZ]
 0385 08                push A
 0386 10                push X
 0387 4F                mov X,SP
 0388 3801              add SP,1
 038A                   .dbline 206
 038A           ;                               
 038A           ;       }
 038A           ; }
 038A           ; 
 038A           ; // ISR um die RTC auszulesen
 038A           ; void RTC_Read_ISR(void)
 038A           ; {
 038A                   .dbline 208
 038A           ;       BYTE dummy;
 038A           ;       fReadRTC = 0x01;                                                                                                                                        // Event used to read data from RTC 
 038A 62D000            mov REG[0xd0],>_fReadRTC
 038D 550001            mov [_fReadRTC],1
 0390                   .dbline 209
 0390           ;       dummy = PRT1DR;                                                                                                                                         // Ließt Port1 um den "ChangeFromRead" Interrupt auszulösen
 0390 5D04              mov A,REG[0x4]
 0392 5400              mov [X+0],A
 0394                   .dbline 210
 0394           ;       Print_Time(&Time);                                                                                                                                      // Ruft die Funktion "Print_Time" auf und übergibt die Adresse
 0394 5000              mov A,>_Time
 0396 08                push A
 0397 5000              mov A,<_Time
 0399 08                push A
 039A 9DA3              xcall _Print_Time
 039C 38FE              add SP,-2
 039E                   .dbline -2
 039E           L61:
 039E 38FF              add SP,-1
 03A0 20                pop X
 03A1 62D000            mov REG[0xD0],>__r0
 03A4 18                pop A
 03A5 5300              mov [__rZ],A
 03A7 18                pop A
 03A8 5300              mov [__rY],A
 03AA 18                pop A
 03AB 5300              mov [__rX],A
 03AD 18                pop A
 03AE 5300              mov [__r11],A
 03B0 18                pop A
 03B1 5300              mov [__r10],A
 03B3 18                pop A
 03B4 5300              mov [__r9],A
 03B6 18                pop A
 03B7 5300              mov [__r8],A
 03B9 18                pop A
 03BA 5300              mov [__r7],A
 03BC 18                pop A
 03BD 5300              mov [__r6],A
 03BF 18                pop A
 03C0 5300              mov [__r5],A
 03C2 18                pop A
 03C3 5300              mov [__r4],A
 03C5 18                pop A
 03C6 5300              mov [__r3],A
 03C8 18                pop A
 03C9 5300              mov [__r2],A
 03CB 18                pop A
 03CC 5300              mov [__r1],A
 03CE 18                pop A
 03CF 5300              mov [__r0],A
 03D1 18                pop A
 03D2 60D5              mov REG[213],A
 03D4 18                pop A
 03D5 60D4              mov REG[212],A
 03D7 18                pop A
 03D8 60D3              mov REG[211],A
 03DA 18                pop A
 03DB 60D0              mov REG[208],A
 03DD 18                pop A
 03DE                   .dbline 0 ; func end
 03DE 7E                reti
 03DF                   .dbsym l dummy 0 c
 03DF                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\DS1307\DS1307\DS1307\main.c
 0000           _SetTime::
 0000 0000000000000000  .byte 0,0,0,0,0,0,0,0
 0008                   .dbsym e SetTime _SetTime S[.1]
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\DS1307\DS1307\DS1307\main.c
 0000           _Time::
 0000 0000000000000000  .byte 0,0,0,0,0,0,0,0
 0008                   .dbsym e Time _Time S[.1]
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\DS1307\DS1307\DS1307\main.c
 0000           _fReadRTC::
 0000 00                .byte 0
 0001                   .dbsym e fReadRTC _fReadRTC c
                        .area data(ram, con, rel)
 0000                   .dbfile H:\Hobby\PROGRA~1\PSOCPR~1\DS1307\DS1307\DS1307\main.c
 0000           _bRTC_RegPointer::
 0000 00                .byte 0
 0001                   .dbsym e bRTC_RegPointer _bRTC_RegPointer c
                        .area lit(rom, con, rel, lit)
 0000           L60:
 0000 20285341542900    .byte 32,40,'S,'A,'T,41,0
 0007           L58:
 0007 20284652492900    .byte 32,40,'F,'R,'I,41,0
 000E           L56:
 000E 20285448552900    .byte 32,40,'T,'H,'U,41,0
 0015           L54:
 0015 20285745442900    .byte 32,40,'W,'E,'D,41,0
 001C           L52:
 001C 20285455452900    .byte 32,40,'T,'U,'E,41,0
 0023           L50:
 0023 20284D4F4E2900    .byte 32,40,'M,'O,'N,41,0
 002A           L48:
 002A 202853554E2900    .byte 32,40,'S,'U,'N,41,0
 0031           L43:
 0031 2F00              .byte 47,0
 0033           L42:
 0033 20414D00          .byte 32,'A,'M,0
 0037           L41:
 0037 20504D00          .byte 32,'P,'M,0
 003B           L36:
 003B 3A00              .byte 58,0
