;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: I2CHW_Mstr.asm
;;  Version: 1.90, Updated on 2012/9/21 at 11:59:4
;;  Generated by PSoC Designer 5.3.2710
;;
;;  DESCRIPTION: I2CHW MultiMaster User Module software implementation file
;;
;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API
;;        function returns. Even though these registers may be preserved now,
;;        there is no guarantee they will be preserved in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "I2CHWCommon.inc"
include "I2CHWMMS.inc"
include "I2CHWMstr.inc"

;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------

export   I2CHW_fSendRepeatStart
export  _I2CHW_fSendRepeatStart
export   I2CHW_fSendStart
export  _I2CHW_fSendStart
export   I2CHW_SendStop
export  _I2CHW_SendStop
export   I2CHW_fReadBytesNoStall
export  _I2CHW_fReadBytesNoStall
export   I2CHW_fReadBytes
export  _I2CHW_fReadBytes
export   I2CHW_bWriteBytesNoStall
export  _I2CHW_bWriteBytesNoStall
export   I2CHW_bWriteBytes
export  _I2CHW_bWriteBytes
export   I2CHW_bWriteCBytesNoStall
export  _I2CHW_bWriteCBytesNoStall
export   I2CHW_bWriteCBytes
export  _I2CHW_bWriteCBytes

export   I2CHW_fWrite
export  _I2CHW_fWrite

export   I2CHW_bRead
export  _I2CHW_bRead



;-------------------------------------------------------------------
;  Declare the varables for both the assembler and C compiler.
;-------------------------------------------------------------------
export  I2CHW_bStatus
export _I2CHW_bStatus

export  I2CHW_RsrcStatus
export _I2CHW_RsrcStatus
;export   I2CHW_bData
;export  _I2CHW_bData

;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------
area InterruptRAM(RAM, REL, CON)

_I2CHW_bStatus:
 I2CHW_bStatus:                      BLK  1   ; Bus Status during transfers

_I2CHW_RsrcStatus:
 I2CHW_RsrcStatus:                   BLK  1   ; Bus Status during transfers

AREA UserModules (ROM, REL)
;-----------------------------------------------
;  EQUATES
;-----------------------------------------------
I2CHW_SLAVE_ACKed:                   equ 0x01 ; This bit set if Slave ACKed Master
I2CHW_SEND_ACK:                      equ 0x10 ; If this flag set, Master should send ACK

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_bWriteBytesNoStall
;
;  DESCRIPTION:
;    Write multiple data bytes to slave device from RAM. This function allows
;    for proper bus arbitration when there is more than one master on the bus
;    by first checking to see if the bus is busy.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
; [SP-7]=> Mode flags that allow the programmer to set flags
;          to determine if:
;              0x01 => Use RePeatStart instead of Start
;              0x02 => Don't send Stop
; [SP-6]=> Count of bytes to write.
; [SP-5]=> MSB of Array address to put data in (ignored small mem model).
; [SP-4]=> LSB of Array address to put data in.
; [SP-3]=> Address of slave
;
;
;  RETURNS:  Master Status/Control register or 0xFF if the bus was busy.
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;    1. Checks if the Bus is free.
;    2. If busy returns 0xFF.
;    3. Else continues the transmission via entry into the bWriteBytes API.
;
;-----------------------------------------------------------------------------
TxMode:       equ  -7
TxByteCount:  equ  -6
TxArrayHI:    equ  -5
TxArrayLO:    equ  -4
TxSlaveAddr:  equ  -3
 I2CHW_bWriteBytesNoStall:
_I2CHW_bWriteBytesNoStall:

    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_2
    RAM_SETPAGE_CUR >I2CHW_MasterStatus

	mov   X, SP
	;test the I2CM_BUSBUSY bit in the MSCR reg
	tst reg[I2CHW_MSCR], I2CM_BUSBUSY
	jz I2C_BusFree2
        mov A, 0xff;   bus busy
	ret
        
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_bWriteBytes
;
;  DESCRIPTION:
;    Write multiple data bytes to slave device from RAM.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
; [SP-7]=> Mode flags that allow the programmer to set flags
;          to determine if:
;              0x01 => Use RePeatStart instead of Start
;              0x02 => Don't send Stop
; [SP-6]=> Count of bytes to write.
; [SP-5]=> MSB of Array address to put data in (ignored small mem model).
; [SP-4]=> LSB of Array address to put data in.
; [SP-3]=> Address of slave
;
;
;  RETURNS:  Bus Status
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;    1. Checks if the Bus is free.  If not, sets the ERROR and BUS_BUSY flags and exits
;    2. If the I2CHW_ISR_ACTIVE indicates that the I2CHW_ISR is already 
;       running this routine will pend on the ISR_ACTIVE bit until it can run
;    3. Initializes the Read buffer in RAM to read data to be sent
;    4. Performs a Start or Restart according the Mode specified
;    5. The rest is taken care of by the ISR
;
;-----------------------------------------------------------------------------         
TxMode:       equ  -7
TxByteCount:  equ  -6
TxArrayHI:    equ  -5
TxArrayLO:    equ  -4
TxSlaveAddr:  equ  -3

 I2CHW_bWriteBytes:
_I2CHW_bWriteBytes:

    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_2
    RAM_SETPAGE_CUR >I2CHW_MasterStatus

	mov   X, SP
	
	; Write code here to test the bus busy flag proceed with the start only if the
	; bus is free.  If the bus is busy, set flag in the status register and exit
	
I2C_BusFree2:
    ;push  A
I2CMSCR_NotReady2:
    I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
    tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE
    ;mov   A, reg[I2CHW_MSCR]                              ;read the mscr register to look for pending master operations
    ;and   A, 0x0f                                         ;only look at the lower bits
         
         
         
    jnz   I2CMSCR_NotReady2
    ;pop   A

	mov [I2CHW_bStatus],0				                                 ; Clear all Error flags
	tst [X+RxMode],I2CHW_RepStart
	jnz BypassBusBusy2					                                   ; Check transfer is with a Repeat Start condition
										                                                 ;  Then no need to check if the bus is busy.
;   This doesn't seem to contribute, causes lock ups
;   BUS_BUSY is cleared automatically when a stop condition happens &
;   the master will not generate a start when the bus it busy anyway.
;	tst REG[I2C_MSCR],I2CM_BUSBUSY		                         ; Test if the Bus is busy
;	jnz I2C_ReturnBusBusy				                                ; If free proceed

BypassBusBusy2:
    or    [I2CHW_bStatus], I2CHW_ISR_ACTIVE       	   ; flag set here and cleared at end of ISR
    mov   A, [X + TxSlaveAddr]
    asl   A                                                ; Shift address to the left to make
                                                           ; a complete byte with the R/W bit.
                                                           ; The ASL takes care of clearing bit 0.
    mov   [I2CHW_SlaveAddr], A                             ; preserve addr+r/w state for the ISR to use
    mov   reg[I2CHW_DR], A                                 ; put the write addr into the I2C_DR reg
    mov   A, [X+TxMode]                                                             ; place the TxMode in status so ISR can access it
    or   [I2CHW_bStatus],A
    ;
    ;we must now initialize a read buffer using I2CHW_InitMasterRamRead
    ;
    push   X                                                 ;preserve since it's used later
    inc    [X+TxByteCount]                                   ;increase this by one since the init routine will decrement it by 1
                                                             ;but the ISR understands the original count passed (sigh...)(F.O.E.O.)
    mov    A, [X+TxByteCount]                                ;get the write buf size
    push   A
    mov    A, [X+TxArrayHI]                                  ;get the write buf addr
    push   A                                                                                            ;this will be ignored
    mov    A, [X+TxArrayLO]                                  ;get the write buf addr
    push   A
    call  I2CHW_InitMasterRamRead                          ;sets the addr and byte count to write to
    add SP, -3
    pop X                                                    ;restore X to be used for the rest of this routine
    ;and  [I2CHW_MasterStatus],~I2C_READFLASH              ;shouldn't be needed should have been taken care of in InitMasterRamRead routine


    mov   A,[I2CHW_SlaveAddr]
    tst   [x+TxMode],I2CHW_RepStart
    jnz   DoRestartTx
    tst   reg[I2CHW_SCR], I2C_BYTE_COMPL                 ; indicates the I2C bus is stalled
    jnz   DoRestartRx
    call  I2CHW_DoStart                                      ; Send a start and address.
    jmp   DoTxAck
DoRestartTx:
    call  I2CHW_DoBufferRepeatStart                          ; Send a repeat start and address.
DoTxAck:


WriteSlaveAck:
    mov  a,[I2CHW_bStatus]
    RAM_EPILOGUE RAM_USE_CLASS_2
	RAM_EPILOGUE RAM_USE_CLASS_4
    ret

.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_fReadBytesNoStall
;
;  DESCRIPTION:
;    Reads Multiple bytes from Slave. This function allows
;    for proper bus arbitration when there is more than one master on the bus
;    by first checking to see if the bus is busy.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;  [SP-7]=> Mode flags that allow the programmer to set flags
;           to determine if:
;             0x01 => Use RepeatStart instead of Start
;             0x02 => Don't send Stop
;  [SP-6]=> Count of bytes to read.
;  [SP-5]=> MSB of Array address to put data in (ignorned for small mem model)
;  [SP-4]=> LSB of Array address to put data in 
;  [SP-3]=> Address of slave
;
;  RETURNS:  Master Status/Control register or 0xFF if the bus was busy.
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;    1. Checks if the Bus is free.
;    2. If busy returns 0xFF.
;    3. Else continues the transmission via entry into the fReadBytes API.
;
;-----------------------------------------------------------------------------
RxMode:         equ  -7
RxCnt:          equ  -6
RxArrayHI:      equ  -5
RxArrayLO:      equ  -4
RxSlaveAddr:    equ  -3
 I2CHW_fReadBytesNoStall:
_I2CHW_fReadBytesNoStall:

    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_2
    RAM_SETPAGE_CUR >I2CHW_MasterStatus

	mov   X, SP
	;test the I2CM_BUSBUSY bit in the MSCR reg
	tst reg[I2CHW_MSCR], I2CM_BUSBUSY
	jz I2C_BusFree1
        mov A, 0xff;   bus busy
	ret
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_fReadBytes
;
;  DESCRIPTION:
;    Reads Multiple bytes from Slave
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;  [SP-7]=> Mode flags that allow the programmer to set flags
;           to determine if:
;             0x01 => Use RepeatStart instead of Start
;             0x02 => Don't send Stop
;  [SP-6]=> Count of bytes to read.
;  [SP-5]=> MSB of Array address to put data in (ignorned for small mem model)
;  [SP-4]=> LSB of Array address to put data in 
;  [SP-3]=> Address of slave
;
;  RETURNS:  The Bus Status
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;    1. Checks if the Bus is free.  If not, sets the ERROR and BUS_BUSY flags and exits
;    2. If the I2CHW_ISR_ACTIVE indicates that the I2CHW_ISR is already 
;       running this routine will pend on the ISR_ACTIVE bit until it can run
;    3. Initializes the write buffer in RAM for Master to deposit data
;    4. Performs a Start or Restart according the Mode specified
;    5. The rest is taken care of by the ISR
;
;----------------------------------------------------------------------------- 
RxMode:         equ  -7
RxCnt:          equ  -6
RxArrayHI:      equ  -5
RxArrayLO:      equ  -4
RxSlaveAddr:    equ  -3

 I2CHW_fReadBytes:
_I2CHW_fReadBytes:

    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_2
	RAM_SETPAGE_CUR >I2CHW_MasterStatus
	mov   X, SP
	
I2C_BusFree1:	
    ;push  A
I2CMSCR_NotReady1:
    I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
	tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE
    ;mov   A, reg[I2CHW_MSCR]                            ;read the mscr register to look for pending master operations
    ;and   A, 0x0f                                         ;only look at the lower bits
         
         
         
         
	; Here a Timeout condition may be used to get out if the program hangs
	jnz   I2CMSCR_NotReady1
	;pop   A

	mov [I2CHW_bStatus],0						; Clear the Error Flags

	tst [X+RxMode],I2CHW_RepStart
	jnz BypassBusBusy1							                                 ; Check if transfer is with a Repeat Start condition
												                                               ;  Then no need to check if the bus is busy.

BypassBusBusy1:
	or    [I2CHW_bStatus], I2CHW_ISR_ACTIVE       		; flag set here and cleared by ISR
    mov   A, [X + TxSlaveAddr]
	asl   A                                                	  ; Shift address to the left to make
                                                           	 ; a complete byte with the R/W bit.
    or    A,0x01                                           	 ; OR the address with the Read bit.
    mov   [I2CHW_SlaveAddr], A                             ; preserve addr+r/w state for the ISR to use
    mov   reg[I2CHW_DR], A                                 ; put the write addr into the I2C_DR reg
    mov   A, [X+RxMode]                                      ; place the RxMode in status so ISR can access it
    or   [I2CHW_bStatus],A						                           ; Set the Mode bit in Status register

    ;
    ;we must now initialize a read buffer using I2CHW_InitMasterWrite
    ;
    push   X                                               ;preserve since it's used later
    mov    A, [X+RxCnt]                                    ;get the write buf size
    push   A										    
    mov    A, [X+RxArrayHI]                                ;get the write addrHI
    push   A										   
    mov    A, [X+RxArrayLO]							                         ;get the write addrLO
    push   A                                               ;this will be ignored
    call  I2CHW_InitMasterWrite                            ;sets the addr and byte count to write to
    add    SP, -3
    pop    X                                               ;restore X to be used for the rest of this routine

    mov   A,[I2CHW_SlaveAddr]
    tst   [x+RxMode],I2CHW_RepStart
    jnz   DoRestartRx
    tst   reg[I2CHW_SCR], I2C_BYTE_COMPL                   ; indicates the I2C bus is stalled
    jnz   DoRestartRx
    call  I2CHW_DoStart                                    ; Send a start and address.
    jmp   CheckRxAck

DoRestartRx:
	
    call  I2CHW_DoBufferRepeatStart                          ; Send a repeat start and address.

        ; note that REPEATSTART can only be used if this master currently has control of the bus and is at the end
        ; of or ending the current data transmission/reception.  This also requres that the software (this UM)
        ; as a whole be able to detect that a stop has not been sent previously in this transmission.

CheckRxAck:                                                ; Test to see if Slave ACKed
        ;nothing to do here, a start and address are being transmitted, wait for the ISR to pick up, when it
        ;is finished.
End_RD:
    mov  a,[I2CHW_bStatus]
    RAM_EPILOGUE RAM_USE_CLASS_2
    RAM_EPILOGUE RAM_USE_CLASS_4
	ret

.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_bWriteCBytesNoStall
;
;  DESCRIPTION:
;    Write multiple data bytes to slave device from ROM. This function allows
;    for proper bus arbitration when there is more than one master on the bus
;    by first checking to see if the bus is busy.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;  [SP-7]=> Mode flags that allow the programmer to set flags
;            to determine if:
;               0x01 => Use RepeatStart instead of Start
;               0x02 => Don't send Stop
;  [SP-6]=> Count of bytes to write.
;  [SP-5]=> MSB of ROM Array address to get data from
;  [SP-4]=> LSB of ROM Array address to get data from.
;  [SP-3]=> Address of slave
;
;  RETURNS:  Master Status/Control register or 0xFF if the bus was busy.
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;    1. Checks if the Bus is free.
;    2. If busy returns 0xFF.
;    3. Else continues the transmission via entry into the bWriteCBytes API.
;
;-----------------------------------------------------------------------------
TxCMode:       equ  -7
TxCByteCount:  equ  -6
TxCArrayMSB:   equ  -5
TxCArrayLSB:   equ  -4
 I2CHW_bWriteCBytesNoStall:
_I2CHW_bWriteCBytesNoStall:

    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_2
    RAM_SETPAGE_CUR >I2CHW_MasterStatus

	mov   X, SP
	;test the I2CM_BUSBUSY bit in the MSCR reg
	tst reg[I2CHW_MSCR], I2CM_BUSBUSY
	jz I2C_BusFree3
        mov A, 0xff;   bus busy
	ret
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_bWriteCBytes
;
;  DESCRIPTION:
;    Write multiple data bytes to slave device from ROM
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;  [SP-7]=> Mode flags that allow the programmer to set flags
;            to determine if:
;               0x01 => Use RepeatStart instead of Start
;               0x02 => Don't send Stop
;  [SP-6]=> Count of bytes to write.
;  [SP-5]=> MSB of ROM Array address to get data from
;  [SP-4]=> LSB of ROM Array address to get data from.
;  [SP-3]=> Address of slave
;
;  RETURNS:  Bus Status
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;    1. Checks if the Bus is free.  If not, sets the ERROR and BUS_BUSY flags and exits
;    2. If the I2CHW_ISR_ACTIVE indicates that the I2CHW_ISR is already 
;       running this routine will pend on the ISR_ACTIVE bit until it can run
;    3. Initializes the Read buffer in ROM to read data to be sent
;    4. Performs a Start or Restart according the Mode specified
;    5. The rest is taken care of by the ISR
;
;-----------------------------------------------------------------------------    
TxCMode:       equ  -7
TxCByteCount:  equ  -6
TxCArrayMSB:   equ  -5
TxCArrayLSB:   equ  -4
;TxSlaveAddr:  equ  -3	  ;defined above this line if for reference only

 I2CHW_bWriteCBytes:
_I2CHW_bWriteCBytes:

    RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_PROLOGUE RAM_USE_CLASS_2
	RAM_SETPAGE_CUR >I2CHW_MasterStatus
	mov   X, SP

	; Write code here to test the bus busy flag proceed with the start only if the
	; bus is free.  If the bus is busy, set flag in the status register and exit

I2C_BusFree3:
    ;push  A
I2CMSCR_NotReady3:
    I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
    tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE
    ;mov   A, reg[I2CHW_MSCR]                              ;read the mscr register to look for pending master operations
    ;and   A, 0x0f                                         ;only look at the lower bits
         ;For multi master operations, a pening start or restart
         ;request might be OK, the master might be waiting to
         ;acquire the bus from another master
    jnz   I2CMSCR_NotReady3
    ;pop   A
	mov [I2CHW_bStatus],0				                                 ; Clear the Error Flags
	tst [X+RxMode],I2CHW_RepStart
	jnz BypassBusBusy3					; Check transfer is with a Repeat Start condition
										;  Then no need to check if the bus is busy.

BypassBusBusy3:
    or    [I2CHW_bStatus], I2CHW_ISR_ACTIVE                          ;lag set here but cleared in ISRf
    mov   A, [X + TxSlaveAddr]
    asl   A                                                ; Shift address to the left to make
                                                           ; a complete byte with the R/W bit.
                                                           ; The ASL takes care of clearing bit 0.
    mov   [I2CHW_SlaveAddr], A                             ; preserve addr+r/w state for the ISR to use
    mov   reg[I2CHW_DR], A                                 ; put the write addr into the I2C_DR reg
    mov   A, [X+RxMode]                                    ; place the RxMode in status so ISR can access it
    or   [I2CHW_bStatus],A
    ;
    ;we must now initialize a read buffer using I2CHW_InitMasterFlashRead
    ;
    push   X                                                 ;preserve X since it's used later
    mov    A, 0                                              ;get the write buf size (this is the hi order part)
    inc    [X+TxCByteCount]                                  ;increase this by one since the init routine will decrement it by 1
    jnc     . + 3                                            ;but the ISR understands the original count passed (sigh...)(F.O.E.O.)
    inc    A                                                                                        ;if the low order part of the count happened to roll to 0x00, inc the hi part
    push   A
    mov    A, [X+TxCByteCount]                               ;initFlasRead needs a 2 byte count this is the low ord byte
    push   A
    mov    A, [X+TxCArrayMSB]                                ;get the write buf addr
    push   A                                                                                        ;this will be ignored
    mov    A, [X+TxCArrayLSB]                                ;get the write buf addr
    push   A
    mov    X, sp
    dec    X
    call  I2CHW_InitMasterFlashRead                        ;sets the addr and byte count to write to
    add SP, -4
    pop X                                                    ;restore X to be used for the rest of this routine

    or  [I2CHW_MasterStatus],I2CHW_READFLASH
    mov   A,[I2CHW_SlaveAddr]
    tst   [x+TxMode],I2CHW_RepStart                        ; Check if a Start or RepeatStart
    jnz   DoCRestartTx                                       ; should executed.
    tst   reg[I2CHW_SCR], I2C_BYTE_COMPL                   ; indicates the I2C bus is stalled
    jnz   DoRestartRx
    call  I2CHW_DoStart                                    ; Send a start and address.
    jmp   DoCTxAck
DoCRestartTx:
    call  I2CHW_DoBufferRepeatStart                            ; Send a repeat start and address.

DoCTxAck:                                                    ; Test to see if Slave is ACKed

CWriteSlaveAck:
    mov A,[I2CHW_bStatus]						                            ; Return Bus Status
    RAM_EPILOGUE RAM_USE_CLASS_2
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret


I2C_ReturnBusBusy:
    or   [I2CHW_bStatus],(I2CHW_BUS_BUSY | I2CHW_ERROR)
    mov  a,[I2CHW_bStatus]
    RAM_EPILOGUE RAM_USE_CLASS_2
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
    
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_DoBufferRepeatStart
;
;  DESCRIPTION:
;    Send repeated start condition and send slave address for buffered transfers.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;     This routine is called internally only.  It is not exported or intended as an API
;
;  RETURNS:
;    None
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;    1. It checks if the Master is in control of the Bus.  If not, sets the ERROR
;       flag and returns
;    2. This is similar to the I2C_DoRepeatStart entry point but this function does not
;       wait for the byte_complete flag.
;
;-----------------------------------------------------------------------------

I2CHW_DoBufferRepeatStart:
    RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_SETPAGE_CUR >I2CHW_SlaveAddr
    ;here the path through the routine is dependent on the previous transmission.
        ; 1. a slave being written too must have acked or nakk'ed the previous byte (generating a Byte complete
        ; I2C interrupt
        ; 2a. the master must NAK the byte if he is reading from the slave.
        ; We do have to look at the status of the I2C block to see what is going on because if there was a
        ; previous write to a slave it may have ack'ed or nak'ed so we set an address and attempt a repeat start
        ; by setting the master restart bit and clearing to I2C_SCR (I2C_TX)
        ; 2b. if we are reading from theslave we would NAK it by clearing the I2C_ACKOUT bit and writing I2C_TX to the
        ; I2C_SCR reg.  (same as if we were writing to slave).
        ; 3. once the ISR starts it will figure out which direction we are going with data (sending/receiving)
        ;
    mov   reg[I2CHW_DR], A
    mov   [I2CHW_SlaveAddr], A
        ;tst      reg[I2CHW_MSCR], I2CM_MASTEROP;               ;do we even have control of the bus?
        ;jz    notBusMasterErr
    mov   A, reg[I2CHW_MSCR]                                    ;read the mscr register to look for pending master operations
    and   A, 0x0f                                               ;only look at the lower bits
    jz    BusIdleSendStart
        ; for a single master system this should not be an issue,
        ; so we'll go ahead and request the restart.  If a stop condition was already generated
        ; the state machine will automatically generate a start instead.

    ; for a Multimaster system, we have to test if the Master is in control of the bus.
    ; If the condition is Bus Busy, but Master is not in control, then

	tst reg[I2CHW_MSCR],I2CM_MASTEROP								                      ; Test if the Bus is in the control of the Master
	jz NotBusMaster1										

    ;SetI2CHW_SCR I2CM_RESTRT
    ;mov   reg[I2CHW_MSCR], I2CM_RESTRT
    ;SetI2CHW_SCR          I2C_TX                               ;even though the restart has been requested the state
        ;mov      reg[I2CHW_SCR], I2C_TX                        ;even though the restart has been requested the state

;IF I2CHW_THROTTLE_CLK_RATE
    SetI2CHW_MSCR I2CM_RESTRT
;ELSE
;    mov  reg[I2CHW_MSCR], I2CM_RESTRT
;ENDIF

    tst   reg[I2CHW_SCR], I2C_TX
    jnz   I2C_RestartRecieve

;IF I2CHW_THROTTLE_CLK_RATE
    SetI2CHW_SCR I2C_TX                                         ;even though the restart has been requested the state
;ELSE
;    mov  reg[I2CHW_SCR], I2C_TX                                ;send Ack
;ENDIF
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

I2C_RestartRecieve:

;IF I2CHW_THROTTLE_CLK_RATE
    SetI2CHW_SCR 0                                              ;even though the restart has been requested the state
;ELSE
;    mov   reg[I2CHW_SCR], 0                                    ;send Ack
;ENDIF
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

; Since something appears to be messed up do the next best thing to 
; a repeat start, send a start.
BusIdleSendStart:
    mov    A, [I2CHW_SlaveAddr]
    call   I2CHW_DoStart
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

.ENDSECTION

.SECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_fSendRepeatStart
;
;  DESCRIPTION:
;    Send repeated start condition and send slave address.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;    A has the Slave Address
;    X has the data direction. 0-Write, 1-Read
;
;  RETURNS: Bus Status
;    Reg A contains non-0 if there was an error
;    reg A contains 0 for success 
;	 I2CHW_bStatus contains the contains error information
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;    1. If the ISR is active, waits till the action is complete
;    2. Checks if the Mater has control on the bus.  If not sets the ERROR
;       bit in the bStatus register and returns.
;    3. Sends the Repeat Start
;    4. Waits for the Byte Complete bit to be set.  
;    5. Checks if Slave has acknowledged.  If not, sets the SLAVE_NAK
;       and ERROR bits and returns.
;    
;   WARNING: This routine will disable the interrupt
;-----------------------------------------------------------------------------
 I2CHW_fSendRepeatStart:
_I2CHW_fSendRepeatStart:
    RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_SETPAGE_CUR >I2CHW_bStatus
    
    push  A
    or   [I2CHW_bStatus], I2CHW_RepStart
I2CMSCR_NotReady4:
    I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
    tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE                    ; Test if ISR is active on another operation
    jnz   I2CMSCR_NotReady4                                     ; Wait if the ISR is already busy...
    tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                  
    jz   I2CMSCR_NotReady4                                      ; Wait if the ISR is already busy...
    pop   A

    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
    mov   [I2CHW_bStatus], I2CHW_BUS_BUSY
    tst   reg[I2CHW_MSCR],I2CM_MASTEROP                         ; Test if the Master has control on the bus
    jz    Err_Exit_RepStart                                     ; If not Bus Master return
    
    asl   a                                                     ; Shift address to the left
    dec   x                                                     ; If zero, C flag will be set
    jc    I2C_DoRepeatStart                                     ; Do a write if zero
    or    a,0x01                                                ; Set Read flag

I2C_DoRepeatStart:
    ;here the path through the routine is dependent on the previous transmission.
        ; 1. a slave being written too must have acked or nakk'ed the previous byte (generating a Byte complete
        ; I2C interrupt
        ; 2. the master must NAK the byte if he is reading from the slave.
        ; We don't have to look at the status of the I2C block to see what is going on because if there was a
        ; previous write to a slave it may have ack'ed or nak'ed so we set an address and attempt a repeat start
        ; by setting the master restart bit and writing to I2C_SCR (I2C_TX)
        ; if we are reading from theslave we would NAK it by clearing the I2C_ACKOUT bit and writing I2C_TX to the
        ; I2C_SCR reg.  (same as if we were writing to slave).
        ;
    mov   reg[I2CHW_DR], A
    mov   [I2CHW_SlaveAddr], A

; machine is stalling the SCL and has to be 'released'
; Set the RESTRT bit in I2C_MSCR
; Clear I2C_SCR to generate a restart condition
;IF I2CHW_THROTTLE_CLK_RATE
    SetI2CHW_MSCR I2CM_RESTRT						
    SetI2CHW_SCR 0                                
;ELSE
;    mov   reg[I2CHW_MSCR], I2CM_RESTRT
;    mov   reg[I2CHW_SCR], 0                                   
;ENDIF

; Wait till the Restart is complete
WaitRepStrtCompl:
    mov   A,  reg[I2CHW_SCR]
;;    I2CHW_POLL_SERVICE						                             ;Not appropriate for low level functions
    tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                  
    jz    WaitRepStrtCompl
    mov   [I2CHW_bStatus], I2CHW_SLAVE_NAK
    tst	  reg[I2CHW_SCR], I2C_LST_BIT		                    ; Test to see if Slave ACKed
    jnz   Err_Exit_RepStart                                ; If Slave did not ACK return with SLAVE_NAK Error
;    or   [I2CHW_bStatus], I2CHW_RepStart
    mov   [I2CHW_bStatus], 0
    mov   A, [I2CHW_bStatus]
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

Err_Exit_RepStart:
    
    ;mov   [I2CHW_bStatus], 0xff	                          ;I2CHW_bStatus should already contain an error condition
    mov   A, 01
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

NotBusMaster1:
    ; Some sort of improper operation is being attempted.  The Master has to be in cotrol
    ; to generate a Repeat Start condition.  Set ERROR Flag and return
	or [I2CHW_bStatus],I2CHW_ERROR
	and [I2CHW_bStatus],~I2CHW_ISR_ACTIVE
    mov   A,[I2CHW_bStatus] 
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_fSendStart
;
;  DESCRIPTION:
;    Generates start condition and sends slave address.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;    A => Contains the slave address.
;	 X => Conntains the value of the R/W bit. 0 for Write, and Non zero for Read
;
;  RETURNS:
;    Reg A contains non-0 if there was an error
;    reg A contains 0 for success 
;	 I2CHW_bStatus contains the contains error information
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;   1. If the I2CHW_ISR_ACTIVE flag is set, it waits till this is cleared
;   2. Disables Interrupt
;   3. Checks if any BYTE_COMPLETE interrupt is pending.  If yes, sets ERROR flag and
;      returns
;   4. Checks if Bus is Busy.  If yes, sets the ERROR and BUS_BUSY flags and exits
;
;  WARNING: this routine will disable the I2C interrupt.  It will wait until the I2C_BYTE_COMPLETE
;   flag is set to return.
;
;-----------------------------------------------------------------------------
 I2CHW_fSendStart:
_I2CHW_fSendStart:
    RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_SETPAGE_CUR >I2CHW_bStatus 
    ;wait if the bus is already busy...
    ;push  A
    mov   [I2CHW_bStatus], 0x00
I2CMSCR_NotReady5:
    I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
    tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE
    jnz   I2CMSCR_NotReady5
	
    ;mov   A, reg[I2CHW_MSCR]                              ;read the mscr register to look for pending master operations
    ;and   A, 0x0f                                         ;only look at the lower bits
          ;For multi master operations, a pening start or restart
          ;request might be OK, the master might be waiting to
          ;acquire the bus from another master
    ;pop   A

    ; disable the interrupt
        ; *** NOT REENABLED ***
        ;
    mov    [I2CHW_bStatus], I2CHW_ERROR
    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
    tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                    ; If there is a pending BYTE_COMPL here
                                                           ; it is highly probable that a start is not the
                                                           ; right thing to do
    jnz   Err_Exit_Start

    mov    [I2CHW_bStatus], I2CHW_BUS_BUSY
	tst   REG[I2CHW_MSCR],I2CM_BUSBUSY                        ; Test if the Bus is busy
	jz    I2C_BusFree4                                        ; If free proceed
	jmp   Err_Exit_Start                                      ; If busy return with Bus Busy Error

I2C_BusFree4:	
    asl   a                                                ; Shift address to the left
    dec   x                                                ; If zero, C flag will be set
    jc    I2C_SndWRStart                                   ; Do a write if zero
    or    a,0x01                                           ; Set Read flag
I2C_SndWRStart:

    mov   reg[I2CHW_DR], A
    mov   [I2CHW_SlaveAddr], A

;IF I2CHW_THROTTLE_CLK_RATE
    SetI2CHW_MSCR I2CM_SNDSTRT
;ELSE
;    mov   reg[I2CHW_MSCR], I2CM_SNDSTRT
;ENDIF

WaitStrtByteCompl:
    mov   A,  reg[I2CHW_SCR]
    tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                         ; Test to see if Slave ACKed
    jz    WaitStrtByteCompl
    tst   reg[I2CHW_SCR], I2C_LST_BIT
    jnz   Err_Exit_SlaveNak
    mov    [I2CHW_bStatus], 0
    mov   A,[I2CHW_bStatus]
    ;mov  A, 0 ;effective result of previous two operations
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

Err_Exit_SlaveNak:
	or    [I2CHW_bStatus],I2CHW_SLAVE_NAK

Err_Exit_Start:
	or    [I2CHW_bStatus],I2CHW_ERROR
    mov   A, [I2CHW_bStatus]
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret


;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_DoStart
;
;  DESCRIPTION:
;    Generates start condition and sends slave address.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;    A => Contains the slave address with the R/W bit.
;
;  RETURNS:
;    I2CHW_bSTatus - SLAVE_NAK bit indicates if the Slave responded.
;	                   If this bit is set, the Slave did not Acknowledge
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;  THEORY of OPERATION or PROCEDURE:
;   Writes the Address in Accumulator to the I2C_DR register and sets the
;	  SendStart bit in the I2C_MSCR.
;
;-----------------------------------------------------------------------------

I2CHW_DoStart:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >I2CHW_SlaveAddr
; Here we are not required to test for master operation since we are only attempting 
; to gain control of the bus by attempting to assert a Start.  It is the calling routine's
; responsibility to ensure that the bus is free.

    mov   reg[I2CHW_DR], A
    mov   [I2CHW_SlaveAddr], A

;IF I2CHW_THROTTLE_CLK_RATE
    SetI2CHW_MSCR I2CM_SNDSTRT
;ELSE
;    mov   reg[I2CHW_MSCR], I2CM_SNDSTRT
;ENDIF

;WaitStrtByteCompl1:
;    mov   A,  reg[I2CHW_SCR]
;	tst	  [I2CHW_bStatus],I2CHW_SLAVE_NAK
;	jnz   Error1
;   tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                         ; Test to see if Slave ACKed
;    jz    WaitStrtByteCompl1
;Error1:
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
;
;   DO NOT PLACE
;   .SECTION
;   .ENDSECTION
;   _fSendStart USES CODE BELOW
;
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_fWrite
;
;  DESCRIPTION:
;    Writes a byte to the I2C master bus.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;    A contains Data to be written to I2C slave.
;
;  RETURNS:
;   I2CHW_bStatus - If Master is not in control of bus, the ERROR flag is set.
;	 If the Slave does not ACK then SLAVE_NAK, and ERROR flags are set
;
;  SIDE EFFECTS:
;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;  FUNCTION NAME: I2CHW_write
;
;  DESCRIPTION:
;    Writes a byte to the I2C master bus. Also used for sending the address.
;
;  ARGUMENTS:
;    Reg A contains data to be written to the bus (destroyed).
;
;  PROCEDURE:
;    This routine first disables the I2C interrupt.  Then it checks if the Master
;    is in control of the bus.  If not, sets the ERROR flag in bStatus and returns.
;	 Then it writes the data to the Data register and enables the I2C_TX bit to
;	 transmit the data.  It waits till the Byte Tx is complete.  It checks for the
;	 Slave ACK or NAK condition.  If slave ACKed then it returns.  If slave NAKed,
;	 then it sets the ERROR and SLAVE_NAK flags of bStatus and returns.	
;
;  RETURNS:
;   I2CHW_bStatus - If Master is not in control of bus, the ERROR flag is set.
;	 If the Slave does not ACK then SLAVE_NAK, and ERROR flags are set
;    returns A=01 (non zero= TRUE) for success, A= 0 (false = 0) for failure
;    I2CHW_bStatus contains error flags
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;   WARNING: This routine will explicitly disable the I2C interrupt.  
;
;-----------------------------------------------------------------------------
I2CHW_fWrite:
_I2CHW_fWrite:
    RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_SETPAGE_CUR >I2CHW_bStatus
    ; disable the interrupt
        ; *** NOT REENABLED ***
        ;

    mov   reg[I2CHW_DR],A                                       ; Put data in Data Reg
    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
    mov   A,  reg[I2CHW_MSCR]                                   ; MSCR into A incase there is an error here
    or    [I2CHW_bStatus], I2CHW_BUS_BUSY
    tst   reg[I2CHW_MSCR],I2CM_MASTEROP                         ; Do we have control of the bus?
	jz    Err_Exit_fWrite								                                  ; If Master not in control of the bus, set ERROR flag
														                                                  ;   and exit

I2CHW_write:
_I2CHW_write:
    mov   [I2CHW_bStatus],0x00                                  ; Clear ACK flag
;IF I2CHW_THROTTLE_CLK_RATE
    SetI2CHW_SCR I2C_TX                                         ; Transmit Data in Data Reg
;ELSE
;    mov   reg[I2CHW_SCR], I2C_TX                               ; Transmit Data in Data Reg
;ENDIF


WaitTXByteCompl:
    mov   A, reg[I2CHW_SCR]
    mov    [I2CHW_bStatus], I2CHW_ERROR
    tst   reg[I2CHW_SCR],I2C_STOP_ST					                       ; Not precisely sure what happened but transaction is done
    jnz   Err_Exit_fWrite                  
    tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                  
    jz    WaitTXByteCompl									                              ; Wait till Byte Completes
    mov    [I2CHW_bStatus], I2CHW_SLAVE_NAK
    tst   reg[I2CHW_SCR], I2C_LST_BIT				                       ; Test to see if Slave ACKed
    jnz   Err_Exit_fWrite							                                ; Report SLAVE_NAK error, if slave did not respond
    mov   [I2CHW_bStatus], 0x0
    mov   A, 0
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

Err_Exit_fWrite:
    mov   A, 01
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret


.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_get_ack
;
;  DESCRIPTION:
;    Get slave acknowledge response. Used to poll for I2C_BYTE_COMPL and then test Ack (I2C_LST_BIT)
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;    Sets the SLAVE_NAK flag in the bStatus register if the Slave did not Acknowledge
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;    Do the ack clock and check for Slave ACK
;
;-----------------------------------------------------------------------------
I2CHW_get_ack:
_I2CHW_get_ack:
    RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_SETPAGE_CUR >I2CHW_bStatus
    and [I2CHW_bStatus], ~I2CHW_SLAVE_NAK
    tst reg[I2CHW_SCR], I2C_BYTE_COMPL
    jnz I2CHW_get_ack
    tst reg[I2CHW_SCR], I2C_LST_BIT
    jnz notAcked
    mov [I2CHW_bStatus], 0
    ret
    
notAcked:
    or [I2CHW_bStatus], I2CHW_SLAVE_NAK
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

.ENDSECTION

.SECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_bRead
;
;  DESCRIPTION:
;    Reads 1 data byte from the I2C master bus.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;    Reg A Contains Ack or Nak information. If 0, the received byte is NAKed.
;	 If Reg A contains 1, then the received byte is ACKed.	  
;
;  RETURNS:
;    ret A contains returned data
;    Reg A contains 0 if there was an error 
;	 I2CHW_bStatus contains the contains error information
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;    Currently only the page pointer registers listed below are modified: 
;          CUR_PP
;
;    The I2CHW interrupt should be disabled since this routine will poll the
;    reg[I2CHW_SCR] to determine when a byte is available
;
;   WARNING: This routine will disable the I2C interrupt.  It will wait until the I2C_BYTE_COMPLETE
;    flag is set to return.
;
;
;-----------------------------------------------------------------------------
I2CHW_bRead:
_I2CHW_bRead:
    RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_SETPAGE_CUR >I2CHW_bStatus
    ; disable the interrupt
    ; *** NOT REENABLED ***
    ;

    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK	; Disable I2C Interrupt
    tst   reg[I2CHW_MSCR], I2CM_MASTEROP         	              ; Do we have control of the bus?
    mov    [I2CHW_bStatus], I2CHW_BUS_BUSY
    jz    Err_Exit_bRead                                        ; Set Error Flag and Return
    mov   [I2CHW_bStatus],0x00                                  ; Clear Status

; Check for the special case of the first read after and address is sent
    push  A                                                     ;preserve the information about wether to ACK or NAK this byte
    mov   A, reg[I2CHW_SCR]
    tst   reg[I2CHW_SCR], I2C_ADDRIN
    jz    WaitRXByteCompl                                       ;addr bit not set then this is a normal read

;IF I2CHW_THROTTLE_CLK_RATE
    SetI2CHW_SCR 0                                              ;clear the I2C_ADDR bit (to unstall SCL) & wait for next byte
;ELSE
;    mov   reg[I2CHW_SCR], 0                                    ;clear the I2C_ADDR bit (to unstall SCL) & wait for next byte
;ENDIF
                                                                ; through to I2CHW_put_ack.

    ;must DROP through to send an Ack and another byte,
    ;to stop reading we NAK the slave
WaitRXByteCompl:
    tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                         ; Wait till Byte is read
    jz    WaitRXByteCompl

    pop   A                                                     ; Recover the saved ACK/NAK flag
    and   A,0xFF                                                ; Is Ack flag set?
    jz    exit_bRead_NOACK                                      ; Don't ACK

    ;now if the ACK flag was set, Ack the data which will release the bus and start the next byte in
    ;otherwise do NOTHING to the SCR reg.  This will allow the calling routine to generate a repeat start
    ;or a stop depending on it's preference.

    mov   A, reg[I2CHW_DR]                                      ; Record data received
    ;mov   [I2CHW_bData],A							                               ; Write received data to bData

;IF I2CHW_THROTTLE_CLK_RATE
    SetI2CHW_SCR I2C_ACKOUT                                     ; Send Ack
;ELSE
;    mov   reg[I2CHW_SCR], I2C_ACKOUT                           ; Send Ack
;ENDIF

    mov   [I2CHW_bStatus],0x00                             ; No error bits set
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

exit_bRead_NOACK:
    mov   A, reg[I2CHW_DR]                                      ; Record data received
    ;mov   [I2CHW_bData],A							                               ; Write received data to bData
	
    ; send no Ack or Nak, the calling routine will have to decide to NAK or execute a repeat start.
    ; sending nothing leaves the bus held in wait until a decision is made.
    mov   [I2CHW_bStatus],0x00                             ; Clear ACK flag
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret


Err_Exit_bRead:
    mov   A, 00	                                                 ;Data should be in A but something went wrong
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

.ENDSECTION


.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: I2CHW_SendStop
;
;  DESCRIPTION:
;    Assert stop condition.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: none
;
;  RETURNS: none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;          
;  THEORY of OPERATION or PROCEDURE:
;     Send stop by releasing SDA high while SCL high. 
;	  When in Master Read Mode, this is done by clearing the ACK bit to NAK a read 
;	     from the slave.
;	  In Master Write Mode this is done by clearing I2C_TX bit in the I2C_SCR register
;     In either case this is a zero written to I2CHW_SCR register.
;
;-----------------------------------------------------------------------------
 I2CHW_SendStop:
_I2CHW_SendStop:
    RAM_PROLOGUE RAM_USE_CLASS_1
    tst   reg[I2CHW_MSCR], I2CM_MASTEROP                        ; Do we have control of the bus?
    jz    notBusMaster3							                                  ; If not nothing to do

; Clear ACK bit in SCR register to release the bus and to generate a Stop
;IF I2CHW_THROTTLE_CLK_RATE
        SetI2CHW_SCR 0                           
;ELSE
;    mov   reg[I2CHW_SCR], 0                      
;ENDIF

notBusMaster3:
    RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION




; End of File I2CHW.asm
