;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: I2CHWINT.asm
;;  Version: 1.90, Updated on 2012/9/21 at 11:59:4
;;  Generated by PSoC Designer 5.3.2710
;;
;;  DESCRIPTION: I2CHW MultiMaster Interrupt Service Routine.
;;
;;	File stored in Master directory of user module
;;	program flow would likely be to first determine what 'mode' the device is in.  
;;  I.e. is Master and Slave mode enabled?  Control of program flow must take 
;;  more into account when all more modes are enabled.
;;
;;
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "I2CHWCommon.inc"
include "I2CHWMstr.inc"
include "I2CHWMMS.inc"
include "I2CHWSlave.inc"
;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------

export     I2CHW_MasterRead_Count
export    _I2CHW_MasterRead_Count
export     I2CHW_MasterWrite_Count
export    _I2CHW_MasterWrite_Count
export    pI2CHW_MasterRead_BufLO
export   _pI2CHW_MasterRead_BufLO
export    pI2CHW_MasterWrite_BufLO
export   _pI2CHW_MasterWrite_BufLO
export    I2CHW_MasterStatus
export   _I2CHW_MasterStatus
export    I2CHW_SlaveAddr
export   _I2CHW_SlaveAddr


area InterruptRAM(RAM, REL, CON)
;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------

  I2CHW_SlaveAddr:
 _I2CHW_SlaveAddr:                     BLK    1
  I2CHW_MasterStatus:
 _I2CHW_MasterStatus:                  BLK    1
IF SYSTEM_LARGE_MEMORY_MODEL
export    pI2CHW_MasterWrite_BufHI
export   _pI2CHW_MasterWrite_BufHI

 pI2CHW_MasterWrite_BufHI:
_pI2CHW_MasterWrite_BufHI:                   blk     1
ENDIF
 pI2CHW_MasterWrite_BufLO:
_pI2CHW_MasterWrite_BufLO:             BLK    1
  I2CHW_MasterWrite_Count:
 _I2CHW_MasterWrite_Count:             BLK    1
IF I2CHW_READ_FLASH
export    pI2CHW_MasterRead_BufHI
export   _pI2CHW_MasterRead_BufHI

 pI2CHW_MasterRead_BufHI:
_pI2CHW_MasterRead_BufHI:                    blk     1
ELSE
IF SYSTEM_LARGE_MEMORY_MODEL
export    pI2CHW_MasterRead_BufHI
export   _pI2CHW_MasterRead_BufHI

 pI2CHW_MasterRead_BufHI:
_pI2CHW_MasterRead_BufHI:                    blk     1
ENDIF
ENDIF
 pI2CHW_MasterRead_BufLO:
_pI2CHW_MasterRead_BufLO:              BLK    1
IF I2CHW_READ_FLASH
export    I2CHW_MasterRead_CountHI
export   _I2CHW_MasterRead_CountHI

 I2CHW_MasterRead_CountHI:
_I2CHW_MasterRead_CountHI:                   blk    1
ENDIF
 I2CHW_MasterRead_Count:
_I2CHW_MasterRead_Count:               BLK    1



IF I2CHW_SLAVE_OPTION

export    I2CHW_SlaveStatus
export   _I2CHW_SlaveStatus
export     I2CHW_SlaveRead_Count
export    _I2CHW_SlaveRead_Count
export     I2CHW_SlaveWrite_Count
export    _I2CHW_SlaveWrite_Count
export    pI2CHW_SlaveRead_BufLO
export   _pI2CHW_SlaveRead_BufLO
export    pI2CHW_SlaveWrite_BufLO
export   _pI2CHW_SlaveWrite_BufLO
export    I2CHW_SlaveRead_CountHI
export   _I2CHW_SlaveRead_CountHI


  I2CHW_SlaveStatus:
 _I2CHW_SlaveStatus:                   BLK    1
IF SYSTEM_LARGE_MEMORY_MODEL
export    pI2CHW_SlaveWrite_BufHI
export   _pI2CHW_SlaveWrite_BufHI

 pI2CHW_SlaveWrite_BufHI:
_pI2CHW_SlaveWrite_BufHI:                    blk     1
ENDIF
 pI2CHW_SlaveWrite_BufLO:
_pI2CHW_SlaveWrite_BufLO:              BLK    1
  I2CHW_SlaveWrite_Count:
 _I2CHW_SlaveWrite_Count:              BLK    1
IF I2CHW_READ_FLASH
export    pI2CHW_SlaveRead_BufHI
export   _pI2CHW_SlaveRead_BufHI

 pI2CHW_SlaveRead_BufHI:
_pI2CHW_SlaveRead_BufHI:                     blk     1
ELSE
IF SYSTEM_LARGE_MEMORY_MODEL
export    pI2CHW_SlaveRead_BufHI
export   _pI2CHW_SlaveRead_BufHI

 pI2CHW_SlaveRead_BufHI:
_pI2CHW_SlaveRead_BufHI:                     blk     1
ENDIF
ENDIF
 pI2CHW_SlaveRead_BufLO:
_pI2CHW_SlaveRead_BufLO:               BLK    1
 I2CHW_SlaveRead_CountHI:
_I2CHW_SlaveRead_CountHI:              BLK    1
 I2CHW_SlaveRead_Count:
_I2CHW_SlaveRead_Count:                BLK    1

ENDIF


IF I2CHW_POLLED_PROCESS

I2CHW_Poll_Status:                             blk      1  ;internal variable used for polled operation
;bit 0 - Write transaction started begin looking for the STOP state to terminate the transaction
I2C_WRITE_STARTED:       equ     0x01
;bit 1 - Undefined
;bit 2 - Undefined
;bit 3 - Undefined
;bit 4 - Undefined
;bit 5 - Undefined
;bit 6 - Undefined
;bit 7 - Undefined

ENDIF


SNIFF_DATA:  equ 0
DEBUG_STATE: equ 0

;@PSoC_UserCode_INIT@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom declarations below this banner
;---------------------------------------------------

;------------------------
; Includes
;------------------------

	
;------------------------
;  Constant Definitions
;------------------------


;------------------------
; Variable Allocation
;------------------------


;---------------------------------------------------
; Insert your custom declarations above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)



AREA UserModules (ROM, REL)

export _I2CHW_ISR
export _I2CHW_Poll
export  I2CHW_Poll

;;****************************************************
;; I2C_ISR  main entry point from vector 60h
;;
;;****************************************************

IF I2CHW_POLLED_PROCESS

_I2CHW_ISR:
    reti ; stub out the ISR if this is going to be a polled function

 
 
 I2CHW_Poll:
_I2CHW_Poll:
;    cases are:
;    1. Stop state after a Master write to this slave
;    2. possible Stop condition COMBINED with a new transaction is not a problem since the Stop will only flag that the 
;       previous write has been completed. (so just call the I2CA_Process routine for this case and let the process routine take
;       care of it.
    ;case 1
    RAM_SETPAGE_CUR	( >I2CHW_Poll_Status )

    tst [I2CHW_Poll_Status], I2C_WRITE_STARTED
    jz  NOT_I2C_Write
    tst reg[ I2CHW_SCR], I2C_STOP_ST
    ;make sure the pushes and pops 'line up' or die horribly
    jz  NOT_I2C_Write
    push A
    push X
IF SYSTEM_LARGE_MEMORY_MODEL
    REG_PRESERVE IDX_PP
ENDIF
    jmp Slave_STOPTRAP
    
NOT_I2C_Write:    
    tst reg[ I2CHW_SCR], I2C_BYTE_COMPL
    jnz I2CHW_Process   ;if no other critical events are in evidence, process an I2C byte if it's done
    ret

 I2CHW_Process:
_I2CHW_Process:  ;don't need to export user will call I2CA_POLL which will call the I2CA_Process routine if necessary



ELSE
;; STUB for polling function when it's un-defined
 I2CHW_Poll:
_I2CHW_Poll:
    ret


;;*****************************************************************************************
;;                 I2C_MASTER  main entry point from vector 60h
;;*****************************************************************************************

_I2CHW_ISR:
ENDIF
    push A
    push X
IF SYSTEM_LARGE_MEMORY_MODEL
    REG_PRESERVE IDX_PP
ENDIF

Process_REENTRY:
;******************************************************************************************
;If two masters attempt to address one another and do so simultaneously within the window of
;the start bit, one may still have it's address bit set indicating that it failed in acquiring
;the bus prior to an arbitration loss event.  Since the Data register may be overwritten
;the presence of the address request bit can cause an address event with incorrect data
;if undetected.  A byte-complete event when the address bit is still set indicates that this
;has happened.
;          
;******************************************************************************************
    mov A, reg[I2CHW_MSCR]
    and A, 0x01                                              ;;Test if Start_Gen/address req is Set
    jz  ContinueByteCompl                                    ;;If not jump out
    and reg[I2CHW_MSCR], ~0x01                               ;;If address req is set clear it
    or  [I2CHW_bStatus],(I2CHW_LOST_ARB | I2CHW_ERROR)       ; Set the ERROR and LOST_ARB flags in the bus status register
    ;or  [I2CHW_bStatus], I2CHW_ERROR // Then flag an error
	;; if an address has been received it's possible that it's this devices slave address
ContinueByteCompl:
;******************************************************************************************
;Before doing anything else check for the presence of a STOP_ST in combination with the
;STOP Interrupt Enable (STOPIE).  If this is what happened set appropriate bits, 
;clear and reset the main I2CHW interrupt to assure that we haven't missed a BYTE_COMPLETE
;interrupt and exit the interrupt.  If a BYTE_COMPLETE interrupt is concurrent with the STOP 
;interrupt the next entry to this interrupt will be immediate and the STOPIE bit will now be 
;cleared.  This removes the possibility of trying to process two different events within one 
;interrupt.
;          
;******************************************************************************************
;first check to see if the slave function is enabled
;so no valid address are detected without the interrupt 
;capability to ACK them
    IF(I2CHW_USED_I2C_BLOCK)
    M8C_SetBank1
    tst reg[I2CHW_CFG],I2C_S_EN                                ; is the slave function enabled?
    M8C_SetBank0
    ELSE
    tst reg[I2CHW_CFG],I2C_S_EN                                ; is the slave function enabled?
    ENDIF
    jz  ByteComplProcess 
; Check the Stop Bit in SCR only if the Stop Interrupt is enabled.    
    IF(I2CHW_USED_I2C_BLOCK)
    M8C_SetBank1
    tst reg[I2CHW_CFG],I2C_STOPIE
    M8C_SetBank0
    ELSE
    tst reg[I2CHW_CFG],I2C_STOPIE
    ENDIF
    jz  ByteComplProcess
    tst reg[I2CHW_SCR],I2C_STOP_ST                         ; Test if the Interrupt is due to Stop Condition
;conditions that must be met here are Slave-enabled, STOP int enabled (STOPIE), and STOP_ST (status bit set)
    jnz Slave_STOPTRAP                                       ; If yes process Stop Trap

ByteComplProcess:
;*********END TEST OF STOP STATUS**********************************************************       

    tst reg[I2CHW_SCR],I2CM_BUSERR                           ; Test if the Interrupt is due to Bus Error
    jnz ReportBusError                                       ; If yes Report Bus Error

    
    tst reg[I2CHW_SCR],I2CM_LOSTARB                          ; Test the Lost Arbitration bit
    jz  NoLostArb                                            ; If not set, proceed

;******************************************************************************************
;                     Control is here if Master Lost Arbitration
;******************************************************************************************
; 1. Set the ERROR and LOST_ARB flags in the bStatus register.
; 2. Branch to Slave ISR if the Address bit is set in I2C_SCR and Slave mode enabled.
; 3. If Slave mode not enabled or Address bit not set, release the bus.

    or  [I2CHW_bStatus],(I2CHW_LOST_ARB | I2CHW_ERROR)       ; Set the ERROR and LOST_ARB flags in the bus status register
IF I2CHW_SLAVE_OPTION
;first check to see if the slave function is enabled
;so no valid address are detected without the interrupt 
;capability to ACK them
IF DEBUG_STATE
   mov A, 'b'
   lcall TX8_1_PutChar
   mov A, '0'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
   lcall TX8_1_PutCRLF
ENDIF
    IF(I2CHW_USED_I2C_BLOCK)
    M8C_SetBank1
    tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
    M8C_SetBank0
    ELSE
    tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
    ENDIF
    jz  ArbitrationLossBusRelease 
    tst reg[I2CHW_SCR],I2C_ADDRIN                            ; Test if the Received byte is an address
    jnz I2CHW_ISR_SLAVE                                      ; If yes, the master probably has been addressed as slave
ENDIF

ArbitrationLossBusRelease:
;******************************************************************************************
;;; EXIT ON ARBITRATION LOSS, RELEASE BUS IGNORE FURTHER ACTIVITY ;;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, "b"
   lcall TX8_1_PutChar
   mov A, "1"
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
   lcall TX8_1_PutCRLF
ENDIF

;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ; Release the Bus by clearing the I2C_SCR register

; Enable Stop Trap.  The ISR_ACTIVE bit will be cleared only when a Stop condition is
; detected. ie, when the winning master releases the bus
; On the other hand why bother?  The bit is therefore decreed to be cleared,
; IFF the Slave it NOT enabled. 
;    BitSetI2CHW_CFG I2C_STOPIE
    and [I2CHW_bStatus],~I2CHW_ISR_ACTIVE
IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

;******************************************************************************************
;                          Interrupt Caused by Bus Error
;******************************************************************************************
; Set the ERROR and BUS_ERROR flags in the bStatus register
ReportBusError:
;******************************************************************************************
;;; EXIT ON BUS ERROR (STATE OF BUS IS UNKNOWN--PROBABLY STALLED), RELEASE BUS IGNORE FURTHER ACTIVITY ;;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'b'
   lcall TX8_1_PutChar
   mov A, 'E'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF

;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ; Release the Bus by clearing the I2C_SCR register

    or [I2CHW_bStatus],(I2CHW_ERROR | I2CHW_BUS_ERROR)
    and [I2CHW_bStatus],~I2CHW_ISR_ACTIVE
IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

;******************************************************************************************
;                              No Errors encountered
;******************************************************************************************
NoLostArb:

IF I2CHW_SLAVE_OPTION
	tst REG[I2CHW_MSCR],I2CM_MASTEROP                           ; Test if Master is in control
	jz TstSlaveOperational                                      ; If not branch to SLAVE_ISR
	jmp ProceedWithMasterOp  
TstSlaveOperational:
    
;first check to see if the slave function is enabled
;so no valid address are detected without the interrupt 
;capability to ACK them
    IF(I2CHW_USED_I2C_BLOCK)
    M8C_SetBank1
    tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
    M8C_SetBank0
    ELSE
    tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
    ENDIF
    jz  ArbitrationLossBusRelease 
    jmp I2CHW_ISR_SLAVE                                      ; If not branch to SLAVE_ISR  
ENDIF

ProceedWithMasterOp:
;******************************************************************************************
	;Only use the SLAVE stop trap for Writes to the Slave from and external master.
	;The stop interrupt will only cause problems otherwise.
	;Do not use stop interrupts for multi-master (master) mode.
;******************************************************************************************

    tst reg[I2CHW_SCR], I2C_ADDRIN
    jz DataState

; Test if a Start Generation is pending, or the if the Slave ACK'ed or NAKed the address.
AddrState:
    tst reg[I2CHW_MSCR], I2CM_SNDSTRT
    jnz NoStart                                              ; A start is pending                            
    tst reg[I2CHW_SCR], ( I2C_LST_BIT )         
    jnz SlaveAddrNAK                                         ; Slave did not answer 

; Slave has acknowledged here.  Now it is to be decided if data has to be transmitted or
; received.  This is done by testing the R/W bit of the SlaveAddr.  If this bit is 0, then
; it is a write operation.  If 1, then it is a read operation
    tst [I2CHW_SlaveAddr], 01                   
    jnz I2C_ReadSlave1stByte                                 ; Branch to Read byte
    jmp I2C_WriteSlave1stByte                                ; Branch to Write byte
;******************************************************************************************
;;; UNREACHABLE EXIT POINT STACK MAY BE CORRUPTED ;;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 0xEE
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

; A data byte has been transmitted or has been received.  This is again decided by testing
; the R/W bit of the SlaveAddr byte.  If 0, then a byte transmission has been completed and
; the next byte has to be transmitted.  If 1, a byte has been received and has to be ACK'ed
; or NAKed
DataState:
    or [I2CHW_bStatus], I2CHW_ISR_ACTIVE
    tst [I2CHW_SlaveAddr], 01                                
    jnz I2C_ReadSlave                                        ; Process the received byte
    jmp I2C_WriteSlave                                       ; Write next byte to Slave
;******************************************************************************************
;;; UNREACHABLE EXIT POINT STACK MAY BE CORRUPTED ;;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 0xEE
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
	pop X
	pop A
    RAM_RESTORE_NATIVE_PAGING		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

; Slave did not ACK.  Either the Slave was not present or is busy.  So release the bus,
; set the ERROR and SLAVE_NAK bits in the bStatus register and return
SlaveAddrNAK:
;******************************************************************************************
;;; EXIT STATE: SLAVE NAK'ED IT'S ADDRESS ,RELEASE BUS (MASTER OPERATION STATE An);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'A'
   lcall TX8_1_PutChar
   mov A, 'n'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF DEBUG_STATE
   lcall TX8_1_PutCRLF
ENDIF


;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ; Sets the tx/rx bit to receive, generates a stop without sending any data

    and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
    or [I2CHW_bStatus], (I2CHW_ERROR | I2CHW_SLAVE_NAK )        ; Set the ERROR and SLAVE_NAK Flag
IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING
    I2CHW_SERVICE_RETURN

NoStart:
; A previous generated start could not be sent.  This could be because the bus has already
; been acquired by another Master.  So test the Address bit.  If it is set, it is possible
; that the Slave has been addressed.  Branch to Slave ISR to compare the address.

;first check to see if the slave function is enabled
;so no valid address are detected without the interrupt 
;capability to ACK them
    IF(I2CHW_USED_I2C_BLOCK)
    M8C_SetBank1
    tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
    M8C_SetBank0
    ELSE
    tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
    ENDIF
    jz  ArbitrationLossBusRelease 

    tst reg[I2CHW_SCR],I2C_ADDRIN                            ; Test if the Received byte is an address

IF I2CHW_SLAVE_OPTION
    jnz I2CHW_ISR_SLAVE                                      ; If yes, branch to Slave ISR
ELSE
; If Slave mode is not enabled then nothing to do.  In fact, this condition could never
; occur.  If the Slave were disabled, then a Byte complete interrupt will only be 
; generated on successful completion of Start.  In that case, the Start bit will already
; have been cleared and the program can never branch here.  Still just to make sure...
    and [I2CHW_bStatus],~I2CHW_ISR_ACTIVE    
;******************************************************************************************
;;; UNREACHABLE EXIT POINT STACK MAY BE CORRUPTED: RELEASE BUS COMPLETELY;;;
;;; ISR program flow should not reach this point.
;******************************************************************************************
IF DEBUG_STATE
   mov [I2CHW_ExitState], 0xE1
   mov A, 0xE1
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF

;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ; Sets the tx/rx bit to receive, generates a stop without sending any data

IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING
    I2CHW_SERVICE_RETURN
ENDIF
    
; The control has branched here because a byte has been received from the Slave.  Process
; this received data.
I2C_ReadSlave1stByte:

    or [I2CHW_bStatus], I2CHW_ISR_ACTIVE
    and [I2CHW_MasterStatus], ~I2CHW_RD_COMPLETE

;read normal data in from slave immediately after the address is sent, there is no data to read
;but the bus is stalled at byte complete
;******************************************************************************************
;;; EXIT STATE: READING FROM SLAVE (MASTER OPERATION STATE Ar);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'A'
   lcall TX8_1_PutChar
   mov A, 'r'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF


;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ;sets the tx/rx bit to receive, and clocks a byte in


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING
    I2CHW_SERVICE_RETURN

I2C_ReadSlave:                                               ;this is just a normal read

; MASTER READ from SLAVE
; (and writing to it's own RAM--Write_Buf and Write_Cnt)
;
;@PSoC_UserCode_BODY1@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------

;********************************************************
; By modifying the section from here down to the next comment block
; a user could process data for a custom I2C Master Read (write to RAM) application
; NOTE: I2C handshakes (ACK/NAK may be effected by any introduced bugs)
;********************************************************
   tst   [I2CHW_MasterStatus], fMULTIMASTER_NAK_NEXT_WR
   jnz   InStoreData
   ;
   ;process write data here
   ;
   dec   [I2CHW_MasterWrite_Count]
   jc    CompleteRDXfer                                      ; carry set if value became -1

   cmp   [I2CHW_MasterWrite_Count], 00                       ;set nak flag, dec count, and store data
   jz    InNakNextByte
   jmp   InNotBufEnd
InNakNextByte:                                               ;set the nakflag in I2CHW_bStatus
   or    [I2CHW_MasterStatus], fMULTIMASTER_NAK_NEXT_WR
   jmp   InStoreData
InNotBufEnd:
   and   [I2CHW_MasterStatus], ~fMULTIMASTER_NAK_NEXT_WR     ;clear the nak flag in case it was set from a previous operation
InStoreData:
   ;This is the ONLY place this bit is set  This bit should never be cleared by the isr ONLY by the API ClrWrStatus()
   or    [I2CHW_MasterStatus], I2CHW_RD_NOERR                ;set current status
IF SYSTEM_LARGE_MEMORY_MODEL
   mov   A, [pI2CHW_MasterWrite_BufHI]
ENDIF
   RAM_SETPAGE_IDX A
   mov   X, [pI2CHW_MasterWrite_BufLO]
   mov   A, reg[I2CHW_DR]
   RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
   mov   [X],A                                               ;save the last byte
   RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
   inc   [pI2CHW_MasterWrite_BufLO]

   tst   [I2CHW_MasterStatus], fMULTIMASTER_NAK_NEXT_WR
   jnz   NAK_this_one

;********************************************************
; End user I2C Buffered WRITE (to RAM) Customization
;********************************************************
;@PSoC_UserCode_END@ (Do not change this line.)

AckTheRead:
;******************************************************************************************
;;; NORMAL ACK UPON READING SLAVE DATA (STATE DATA Ra);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'R'
   lcall TX8_1_PutChar
   mov A, 'a'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF

;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR I2C_ACKOUT                                  ;send Ack


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

NAK_this_one:
    and  [I2CHW_MasterStatus], ~fMULTIMASTER_NAK_NEXT_WR     ; Clear NAKNextWr bit
    and   [I2CHW_MasterStatus], ~0x07                        ; Clear the read status bits
    and [I2CHW_bStatus], (I2CHW_NoStop | I2CHW_RepStart)
    jz      CompleteRDXfer
; If No stop mode, then do not send ACK or NAK.  The next transaction should be
; with a Repeat Start Condition.  The bus is stalled till next transaction.
    and   [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
    or    [I2CHW_MasterStatus], I2CHW_RD_NOERR
    or    [I2CHW_MasterStatus], I2CHW_RD_COMPLETE

;******************************************************************************************
;;; EXIT ISR WITHOUT RELEASING BUS: A RESTART/REPEAT START WAS REQUESTED (STATE DATA Rx);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'R'
   lcall TX8_1_PutChar
   mov A, 'x'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF DEBUG_STATE
   lcall TX8_1_PutCRLF
ENDIF
IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

;if neither a repeat start or a NoStop, then this must be a CompleteXfer request.
;The NAK (not I2C_SNDACK) bit in I2C_SCR below will automatically generate a stop
CompleteRDXfer:
;@PSoC_UserCode_BODY7@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------
        ; *****
        ; Here the user can write code to process the received data
        ; The bus will be stalled till the processing is complete.
        ; ******
;********************************************************
; End user I2C Buffered WRITE (to RAM) Customization
;********************************************************
;@PSoC_UserCode_END@ (Do not change this line.)

;******************************************************************************************
;;; NORMAL NAK UPON READING LAST SLAVE DATA BYTE (STATE DATA Rs);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'R'
   lcall TX8_1_PutChar
   mov A, 's'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF DEBUG_STATE
   lcall TX8_1_PutCRLF
ENDIF
    or    [I2CHW_MasterStatus], I2CHW_RD_NOERR
    or    [I2CHW_MasterStatus], I2CHW_RD_COMPLETE
; Clear the NoStop and RepStart and ISR_ACTIVE bits in the bStatus register
    and [I2CHW_bStatus], ~(I2CHW_RepStart | I2CHW_NoStop | I2CHW_ISR_ACTIVE)

;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ;Generate NAK (Stop)


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN                                     ; return and wait for the next interrupt (on data)


; Control has branched here because a byte transmit has completed.  Check if more bytes
; have to be transmitted to slave.  If this is the first byte to be transmitted, then
; clear the WR_COMPLETE flag in the MaterStatus register and set the ISR_ACTIVE flag
; in the bStatus register.

I2C_WriteSlave1stByte:
;******************************************************************************************
;;; SLAVE ACK'ED ADDR BEGIN DATA WRITE (STATE DATA Aw);;;
;******************************************************************************************
    and [I2CHW_MasterStatus], ~I2CHW_WR_COMPLETE
    or [I2CHW_bStatus], I2CHW_ISR_ACTIVE
IF DEBUG_STATE
   mov A, 'A'
   lcall TX8_1_PutChar
   mov A, 'w'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF

I2C_WriteSlave:
    tst reg[I2CHW_SCR], ( I2C_LST_BIT )                      ;must be a zero or no slave answered
    jnz SlaveDataNAK
    mov A, (I2C_TX)
    push A

;
;MASTER is WRITING TO SLAVE (& reading data from ram or flash buffer)
;
;;code snipped from SW I2C below

I2C_ObtainOutData:

;********************************************************
; here we need to get the next data to output (master-read)
; also set the status byte for use on exit
;********************************************************

IF I2CHW_READ_FLASH
;@PSoC_UserCode_BODY2@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
; to modify the way a master might read non-volatile data
; to send.
;---------------------------------------------------

    tst  [I2CHW_MasterStatus],I2CHW_READFLASH
    jz   ReadOutData

    ;
    ;get the data
    ;
    mov  X, [pI2CHW_MasterRead_BufLO]
    mov  A, [pI2CHW_MasterRead_BufHI]
    romx
    mov  reg[I2CHW_DR],A
    dec  [I2CHW_MasterRead_Count]                            ;calculate addr lsb
    jnc  NoDecHighCount
    dec  [I2CHW_MasterRead_CountHI]
    jc   MstrWRComplete

NoDecHighCount:
    inc  [pI2CHW_MasterRead_BufLO]                           ;set the next flash address to read
    jnc  NoIncHiAddr
    inc  [pI2CHW_MasterRead_BufHI]
NoIncHiAddr:
   jmp   I2CNormalOutput
;
;****** THERE SHOULD BE NO WAY TO REACH THIS STATE WE'LL JUST TERMINATE THE ACTIVITY SINCE WERE THE MASTER
;********    MAY LEAVE IT IN TO DEAL WITH MULTI MASTER SLAVE CONFIGS THOUGH BUT NOT IN THIS FILE
;
;FlashRdOverflow:
    ;deal with the over flow condition by re-sending last data byte (dec the low addr)

;   or    [I2CHW_MasterStatus], I2CHW_RD_OVERFLOW
;                                                                      ;set count back to 0
;   mov   [I2CHW_MasterReadCountHI], 0                                  ;functionally the same as incrementing ffff and less instructions
;   mov   [I2CHW_MasterReadCount], 0
;   jmp   I2CNormalRead

;---------------------------------------------------
; Insert your custom code above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)

ENDIF

;@PSoC_UserCode_BODY3@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
; to modify the way a master might read RAM data to send
; to an I2C device
; By replacing the section from here down to the next block
; a user could process data for a custom I2C READ application
;---------------------------------------------------
ReadOutData:
   ;read the current data byte
IF SYSTEM_LARGE_MEMORY_MODEL
   mov   A, [pI2CHW_MasterRead_BufHI]
ENDIF
   RAM_SETPAGE_IDX A
   mov   X, [pI2CHW_MasterRead_BufLO]
   RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
   mov   A, [X]
   RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
   mov   reg[I2CHW_DR], A
   dec   [I2CHW_MasterRead_Count]

   jc    MstrWRComplete
   inc   [pI2CHW_MasterRead_BufLO]
   jmp   I2CNormalOutput
;
;ram read overflow detected here, just re-send the last location in the buffer
;
;********        THERE SHOULD BE NO WAY TO OVERFLOW FOR THIS CASE
;********    MAY LEAVE IT IN TO DEAL WITH MULTI MASTER SLAVE CONFIGS THOUGH BUT NOT IN THIS FILE
;
;RamRDOverflow:
;   or    [I2CHW_MasterStatus], I2CHW_RD_OVERFLOW
;   inc   [I2CHW_MasterReadCount]                                       ; set back to zero

;---------------------------------------------------
; End user I2C MASTER WRITE TO SLAVE /READ buffer customization section
; Insert your custom code above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)

I2CNormalOutput:
;******************************************************************************************
;;; NORMAL WRITE TO SLAVE (SET I2C_TX bit) (STATE DATA W);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'W'
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
ENDIF

        ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
        ;and place there based on whether or not the previous transmission was our I2C address.
        pop   A
        nop


;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR A                                           ;Sets the I2C_TX bit in the I2C_SCR reg.


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN 

MstrWRComplete:
    and   [I2CHW_MasterStatus], ~0x70                        ;clear the write status bits
; Check if the write was called under No stop or repeat start conditions.
; If yes, then do not generate the stop condition.  The bus is stalled.
; The user may want to use the bus for the next transaction by using repeat start.
    and [I2CHW_bStatus], (I2CHW_NoStop | I2CHW_RepStart)
    jz      CompleteWRXfer                                   ; Complete Transfer condition   
    pop  A                                                   ; Clear the stack for return
    or    [I2CHW_MasterStatus], I2CHW_WR_COMPLETE
    or    [I2CHW_MasterStatus], I2CHW_WR_NOERR

    and  [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE

IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
;******************************************************************************************
;;; EXIT ISR WITHOUT RELEASING BUS REPEAT START/RESTART REQUESTED (STATE DATA Wx);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 0x2c
   lcall TX8_1_PutChar
   mov A, 'x'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
   lcall TX8_1_PutCRLF
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

; Complete Transfer condition. Set the WR_COMPLETE, and WR_NOERR bits and generate
; a Stop.  The release of the I2C_TX bit in I2C_SCR below will automatically generate a stop
CompleteWRXfer:
;******************************************************************************************
;;; RELEASE BUS AFTER LAST BYTE TRANSMITTED TO SLAVE (STATE DATA Ws);;;
;******************************************************************************************
;must also fix up the data count because it was decremented past zero on the Byte_Complete 
;AFTER the last byte was transmitted.  This makes sure that if the entire transmission was
;successful the count will be 0.  
    inc  [I2CHW_MasterRead_Count]                          
IF I2CHW_READ_FLASH
    inc  [I2CHW_MasterRead_CountHI]						 ;if a two byte count decremented past zero
	                                                         ;both high and lo addrs should be incremented.
ENDIF

IF DEBUG_STATE
   mov A, 0x2c
   lcall TX8_1_PutChar
   mov A, 's'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
   lcall TX8_1_PutCRLF
ENDIF
    pop   A

    or    [I2CHW_MasterStatus], I2CHW_WR_COMPLETE
    or    [I2CHW_MasterStatus], I2CHW_WR_NOERR
; Clear the NoStop and RepStart and ISR_ACTIVEbits in the bus status register
    and [I2CHW_bStatus], ~(I2CHW_RepStart | I2CHW_NoStop | I2CHW_ISR_ACTIVE)

;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ;this will release the bus and generate a stop condition


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

; We are here because the Slave NAKed the previous data byte.
; Set the WR_COMPLETE and WR_OVERFLOW bits in the MasterStatus register.
; Also check for NoStop, RepeatStart conditions and accordingly generate a Stop or leave
; the bus stalled
SlaveDataNAK:
;must also fix up the data buffer.  While it is marginally safe to nak a byte as a slave and 
;store it.  It is NEVER safe as a master to notice that a written byte has been nak'ed by a 
;slave and fail to re-send it.
;this piece of code fixes up the count and buffer that the master is using to get data from
;to re-transmit the byte when the next master write is done.
    inc  [I2CHW_MasterRead_Count]                          ;calculate addr lsb
IF I2CHW_READ_FLASH
    jnc  NoIncHighCount
    inc  [I2CHW_MasterRead_CountHI]

NoIncHighCount:
ENDIF
    dec  [pI2CHW_MasterRead_BufLO]                         ;set the next flash address to read
IF SYSTEM_LARGE_MEMORY_MODEL
    jnc  NoDecHiAddr
    dec  [pI2CHW_MasterRead_BufHI]
NoDecHiAddr:
ELSE
IF I2CHW_READ_FLASH
    jnc  NoDecHiCAddr
    dec  [pI2CHW_MasterRead_BufHI]
NoDecHiCAddr:
ENDIF
ENDIF

    tst [I2CHW_bStatus],I2CHW_NoStop
    jnz ReturnSlaveDataNAK
    nop
;******************************************************************************************
;;; SLAVE NAK'ED A TRANSMISSION (STATE DATA 0xWn);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 0x2c
   lcall TX8_1_PutChar
   mov A, 'n'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF

;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ;this will release the bus and generate a stop condition

    jmp UpdateSlaveDataNAKStatus

ReturnSlaveDataNAK:
;******************************************************************************************
;;; SLAVE NAK'ED BUT A DON'T RELEASE BUS AT INITIATING ROUTINES REQUEST (STATE DATA Wz);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 0x2c
   lcall TX8_1_PutChar
   mov A, 'z'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
   lcall TX8_1_PutCRLF
ENDIF
UpdateSlaveDataNAKStatus:
    and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
    and   [I2CHW_MasterStatus], ~0x70                        ;clear the write status bits
    or    [I2CHW_MasterStatus], I2CHW_WR_COMPLETE
    or    [I2CHW_MasterStatus], I2CHW_WR_OVERFLOW

IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

STOPTRAP:
;******************************************************************************************
;;; STOP INTERRUPTS SHOULD NOT GENERALLY BE USED FOR MULTI-MASTER-SLAVE OPERATIONS (STATE DATA Es);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'E'
   lcall TX8_1_PutChar
   mov A, 's'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
   lcall TX8_1_PutCRLF
ENDIF
    BitClrI2CHW_CFG I2C_STOPIE                               ; Disable Stop Interrupt

;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ;this will clear the Stop bit and release the bus


    and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE

IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

;****************************************************************************************
;                                  Slave ISR 
;****************************************************************************************
; 1. Test the Address In bit of I2C_SCR.  If set, then compare the received address with
;    self address.  If match occurs, generate ACK, else NAK.
; 2. If I2C_TX bit of I2C_SCR is set, then we are transmitting and a byte complete interrupt
;    has occurred.  So check the ACK or NAK condition received from the Master.
; 3. If the Stop detect bit of I2C_SCR is set, then process a stop condition.
; 4. If none of the above, then process data received from Master

IF I2CHW_SLAVE_OPTION

I2CHW_ISR_SLAVE:

    tst reg[I2CHW_SCR], I2C_ADDRIN
    jnz I2C_EvaluateADDRIN                                   ; Process received Address

    tst reg[I2CHW_SCR], I2C_TX  
    jnz I2C_EvaluateACKIN                                    ; Process ACK or NAK from Master

    ; KLY Only check stop status if stop interrupt enabled
    IF(I2CHW_USED_I2C_BLOCK)
    M8C_SetBank1
    tst reg[I2CHW_CFG],I2C_STOPIE
    M8C_SetBank0
    ELSE
    tst reg[I2CHW_CFG],I2C_STOPIE
    ENDIF
    jz ProcessRxData

    tst reg[I2CHW_SCR], I2C_STOP_ST
    jnz Slave_STOPTRAP ; Process Stop condition

    ProcessRxData:

    tst reg[I2CHW_SCR], I2C_STOP_ST
    jnz Slave_STOPTRAP                                       ; Process Stop condition

; Process Received Data here

;;code snipped from old SW I2C below
;
; MASTER WRITE to SLAVE
;
;@PSoC_UserCode_BODY4@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------
; By modifying the section from here down to the next comment block
; a user could process data for a custom I2C WRITE application
; NOTE: I2C handshakes (ACK/NAK may be effected by any introduced bugs)
;********************************************************
    tst   [I2CHW_SlaveStatus], fMULTIMASTER_NAK_NEXT_WR
    jnz   WrStoreData
;
;process write data here
;
    dec   [I2CHW_SlaveWrite_Count]
    jc    I2CHW_WriteOverflow                                ; carry set if value became -1
;jz    WrStoreData
    cmp   [I2CHW_SlaveWrite_Count], 00                       ;set nak flag, dec count, and store data
    jz    WrNakNextByte
    jmp   WrNotBufEnd
WrNakNextByte:                                               ;set the ank flag in I2CHW_bStatus
    or    [I2CHW_SlaveStatus], fMULTIMASTER_NAK_NEXT_WR
    jmp   WrStoreData
WrNotBufEnd:
    and   [I2CHW_SlaveStatus], ~fMULTIMASTER_NAK_NEXT_WR     ;clear the nak flag in case it was set from a previous operation
WrStoreData:
;This is the ONLY place this bit is set  This bit should never be cleared by the isr ONLY by the API ClrWrStatus()
    or    [I2CHW_SlaveStatus], I2CHW_WR_NOERR                ;set current status
IF SYSTEM_LARGE_MEMORY_MODEL
    mov   A, [pI2CHW_SlaveWrite_BufHI]
ENDIF
    RAM_SETPAGE_IDX A
    mov   X, [pI2CHW_SlaveWrite_BufLO]
    mov   A, reg[I2CHW_DR]
    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
    mov   [X],A                                              ;save the last byte
    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
    inc   [pI2CHW_SlaveWrite_BufLO] 

    tst   [I2CHW_SlaveStatus], fMULTIMASTER_NAK_NEXT_WR
    jnz   Slave_NAK_this_one

;---------------------------------------------------
; End user I2C WRITE Customization
; Insert your custom code above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)

;******************************************************************************************
;;; ACK DATA RECEIVED FROM ANOTHER MASTER (STATE DATA wa);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'w'
   lcall TX8_1_PutChar
   mov A, 'a'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF


;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR  (I2C_ACKOUT )


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN


;
;ram-write-overflow label here, just rewrite the last location in the buffer
;    and set the overflow flag
;
I2CHW_WriteOverflow:
   or    [I2CHW_SlaveStatus], I2CHW_WR_OVERFLOW              ; flag the overflow
   and   [I2CHW_SlaveStatus], ~I2CHW_WR_NOERR
   inc   [I2CHW_SlaveWrite_Count]                            ; put it back to zero
;If data is to be Nak'ed
Slave_NAK_this_one:
;******************************************************************************************
;;; NAK DATA RECEIVED FROM ANOTHER MASTER (IGNORE FURTHER TRAFFIC) (STATE DATA wn);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'w'
   lcall TX8_1_PutChar
   mov A, 'n'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
;
; If the user wants to process the received data before NAK
; this is the place to do it.
; The Bus will be stalled till the processing is complete.
;
    and   [I2CHW_SlaveStatus], ~fMULTIMASTER_NAK_NEXT_WR     ;clear the nak flag in case it was set from a previous operation


;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR ( 0 )


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN                                                       ;return and wait for the next interrupt (on data)


;********************************************************
; Treat the case where the Slave will be continuing to
; receive data after receiving the address
;********************************************************
I2C_AckAddr_RXdata:
IF I2CHW_POLLED_PROCESS
    or [I2CHW_Poll_Status], I2C_WRITE_STARTED
ELSE
    IF(I2CHW_USED_I2C_BLOCK)
    M8C_SetBank1
    BitSetI2CHW_CFG ( I2C_STOPIE )
    M8C_SetBank0
    ELSE
    BitSetI2CHW_CFG ( I2C_STOPIE )
    ENDIF
ENDIF
;******************************************************************************************
;;; ACK ADDRESS FOR SLAVE WRITE (STATE DATA aw);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'a'
   lcall TX8_1_PutChar
   mov A, 'w'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF


;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR ( I2C_ACKOUT )


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

;********************************************************
; Look to see if the address is us or someone else
; use the carry flag to identify a READ or WRITE address
;********************************************************
I2C_EvaluateADDRIN:
    mov A, [I2CHW_SlaveStatus]
    and A, (I2CHW_WR_NOERR | I2CHW_WR_OVERFLOW)
    jz  NewADDRNotSet                                        ;set new addr only if previous data appears to be in buffer
    or  [I2CHW_SlaveStatus], I2CHW_WR_COMPLETE               ;Same bit as I2CHW_ISR_NEW_ADDR
                                                             ;SET WR_COMPL bit if it appears there was write taking place just previous
                                                             ;to this new address by looking at the status bits


IF I2CHW_POLLED_PROCESS						                                ;if a new addr was received it's OK to terminate stop detection
    and [I2CHW_Poll_Status], ~I2C_WRITE_STARTED              ;used to determine the end of a Master write to a slave.
ELSE													                                            ;A REPEAT START could have terminated the transaction without a STOP
    BitClrI2CHW_CFG I2C_STOPIE
ENDIF
    

NewADDRNotSet:                                               ;use as a way to tag the end of a master write to slave

;@PSoC_UserCode_BODY8@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------
;
; User could modify this section to allow the I2C routine
; to respond to multiple addresses, memory based soft addresses,
; I/O pin based addresses etc.
;

    mov A, reg[I2CHW_DR]
    and F, 0xF9                                              ;clear Carry (C) AND Zero (Z) in Flag register
    rrc A                                                    ;carry now holds bit 0 (r/~w) from addr byte
IF (I2CHW_AUTO_ADDR_CHECK^1)   ;; for CY8C28X45 chip: skip address comparison and NACK sending stage-hardware will do this for us  if AutoAddressCompare feature is enabled.
                                          ;; The code in this pre-compiler directive will be executed for all chips except CY8C28X45.
    xor A,  I2CHW_SLAVE_ADDR                                 ;for an equate
    jnz I2C_Terminate
ENDIF
    or [I2CHW_bStatus], I2CHW_ISR_ACTIVE


;********************************************************
; End user I2C Buffered WRITE (to RAM) Customization
;********************************************************
;@PSoC_UserCode_END@ (Do not change this line.)

I2CHW_send_ack:                                              ;slave send address ack

;OK so the addresses were the same was it a read (c=1) or a write (c=0)
    jnc I2C_AckAddr_RXdata                                   ;(Master Write/Slave Receive) for this case we receive data and ack it

;********************************************************
;Master Read (Master Read/Slave Transmit) Ack the address too.
;for this case the master has just sent us OUR read address which must be Ack'ed and will
;subsequently be reading from us (which the master will Ack.  So for the first bit we must
; set the I2C_TX AND the ACK bits in the I2C_SCR (first byte only)
; THEN we'll just be reading the ACK from the master as it reads our data
;********************************************************
IF DEBUG_STATE
   mov A, 'a'
   lcall TX8_1_PutChar
   mov A, 'r'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF

    and [I2CHW_SlaveStatus], ~I2CHW_RD_COMPLETE              ;Master will NAK us at the end of transaction
    mov A, (I2C_ACKOUT | I2C_TX)
    push A

;
;MASTER is READING FROM SLAVE (ram or flash buffer)
;
;;code snipped from old SW I2C below

I2C_ObtainReadData:

;********************************************************
; here we need to get the next data to output (master-read)
; also set the status byte for use on exit
;********************************************************
IF I2CHW_READ_FLASH
;@PSoC_UserCode_BODY5@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
; User flash read customization could take place within
; this area
;---------------------------------------------------
    tst  [I2CHW_SlaveStatus],I2CHW_READFLASH
    jz   ReadRamData

;
;get the data
;
    mov  X, [pI2CHW_SlaveRead_BufLO]
    mov  A, [pI2CHW_SlaveRead_BufHI]
    romx
    mov  reg[I2CHW_DR],A
    dec  [I2CHW_SlaveRead_Count]                             ;calculate addr lsb
    jnc  SlaveNoDecHighCount
    dec  [I2CHW_SlaveRead_CountHI]
    jc   FlashRdOverflow

SlaveNoDecHighCount:

    inc  [pI2CHW_SlaveRead_BufLO]                            ;set the next flash address to read
    jnc  SlaveNoIncHiAddr
    inc  [pI2CHW_SlaveRead_BufHI]
SlaveNoIncHiAddr:
    jmp   I2CNormalRead

FlashRdOverflow:
;deal with the over flow condition by re-sending last data byte (dec the low order addr byte)

    or    [I2CHW_SlaveStatus], I2CHW_RD_OVERFLOW
    and   [I2CHW_SlaveStatus], ~I2CHW_RD_NOERR
;set count back to 0
    mov   [I2CHW_SlaveRead_CountHI], 0                       ;functionally the same as incrementing ffff and less instructions
    mov   [I2CHW_SlaveRead_Count], 0
    jmp   I2CNormalRead				 
;---------------------------------------------------
; Insert your custom code above this banner
; END User flash read customization
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)

ENDIF

;@PSoC_UserCode_BODY6@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------
; By replacing the section from here down to the next block
; a user could process data for a custom I2C READ application
;********************************************************
ReadRamData:
;read the current data byte
IF SYSTEM_LARGE_MEMORY_MODEL
    mov   A, [pI2CHW_SlaveRead_BufHI]
ENDIF
    RAM_SETPAGE_IDX A
    mov   X, [pI2CHW_SlaveRead_BufLO]
    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
    mov   A, [X]
    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
    mov   reg[I2CHW_DR], A
    dec   [I2CHW_SlaveRead_Count]
    jc    I2CHW_readOverflow
    inc   [pI2CHW_SlaveRead_BufLO]
    jmp   I2CNormalRead
;
;ram read overflow detected here, just re-send the last location in the buffer
;
I2CHW_readOverflow:
    or    [I2CHW_SlaveStatus], I2CHW_RD_OVERFLOW
    and   [I2CHW_SlaveStatus], ~I2CHW_RD_NOERR
    inc   [I2CHW_SlaveRead_Count]                            ; set back to zero

;********************************************************
; End user I2C READ customization section
;********************************************************
; Insert your custom code above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)


I2CNormalRead:

;******************************************************************************************
;;; MASTER READ (SLAVE TRANSMITTING DATA) (STATE DATA r);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'r'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
;and place there based on whether or not the previous transmission was our I2C address.
    pop A

;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR A                                           ;set read bit as (bit0) and addr bit (bit7)in the I2C_SCR


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN                                                       ;return and wait for the next interrupt (on data)

; 1. If NAK received from Master, then clear the ISR_ACTIVE flag in bStatus register, set
;    the RD_NO_ERR and RD_COMPLETE flags in SlaveStatus register and wait for the next 
;    address to be received.
; 2. If ACK received from Master, then transmit the next byte.
I2C_EvaluateACKIN:
    tst reg[I2CHW_SCR], I2C_LST_BIT
    jnz I2C_LastByteToMstr                                   ; Terminate and wait for next address
    
    mov A, ( I2C_TX )
    push A
    jmp I2C_ObtainReadData                                   ; Send next byte to Master

I2C_LastByteToMstr:
    or  [I2CHW_SlaveStatus], I2CHW_RD_NOERR 
    or  [I2CHW_SlaveStatus], I2CHW_RD_COMPLETE
	and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
;******************************************************************************************
;;; MASTER NAK'ED READ DATA (STATE DATA rn);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'r'
   lcall TX8_1_PutChar
   mov A, 'n'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF DEBUG_STATE
   lcall TX8_1_PutCRLF
ENDIF
jmp  I2C_TerminateSlaveRead

I2C_Terminate:
;******************************************************************************************
;;; NAK ADDRESS FOR SLAVE (STATE DATA an);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'a'
   lcall TX8_1_PutChar
   mov A, 'n'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
IF SNIFF_DATA
   mov A, reg[I2CHW_DR]
   lcall TX8_1_PutSHexByte
   mov A, 0x2c
   lcall TX8_1_PutChar
ENDIF
I2C_TerminateSlaveRead:
    and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE


;
;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
;
    SetI2CHW_SCR 0                                           ;the default mode to wait for an address


IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

; A Stop Condition has been detected.
Slave_STOPTRAP:
    ;I2C stop detected
;
; set a flag to indicate END OF TRANSMISSION
;
    or  [I2CHW_SlaveStatus], I2CHW_WR_COMPLETE               ;only SET by ISR USER must clear.
    and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
IF I2CHW_POLLED_PROCESS
    and [I2CHW_Poll_Status], ~I2C_WRITE_STARTED
    jmp ExitISR
ELSE
    BitClrI2CHW_CFG I2C_STOPIE
    tst reg[I2CHW_SCR], I2C_BYTE_COMPL
;;if BYTE_COMPL is set, there's an excellent chance to lose an ISR.  Because of the way they are
;; latched into the INT_MSK.  Therefore clear the applicable bit (STOPIE) and jump directly to the 
;; top of this routing since the bus is currently stalled.  Just in case the ISR is properly latched,
;; clear the mask bit since it's is serviced manually.
    jz ExitISR
    and  reg[INT_CLR3], ~0x01                                ;clear the I2C interrupt
ENDIF
;******************************************************************************************
;;;  FORCING INTERRUPT REPROCESS (STATE DATA Sf);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'S'
   lcall TX8_1_PutChar
   mov A, 'f'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
   lcall TX8_1_PutCRLF
ENDIF
	jmp Process_REENTRY
	
ExitISR: 
;******************************************************************************************
;;; SLAVE NORMAL STOP (STATE DATA S);;;
;******************************************************************************************
IF DEBUG_STATE
   mov A, 'S'
   lcall TX8_1_PutChar
   mov A, 0x2c
   lcall TX8_1_PutChar
   lcall TX8_1_PutCRLF
ENDIF

IF SYSTEM_LARGE_MEMORY_MODEL
    REG_RESTORE IDX_PP
ENDIF
    pop X
    pop A
    RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
    I2CHW_SERVICE_RETURN

ENDIF

; end of file I2CHWINT.asm
