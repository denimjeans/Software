FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.3.2710
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.40
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C21x23 microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0068) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0069) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0070) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0071) ; bytes on the stack which are otherwise required for the return address. If
                                        (0072) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0073) ; release, the C compiler automatically places an infinite loop at the end
                                        (0074) ; of main, rather than a return instruction.)
                                        (0075) ;
                                        (0076) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0077) 
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ; Interrupt Vector Table
                                        (0081) ;-----------------------------------------------------------------------------
                                        (0082) ;
                                        (0083) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0084) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0085) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0086) ; vector jump targets are modified automatically according to the user
                                        (0087) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0088) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0089) ; configuration files. If you need to hard code a vector, update the
                                        (0090) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0091) ; of this file.
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) 
                                        (0094)     AREA TOP (ROM, ABS, CON)
                                        (0095) 
                                        (0096)     org   0                        ;Reset Interrupt Vector
                                        (0097) IF	(TOOLCHAIN & HITECH)
                                        (0098) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0099) ELSE
0000: 80 67    JMP   0x0068             (0100)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0101) ENDIF
                                        (0102)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0103)     ;---------------------------------------------------
                                        (0104)     ; Insert your custom code below this banner
                                        (0105)     ;---------------------------------------------------
                                        (0106) 
                                        (0107)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0108)     halt                           ;Stop execution if power falls too low
                                        (0109) 
                                        (0110)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0111)     // call	void_handler
0008: 7E       RETI                     (0112)     reti
                                        (0113) 
                                        (0114)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0115)     // call	void_handler
000C: 7E       RETI                     (0116)     reti
                                        (0117) 
                                        (0118)     org   18h                      ;VC3 Interrupt Vector
                                        (0119)     // call	void_handler
0018: 7E       RETI                     (0120)     reti
                                        (0121) 
                                        (0122)     org   1Ch                      ;GPIO Interrupt Vector
                                        (0123)     // call	void_handler
001C: 7E       RETI                     (0124)     reti
                                        (0125) 
                                        (0126)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                        (0127)     // call	void_handler
0020: 7E       RETI                     (0128)     reti
                                        (0129) 
                                        (0130)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 02 45 LJMP  _PWM16_ISR         (0131)     ljmp	_PWM16_ISR
0027: 7E       RETI                     (0132)     reti
                                        (0133) 
                                        (0134)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0135)     // call	void_handler
0028: 7E       RETI                     (0136)     reti
                                        (0137) 
                                        (0138)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                        (0139)     // call	void_handler
002C: 7E       RETI                     (0140)     reti
                                        (0141) 
                                        (0142)     org   60h                      ;PSoC I2C Interrupt Vector
0060: 7D 04 D5 LJMP  _I2CHW_ISR         (0143)     ljmp	_I2CHW_ISR
0063: 7E       RETI                     (0144)     reti
                                        (0145) 
                                        (0146)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0147)     // call	void_handler
0064: 7E       RETI                     (0148)     reti
0068: 71 10    OR    F,0x10             
                                        (0149)     ;---------------------------------------------------
                                        (0150)     ; Insert your custom code above this banner
                                        (0151)     ;---------------------------------------------------
                                        (0152)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0153) 
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  Start of Execution.
                                        (0156) ;-----------------------------------------------------------------------------
                                        (0157) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0158) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0159) ;
                                        (0160) 
                                        (0161) IF	(TOOLCHAIN & HITECH)
                                        (0162)  	AREA PD_startup(CODE, REL, CON)
                                        (0163) ELSE
                                        (0164)     org 68h
                                        (0165) ENDIF
                                        (0166) __Start:
                                        (0167) 
                                        (0168)     ; initialize SMP values for voltage stabilization, if required,
                                        (0169)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0170)     ; least for now. 
                                        (0171)     ;
                                        (0172)     M8C_SetBank1
006A: 62 E3 87 MOV   REG[0xE3],0x87     (0173)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,0xEF             
006F: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0174)     M8C_SetBank0
                                        (0175) 
                                        (0176) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0177) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0178)     M8C_EnableWatchDog
                                        (0179) ENDIF
                                        (0180) 
0072: 41 FE FB AND   REG[0xFE],0xFB     (0181)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0182) 
                                        (0183) IF	(TOOLCHAIN & HITECH)
                                        (0184)     ;---------------------------
                                        (0185)     ; Set up the Temporary stack
                                        (0186)     ;---------------------------
                                        (0187)     ; A temporary stack is set up for the SSC instructions.
                                        (0188)     ; The real stack start will be assigned later.
                                        (0189)     ;
                                        (0190) 	global		__Lstackps
                                        (0191) 	mov     a,low __Lstackps
                                        (0192) 	swap    a,sp
                                        (0193) ELSE
                                        (0194)     ;------------------
                                        (0195)     ; Set up the stack
                                        (0196)     ;------------------
0075: 50 0F    MOV   A,0xF              (0197)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A               (0198)     swap  SP, A                    ; This is only temporary if going to LMM
0078: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0199) ENDIF
                                        (0200) 
                                        (0201)     ;-----------------------------------------------
                                        (0202)     ; Set Power-related Trim.
                                        (0203)     ;-----------------------------------------------
                                        (0204) M8C_ClearWDTAndSleep ; Clear WDT before enabling it.
                                        (0205) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0206)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0207)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0208)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V
                                        (0209)  ENDIF
                                        (0210) ENDIF ; 5.0 V Operation
                                        (0211) 
                                        (0212) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0213)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0214)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0215)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V
                                        (0216)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0217)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V
                                        (0218)  ENDIF
                                        (0219) ENDIF ; 3.3 Volt Operation
                                        (0220) 
                                        (0221) IF ( POWER_SETTING & POWER_SET_2V7_12MHZ)      ; *** 2.7 Volts / 12MHZ operation ***
                                        (0222)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0223)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_12MHZ, SSCTBL2_TRIM_BGR_2V
                                        (0224) ENDIF ; *** 2.7 Volts / 12MHZ operation ***
                                        (0225) 
                                        (0226) IF ( POWER_SETTING & POWER_SET_2V7_6MHZ)       ; *** 2.7 Volts /  6MHZ operation ***
                                        (0227)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0228)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_6MHZ,  SSCTBL2_TRIM_BGR_2V
                                        (0229) ENDIF ; *** 2.7 Volts /  6MHZ operation ***
                                        (0230) 
007B: 55 F8 00 MOV   [0xF8],0x0         (0231)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
007E: 55 F9 00 MOV   [0xF9],0x0         (0232)     mov  [bSSC_KEYSP], 0
0081: 71 10    OR    F,0x10             
                                        (0233) 
                                        (0234)     ;---------------------------------------
                                        (0235)     ; Initialize Crystal Oscillator and PLL
                                        (0236)     ;---------------------------------------
                                        (0237) IF ( POWER_SETTING & POWER_SET_2V7)       ; *** 2.7 Volts  ***
                                        (0238)     M8C_SetBank1
                                        (0239)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_3MHz)
                                        (0240)     M8C_SetBank0
                                        (0241)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0242) 
                                        (0243) ELSE 	 ;*** all other voltages OK for 12Mhz ***
                                        (0244)     M8C_SetBank1
0083: 62 E0 02 MOV   REG[0xE0],0x2      (0245)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
0086: 70 EF    AND   F,0xEF             
0088: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0246)     M8C_SetBank0
                                        (0247)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0248) 
                                        (0249) ENDIF
                                        (0250) 
                                        (0251)     ;-------------------------------------------------------
                                        (0252)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0253)     ;-------------------------------------------------------
                                        (0254) 
                                        (0255)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0256) 
                                        (0257) IF (SYSCLK_SOURCE)
                                        (0258)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0259) ENDIF
                                        (0260)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0261) 
                                        (0262)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0263)     ;---------------------------------------------------
                                        (0264)     ; Insert your custom code below this banner
                                        (0265)     ;---------------------------------------------------
                                        (0266) 
                                        (0267)     ;---------------------------------------------------
                                        (0268)     ; Insert your custom code above this banner
                                        (0269)     ;---------------------------------------------------
                                        (0270)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0271) 
                                        (0272)     ;-------------------------
                                        (0273)     ; Load Base Configuration
                                        (0274)     ;-------------------------
                                        (0275)     ; Load global parameter settings and load the user modules in the
                                        (0276)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0277)     ; to minimize start up time; (2) We may still need to play with the
                                        (0278)     ; Sleep Timer.
                                        (0279)     ;
008B: 7C 01 E7 LCALL 0x01E7             (0280)     lcall LoadConfigInit
                                        (0281) 
                                        (0282)     ;-----------------------------------
                                        (0283)     ; Initialize C Run-Time Environment
                                        (0284)     ;-----------------------------------
                                        (0285) IF ( C_LANGUAGE_SUPPORT )
008E: 50 00    MOV   A,0x0              (0286)     mov  A,0                           ; clear the 'bss' segment to zero
0090: 55 00 0F MOV   [__r0],0xF         (0287)     mov  [__r0],<__bss_start
                                        (0288) BssLoop:
0093: 3C 00 0F CMP   [__r0],0xF         (0289)     cmp  [__r0],<__bss_end
0096: A0 05    JZ    0x009C             (0290)     jz   BssDone
0098: 3F 00    MVI   [__r0],A           (0291)     mvi  [__r0],A
009A: 8F F8    JMP   0x0093             (0292)     jmp  BssLoop
                                        (0293) BssDone:
009C: 50 01    MOV   A,0x1              (0294)     mov  A,>__idata_start              ; copy idata to data segment
009E: 57 A2    MOV   X,0xA2             (0295)     mov  X,<__idata_start
00A0: 55 00 00 MOV   [__r0],0x0         (0296)     mov  [__r0],<__data_start
                                        (0297) IDataLoop:
00A3: 3C 00 00 CMP   [__r0],0x0         (0298)     cmp  [__r0],<__data_end
00A6: A0 0B    JZ    0x00B2             (0299)     jz   C_RTE_Done
00A8: 08       PUSH  A                  (0300)     push A
00A9: 28       ROMX                     (0301)     romx
00AA: 3F 00    MVI   [__r0],A           (0302)     mvi  [__r0],A
00AC: 18       POP   A                  (0303)     pop  A
00AD: 75       INC   X                  (0304)     inc  X
00AE: 09 00    ADC   A,0x0              (0305)     adc  A,0
00B0: 8F F2    JMP   0x00A3             (0306)     jmp  IDataLoop
00B2: 71 10    OR    F,0x10             
                                        (0307) 
                                        (0308) C_RTE_Done:
                                        (0309) 
                                        (0310) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0311) 
                                        (0312)     ;-------------------------------
                                        (0313)     ; Voltage Stabilization for SMP
                                        (0314)     ;-------------------------------
                                        (0315) 
                                        (0316) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0317) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0318)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0319)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0320)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0321)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0322)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0323)     M8C_SetBank1
                                        (0324)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0325)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0326)     M8C_SetBank0
                                        (0327)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0328)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0329) .WaitFor2ms:
                                        (0330)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0331)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0332) ENDIF ; SMP is operational
                                        (0333) ENDIF ; 5.0V Operation
                                        (0334) 
                                        (0335)     ;-------------------------------
                                        (0336)     ; Set Power-On Reset (POR) Level
                                        (0337)     ;-------------------------------
                                        (0338)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0339)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0340)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0341)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0342)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0343) 
                                        (0344)     M8C_SetBank1
                                        (0345) 
                                        (0346) IF (POWER_SETTING & POWER_SET_2V7)             ; 2.7V Operation?
                                        (0347)                                                ;  Yes, lowest trip already set
                                        (0348) ELSE                                           ;   No, must adjust POR...
                                        (0349) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
                                        (0350)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, change to midpoint trip
                                        (0351) ELSE
                                        (0352) IF (POWER_SETTING & POWER_SET_5V0)             ; 5.0V Operation?
                                        (0353)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)       ; and Slow Mode?
                                        (0354)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, set to midpoint trip
                                        (0355)  ELSE                                          ;    No, fast mode
                                        (0356)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
                                        (0357)     or   reg[VLT_CR], VLT_CR_POR_MID           ;         No, change to midpoint trip
                                        (0358)   ELSE ; 24HMz                                 ;
00B4: 43 E3 20 OR    REG[0xE3],0x20     (0359)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
00B7: 70 EF    AND   F,0xEF             
                                        (0360)   ENDIF ; 24MHz
                                        (0361)  ENDIF ; Slow Mode
                                        (0362) ENDIF ; 5.0V Operation
                                        (0363) ENDIF ; 3.3V Operation
                                        (0364) ENDIF ; 2.7V Operation
                                        (0365) 
                                        (0366)     M8C_SetBank0
                                        (0367) 
                                        (0368)     ;----------------------------
                                        (0369)     ; Wrap up and invoke "main"
                                        (0370)     ;----------------------------
                                        (0371) 
                                        (0372)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0373)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0374)     ;
00B9: 62 E0 00 MOV   REG[0xE0],0x0      (0375)     mov  reg[INT_MSK0],0
00BC: 71 10    OR    F,0x10             
                                        (0376) 
                                        (0377)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0378)     ;
                                        (0379)     M8C_SetBank1
00BE: 62 E0 03 MOV   REG[0xE0],0x3      (0380)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
00C1: 70 EF    AND   F,0xEF             
                                        (0381)     M8C_SetBank0
                                        (0382) 
                                        (0383)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0384)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0385)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0386)     ;
00C3: 62 E2 00 MOV   REG[0xE2],0x0      (0387)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0388)                                    ; have been set during the boot process.
                                        (0389) IF	(TOOLCHAIN & HITECH)
                                        (0390) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0391) ELSE
                                        (0392) IF ENABLE_LJMP_TO_MAIN
                                        (0393)     ljmp  _main                    ; goto main (no return)
                                        (0394) ELSE
00C6: 7C 07 D2 LCALL __UserModules_end|__text_start|_main|_main(0395)     lcall _main                    ; call main
                                        (0396) .Exit:
00C9: 8F FF    JMP   0x00C9             (0397)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0398) ENDIF
                                        (0399) ENDIF ; TOOLCHAIN
                                        (0400) 
                                        (0401)     ;---------------------------------
                                        (0402)     ; Library Access to Global Parms
                                        (0403)     ;---------------------------------
                                        (0404)     ;
                                        (0405)  bGetPowerSetting:
                                        (0406) _bGetPowerSetting:
                                        (0407)     ; Returns value of POWER_SETTING in the A register.
                                        (0408)     ; No inputs. No Side Effects.
                                        (0409)     ;
                                        (0410) IF (POWER_SETTING & POWER_SET_2V7)
                                        (0411)     mov   A, POWER_SETTING | POWER_SET_SLOW_IMO
                                        (0412) ELSE
00CB: 50 10    MOV   A,0x10             (0413)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
                                        (0414) ENDIF
00CD: 7F       RET                      (0415)     ret
                                        (0416) 
                                        (0417) IF	(TOOLCHAIN & HITECH)
                                        (0418) ELSE
                                        (0419)     ;---------------------------------
                                        (0420)     ; Order Critical RAM & ROM AREAs
                                        (0421)     ;---------------------------------
                                        (0422)     ;  'TOP' is all that has been defined so far...
                                        (0423) 
                                        (0424)     ;  ROM AREAs for C CONST, static & global items
                                        (0425)     ;
                                        (0426)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0427)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0428) __idata_start:
                                        (0429) 
                                        (0430)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0431) __func_lit_start:
                                        (0432) 
                                        (0433)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0434)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0435) 
                                        (0436)     ; CODE segment for general use
                                        (0437)     ;
                                        (0438)     AREA text (ROM, REL, CON)
                                        (0439) __text_start:
                                        (0440) 
                                        (0441)     ; RAM area usage
                                        (0442)     ;
                                        (0443)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0444) __data_start:
                                        (0445) 
                                        (0446)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0447)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0448)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0449) __bss_start:
                                        (0450) 
                                        (0451) ENDIF ; TOOLCHAIN
                                        (0452) 
                                        (0453) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.3.2710
01A2: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) include "m8c.inc"
                                        (0004) ;  Personalization tables 
                                        (0005) export LoadConfigTBL_hp03s_Bank1
                                        (0006) export LoadConfigTBL_hp03s_Bank0
                                        (0007) export LoadConfigTBL_hp03s_Ordered
                                        (0008) AREA lit(rom, rel)
                                        (0009) LoadConfigTBL_hp03s_Bank0:
                                        (0010) ;  Instance name I2CHW, User Module I2CHW
                                        (0011) ;  Instance name PWM16, User Module PWM16
                                        (0012) ;       Instance name PWM16, Block Name PWM16_LSB(DBB00)
                                        (0013) 	db		23h, 00h		;PWM16_CONTROL_LSB_REG(DBB00CR0)
                                        (0014) 	db		21h, 2dh		;PWM16_PERIOD_LSB_REG(DBB00DR1)
                                        (0015) 	db		22h, 17h		;PWM16_COMPARE_LSB_REG(DBB00DR2)
                                        (0016) ;       Instance name PWM16, Block Name PWM16_MSB(DBB01)
                                        (0017) 	db		27h, 00h		;PWM16_CONTROL_MSB_REG(DBB01CR0)
                                        (0018) 	db		25h, 00h		;PWM16_PERIOD_MSB_REG(DBB01DR1)
                                        (0019) 	db		26h, 00h		;PWM16_COMPARE_MSB_REG(DBB01DR2)
                                        (0020) ;  Global Register values Bank 0
                                        (0021) 	db		60h, 09h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0022) 	db		64h, 00h		; AnalogComparatorControl0 register (CMP_CR0)
                                        (0023) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0024) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0025) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0026) 	db		d6h, 44h		; I2CConfig register (I2CCFG)
                                        (0027) 	db		62h, 00h		; PWM_Control register (PWM_CR)
                                        (0028) 	db		b0h, 00h		; Row_0_InputMux register (RDI0RI)
                                        (0029) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0030) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0031) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0032) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0033) 	db		b5h, 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0034) 	db		b6h, 10h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0035) 	db		ffh
                                        (0036) LoadConfigTBL_hp03s_Bank1:
                                        (0037) ;  Instance name I2CHW, User Module I2CHW
                                        (0038) ;  Instance name PWM16, User Module PWM16
                                        (0039) ;       Instance name PWM16, Block Name PWM16_LSB(DBB00)
                                        (0040) 	db		20h, 11h		;PWM16_FUNC_LSB_REG(DBB00FN)
                                        (0041) 	db		21h, 15h		;PWM16_INPUT_LSB_REG(DBB00IN)
                                        (0042) 	db		22h, 40h		;PWM16_OUTPUT_LSB_REG(DBB00OU)
                                        (0043) ;       Instance name PWM16, Block Name PWM16_MSB(DBB01)
                                        (0044) 	db		24h, 39h		;PWM16_FUNC_MSB_REG(DBB01FN)
                                        (0045) 	db		25h, 35h		;PWM16_INPUT_MSB_REG(DBB01IN)
                                        (0046) 	db		26h, 47h		;PWM16_OUTPUT_MSB_REG(DBB01OU)
                                        (0047) ;  Global Register values Bank 1
                                        (0048) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0049) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0050) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0051) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0052) 	db		64h, 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
                                        (0053) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0054) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0055) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0056) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0057) 	db		e1h, ffh		; OscillatorControl_1 register (OSC_CR1)
                                        (0058) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0059) 	db		dfh, ffh		; OscillatorControl_3 register (OSC_CR3)
                                        (0060) 	db		deh, 02h		; OscillatorControl_4 register (OSC_CR4)
                                        (0061) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0062) 	db		ffh
                                        (0063) AREA psoc_config(rom, rel)
                                        (0064) LoadConfigTBL_hp03s_Ordered:
                                        (0065) ;  Ordered Global Register values
                                        (0066) 	M8C_SetBank0
01A4: 62 00 00 MOV   REG[0x0],0x0       (0067) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
01A7: 71 10    OR    F,0x10             
                                        (0068) 	M8C_SetBank1
01A9: 62 00 08 MOV   REG[0x0],0x8       (0069) 	mov	reg[00h], 08h		; Port_0_DriveMode_0 register (PRT0DM0)
01AC: 62 01 34 MOV   REG[0x1],0x34      (0070) 	mov	reg[01h], 34h		; Port_0_DriveMode_1 register (PRT0DM1)
01AF: 70 EF    AND   F,0xEF             
                                        (0071) 	M8C_SetBank0
01B1: 62 03 34 MOV   REG[0x3],0x34      (0072) 	mov	reg[03h], 34h		; Port_0_DriveMode_2 register (PRT0DM2)
01B4: 62 02 08 MOV   REG[0x2],0x8       (0073) 	mov	reg[02h], 08h		; Port_0_GlobalSelect register (PRT0GS)
01B7: 71 10    OR    F,0x10             
                                        (0074) 	M8C_SetBank1
01B9: 62 02 00 MOV   REG[0x2],0x0       (0075) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
01BC: 62 03 00 MOV   REG[0x3],0x0       (0076) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
01BF: 70 EF    AND   F,0xEF             
                                        (0077) 	M8C_SetBank0
01C1: 62 01 00 MOV   REG[0x1],0x0       (0078) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
01C4: 62 04 03 MOV   REG[0x4],0x3       (0079) 	mov	reg[04h], 03h		; Port_1_Data register (PRT1DR)
01C7: 71 10    OR    F,0x10             
                                        (0080) 	M8C_SetBank1
01C9: 62 04 03 MOV   REG[0x4],0x3       (0081) 	mov	reg[04h], 03h		; Port_1_DriveMode_0 register (PRT1DM0)
01CC: 62 05 03 MOV   REG[0x5],0x3       (0082) 	mov	reg[05h], 03h		; Port_1_DriveMode_1 register (PRT1DM1)
01CF: 70 EF    AND   F,0xEF             
                                        (0083) 	M8C_SetBank0
01D1: 62 07 03 MOV   REG[0x7],0x3       (0084) 	mov	reg[07h], 03h		; Port_1_DriveMode_2 register (PRT1DM2)
01D4: 62 06 00 MOV   REG[0x6],0x0       (0085) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
01D7: 71 10    OR    F,0x10             
                                        (0086) 	M8C_SetBank1
01D9: 62 06 00 MOV   REG[0x6],0x0       (0087) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
01DC: 62 07 00 MOV   REG[0x7],0x0       (0088) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
01DF: 70 EF    AND   F,0xEF             
                                        (0089) 	M8C_SetBank0
01E1: 62 05 00 MOV   REG[0x5],0x0       (0090) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
01E4: 70 EF    AND   F,0xEF             
                                        (0091) 	M8C_SetBank0
01E6: 7F       RET                      (0092) 	ret
                                        (0093) 
                                        (0094) 
                                        (0095) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.3.2710
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_hp03s
                                        (0026) export _LoadConfig_hp03s
                                        (0027) 
                                        (0028) export NO_SHADOW
                                        (0029) export _NO_SHADOW
                                        (0030) 
                                        (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0033) 
                                        (0034) AREA psoc_config(rom, rel)
                                        (0035) 
                                        (0036) ;---------------------------------------------------------------------------
                                        (0037) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0038) ;                  parameters handled by boot code, like CPU speed). This
                                        (0039) ;                  function can be called from user code, but typically it
                                        (0040) ;                  is only called from boot.
                                        (0041) ;
                                        (0042) ;       INPUTS: None.
                                        (0043) ;      RETURNS: Nothing.
                                        (0044) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0045) ;               In the large memory model currently only the page
                                        (0046) ;               pointer registers listed below are modified.  This does
                                        (0047) ;               not guarantee that in future implementations of this
                                        (0048) ;               function other page pointer registers will not be
                                        (0049) ;               modified.
                                        (0050) ;          
                                        (0051) ;               Page Pointer Registers Modified: 
                                        (0052) ;               CUR_PP
                                        (0053) ;
                                        (0054) _LoadConfigInit:
                                        (0055)  LoadConfigInit:
                                        (0056)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0057)     
01E7: 7C 01 EE LCALL 0x01EE             (0058) 	lcall	LoadConfig_hp03s
01EA: 7C 01 A2 LCALL 0x01A2             (0059) 	lcall	LoadConfigTBL_hp03s_Ordered
                                        (0060) 
                                        (0061) 
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
01ED: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) ;---------------------------------------------------------------------------
                                        (0066) ; Load Configuration hp03s
                                        (0067) ;
                                        (0068) ;    Load configuration registers for hp03s.
                                        (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0070) ;
                                        (0071) ;       INPUTS: None.
                                        (0072) ;      RETURNS: Nothing.
                                        (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0074) ;               modified as may the Page Pointer registers!
                                        (0075) ;               In the large memory model currently only the page
                                        (0076) ;               pointer registers listed below are modified.  This does
                                        (0077) ;               not guarantee that in future implementations of this
                                        (0078) ;               function other page pointer registers will not be
                                        (0079) ;               modified.
                                        (0080) ;          
                                        (0081) ;               Page Pointer Registers Modified: 
                                        (0082) ;               CUR_PP
                                        (0083) ;
                                        (0084) _LoadConfig_hp03s:
                                        (0085)  LoadConfig_hp03s:
                                        (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0087) 
01EE: 10       PUSH  X                  (0088) 	push	x
01EF: 70 EF    AND   F,0xEF             
                                        (0089)     M8C_SetBank0                    ; Force bank 0
01F1: 50 00    MOV   A,0x0              (0090)     mov     a, 0                    ; Specify bank 0
01F3: 67       ASR   A                  (0091)     asr     a                       ; Store in carry flag
                                        (0092)                                     ; Load bank 0 table:
01F4: 50 01    MOV   A,0x1              (0093)     mov     A, >LoadConfigTBL_hp03s_Bank0
01F6: 57 50    MOV   X,0x50             (0094)     mov     X, <LoadConfigTBL_hp03s_Bank0
01F8: 7C 02 09 LCALL 0x0209             (0095)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0096) 
01FB: 50 01    MOV   A,0x1              (0097)     mov     a, 1                    ; Specify bank 1
01FD: 67       ASR   A                  (0098)     asr     a                       ; Store in carry flag
                                        (0099)                                     ; Load bank 1 table:
01FE: 50 01    MOV   A,0x1              (0100)     mov     A, >LoadConfigTBL_hp03s_Bank1
0200: 57 79    MOV   X,0x79             (0101)     mov     X, <LoadConfigTBL_hp03s_Bank1
0202: 7C 02 09 LCALL 0x0209             (0102)     lcall   LoadConfig              ; Load the bank 1 values
0205: 70 EF    AND   F,0xEF             
                                        (0103) 
                                        (0104)     M8C_SetBank0                    ; Force return to bank 0
0207: 20       POP   X                  (0105) 	pop		x
                                        (0106) 
                                        (0107)     RAM_EPILOGUE RAM_USE_CLASS_4
0208: 7F       RET                      (0108)     ret
                                        (0109) 
                                        (0110) 
                                        (0111) 
                                        (0112) 
                                        (0113) ;---------------------------------------------------------------------------
                                        (0114) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0115) ;              pairs. Terminate on address=0xFF.
                                        (0116) ;
                                        (0117) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0118) ;           Flag Register Carry bit encodes the Register Bank
                                        (0119) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0120) ;
                                        (0121) ;  RETURNS: nothing.
                                        (0122) ;
                                        (0123) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0124) ;                X-3 Temporary store for register address
                                        (0125) ;                X-2 LSB of config table address
                                        (0126) ;                X-1 MSB of config table address
                                        (0127) ;
                                        (0128) LoadConfig:
                                        (0129)     RAM_PROLOGUE RAM_USE_CLASS_2
0209: 38 02    ADD   SP,0x2             (0130)     add     SP, 2                   ; Set up local vars
020B: 10       PUSH  X                  (0131)     push    X                       ; Save config table address on stack
020C: 08       PUSH  A                  (0132)     push    A
020D: 4F       MOV   X,SP               (0133)     mov     X, SP
020E: 56 FC 00 MOV   [X-4],0x0          (0134)     mov     [X-4], 0                ; Set default Destination to Bank 0
0211: D0 04    JNC   0x0216             (0135)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
0213: 56 FC 01 MOV   [X-4],0x1          (0136)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0137) .BankSelectSaved:
0216: 18       POP   A                  (0138)     pop     A
0217: 20       POP   X                  (0139)     pop     X
0218: 70 EF    AND   F,0xEF             
021A: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0140) 
                                        (0141) LoadConfigLp:
                                        (0142)     M8C_SetBank0                    ; Switch to bank 0
                                        (0143)     M8C_ClearWDT                    ; Clear the watchdog for long inits
021D: 10       PUSH  X                  (0144)     push    X                       ; Preserve the config table address
021E: 08       PUSH  A                  (0145)     push    A
021F: 28       ROMX                     (0146)     romx                            ; Load register address from table
0220: 39 FF    CMP   A,0xFF             (0147)     cmp     A, END_CONFIG_TABLE     ; End of table?
0222: A0 1F    JZ    0x0242             (0148)     jz      EndLoadConfig           ;   Yes, go wrap it up
0224: 4F       MOV   X,SP               (0149)     mov     X, SP                   ;
0225: 48 FC 01 TST   [X-4],0x1          (0150)     tst     [X-4], 1                ; Loading IO Bank 1?
0228: A0 03    JZ    0x022C             (0151)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
022A: 71 10    OR    F,0x10             
                                        (0152)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0153) .IOBankNowSet:
022C: 54 FD    MOV   [X-3],A            (0154)     mov     [X-3], A                ; Stash the register address
022E: 18       POP   A                  (0155)     pop     A                       ; Retrieve the table address
022F: 20       POP   X                  (0156)     pop     X
0230: 75       INC   X                  (0157)     inc     X                       ; Advance to the data byte
0231: 09 00    ADC   A,0x0              (0158)     adc     A, 0
0233: 10       PUSH  X                  (0159)     push    X                       ; Save the config table address again
0234: 08       PUSH  A                  (0160)     push    A
0235: 28       ROMX                     (0161)     romx                            ; load config data from the table
0236: 4F       MOV   X,SP               (0162)     mov     X, SP                   ; retrieve the register address
0237: 59 FD    MOV   X,[X-3]            (0163)     mov     X, [X-3]
0239: 61 00    MOV   REG[X+0x0],A       (0164)     mov     reg[X], A               ; Configure the register
023B: 18       POP   A                  (0165)     pop     A                       ; retrieve the table address
023C: 20       POP   X                  (0166)     pop     X
023D: 75       INC   X                  (0167)     inc     X                       ; advance to next table entry
023E: 09 00    ADC   A,0x0              (0168)     adc     A, 0
0240: 8F D7    JMP   0x0218             (0169)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0170) EndLoadConfig:
0242: 38 FC    ADD   SP,0xFC            (0171)     add     SP, -4
                                        (0172)     RAM_EPILOGUE RAM_USE_CLASS_2
0244: 7F       RET                      (0173)     ret
                                        (0174) 
                                        (0175) AREA InterruptRAM(ram, rel)
                                        (0176) 
                                        (0177) NO_SHADOW:
                                        (0178) _NO_SHADOW:
FILE: lib\pwm16int.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2012/9/21 at 11:59:18
                                        (0005) ;;  Generated by PSoC Designer 5.3.2710
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWM16.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWM16_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWM16_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWM16_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068) 
                                        (0069)    ;---------------------------------------------------
                                        (0070)    ; Insert your custom assembly code above this banner
                                        (0071)    ;---------------------------------------------------
                                        (0072)    
                                        (0073)    ;---------------------------------------------------
                                        (0074)    ; Insert a lcall to a C function below this banner
                                        (0075)    ; and un-comment the lines between these banners
                                        (0076)    ;---------------------------------------------------
                                        (0077)    
                                        (0078)    ;PRESERVE_CPU_CONTEXT
                                        (0079)    ;lcall _My_C_Function
                                        (0080)    ;RESTORE_CPU_CONTEXT
                                        (0081)    
                                        (0082)    ;---------------------------------------------------
                                        (0083)    ; Insert a lcall to a C function above this banner
                                        (0084)    ; and un-comment the lines between these banners
                                        (0085)    ;---------------------------------------------------
                                        (0086)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0087) 
0245: 7E       RETI                     (0088)    reti
                                        (0089) 
                                        (0090) 
                                        (0091) ; end of file PWM16INT.asm
FILE: lib\pwm16.asm                     (0001) ;;*****************************************************************************
0246: 43 E1 02 OR    REG[0xE1],0x2      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWM16.asm
                                        (0004) ;;   Version: 2.5, Updated on 2012/9/21 at 11:59:18
                                        (0005) ;;  Generated by PSoC Designer 5.3.2710
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWM16.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWM16_EnableInt
                                        (0030) export _PWM16_EnableInt
                                        (0031) export  PWM16_DisableInt
                                        (0032) export _PWM16_DisableInt
                                        (0033) export  PWM16_Start
                                        (0034) export _PWM16_Start
                                        (0035) export  PWM16_Stop
                                        (0036) export _PWM16_Stop
                                        (0037) export  PWM16_WritePeriod
                                        (0038) export _PWM16_WritePeriod
                                        (0039) export  PWM16_WritePulseWidth
                                        (0040) export _PWM16_WritePulseWidth
                                        (0041) export  PWM16_wReadPulseWidth
                                        (0042) export _PWM16_wReadPulseWidth
                                        (0043) export  PWM16_wReadCounter
                                        (0044) export _PWM16_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wPWM16_ReadPulseWidth    ; deprecated
                                        (0049) export _wPWM16_ReadPulseWidth    ; deprecated
                                        (0050) export  wPWM16_ReadCounter       ; deprecated
                                        (0051) export _wPWM16_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA hp03s_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWM16_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWM16_EnableInt:
                                        (0091) _PWM16_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWM16_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0249: 7F       RET                      (0095)    ret
024A: 41 E1 FD AND   REG[0xE1],0xFD     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWM16_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWM16_DisableInt:
                                        (0119) _PWM16_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWM16_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
024D: 7F       RET                      (0123)    ret
024E: 43 23 01 OR    REG[0x23],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWM16_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWM16_Start:
                                        (0148) _PWM16_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWM16_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
0251: 7F       RET                      (0152)    ret
0252: 41 23 FE AND   REG[0x23],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWM16_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register of the LSB block.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWM16_Stop:
                                        (0176) _PWM16_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWM16_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0255: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWM16_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count registers (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWM16_WritePeriod:
                                        (0206) _PWM16_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0256: 60 21    MOV   REG[0x21],A        (0208)    mov   reg[PWM16_PERIOD_LSB_REG], A
0258: 5B       MOV   A,X                (0209)    mov   A, X
0259: 60 25    MOV   REG[0x25],A        (0210)    mov   reg[PWM16_PERIOD_MSB_REG], A
                                        (0211)    RAM_EPILOGUE RAM_USE_CLASS_1
025B: 7F       RET                      (0212)    ret
                                        (0213) 
                                        (0214) 
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) .SECTION
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  FUNCTION NAME: PWM16_WritePulseWidth
                                        (0220) ;
                                        (0221) ;  DESCRIPTION:
                                        (0222) ;     Writes the pulse width value into the Compare register (DR2).
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0226) ;  RETURNS:      Nothing
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  PWM16_WritePulseWidth:
                                        (0235) _PWM16_WritePulseWidth:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
025C: 60 22    MOV   REG[0x22],A        (0237)    mov   reg[PWM16_COMPARE_LSB_REG], A
025E: 5B       MOV   A,X                (0238)    mov   A, X
025F: 60 26    MOV   REG[0x26],A        (0239)    mov   reg[PWM16_COMPARE_MSB_REG], A
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
0261: 7F       RET                      (0241)    ret
                                        (0242) 
                                        (0243) 
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: PWM16_wReadPulseWidth
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Reads the Compare register.
                                        (0252) ;-----------------------------------------------------------------------------
                                        (0253) ;
                                        (0254) ;  ARGUMENTS:    None
                                        (0255) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0256) ;  SIDE EFFECTS:
                                        (0257) ;    The A and X registers may be modified by this or future implementations
                                        (0258) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0259) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0260) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0261) ;    functions.
                                        (0262) ;
                                        (0263)  PWM16_wReadPulseWidth:
                                        (0264) _PWM16_wReadPulseWidth:
                                        (0265)  wPWM16_ReadPulseWidth:                          ; this name deprecated
                                        (0266) _wPWM16_ReadPulseWidth:                          ; this name deprecated
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
0262: 5D 26    MOV   A,REG[0x26]        (0268)    mov   A, reg[PWM16_COMPARE_MSB_REG]
0264: 5C       MOV   X,A                (0269)    mov   X, A
0265: 5D 22    MOV   A,REG[0x22]        (0270)    mov   A, reg[PWM16_COMPARE_LSB_REG]
                                        (0271)    RAM_EPILOGUE RAM_USE_CLASS_1
0267: 7F       RET                      (0272)    ret
                                        (0273) 
                                        (0274) 
                                        (0275) .ENDSECTION
                                        (0276) 
                                        (0277) .SECTION
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: PWM16_wReadCounter
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0283) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0284) ;     from the Count to the Compare register by holding the clock low in
                                        (0285) ;     the MSB PSoC block.
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0292) ;     2) The A and X registers may be modified by this or future implementations
                                        (0293) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0294) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0295) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0296) ;        functions.
                                        (0297) ;
                                        (0298)  PWM16_wReadCounter:
                                        (0299) _PWM16_wReadCounter:
                                        (0300)  wPWM16_ReadCounter:                             ; this name deprecated
                                        (0301) _wPWM16_ReadCounter:                             ; this name deprecated
                                        (0302) 
                                        (0303)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0304)    bOrigClockSetting:      EQU   2                  ; Frame offset to temp Input   store
                                        (0305)    wCounter:               EQU   3                  ; Frame offset to temp Count   store
                                        (0306)    STACK_FRAME_SIZE:       EQU   5                  ; max stack frame size is 5 bytes
                                        (0307) 
                                        (0308)    RAM_PROLOGUE RAM_USE_CLASS_2
0268: 4F       MOV   X,SP               (0309)    mov   X, SP                                      ; X <-  stack frame pointer
0269: 5D 26    MOV   A,REG[0x26]        (0310)    mov   A, reg[PWM16_COMPARE_MSB_REG]           ; Save the Compare register on the stack
026B: 08       PUSH  A                  (0311)    push  A                                          ;
026C: 5D 22    MOV   A,REG[0x22]        (0312)    mov   A, reg[PWM16_COMPARE_LSB_REG]           ;
026E: 08       PUSH  A                  (0313)    push  A                                          ;  -stack frame now 2 bytes-
026F: 41 23 FE AND   REG[0x23],0xFE     
0272: 71 10    OR    F,0x10             
                                        (0314)    PWM16_Stop_M                                  ; Disable the PWM function
                                        (0315)    M8C_SetBank1                                     ;
0274: 5D 21    MOV   A,REG[0x21]        (0316)    mov   A, reg[PWM16_INPUT_LSB_REG]             ; save the LSB clock input setting
0276: 08       PUSH  A                  (0317)    push  A                                          ;   on the stack (now 3 bytes) and ...
                                        (0318)                                                     ;   hold the clock low:
0277: 62 21 00 MOV   REG[0x21],0x0      (0319)    mov   reg[PWM16_INPUT_LSB_REG], INPUT_REG_NULL
027A: 70 EF    AND   F,0xEF             
                                        (0320)    M8C_SetBank0                                     ; Extract the Count via DR2 register
027C: 5D 24    MOV   A,REG[0x24]        (0321)    mov   A, reg[PWM16_COUNTER_MSB_REG]           ; DR2 <- DR0 (in the MSB block)
027E: 5D 26    MOV   A,REG[0x26]        (0322)    mov   A, reg[PWM16_COMPARE_MSB_REG]           ; Stash the Count MSB on the stack
0280: 08       PUSH  A                  (0323)    push  A                                          ;  -stack frame is now 4 bytes
0281: 5D 20    MOV   A,REG[0x20]        (0324)    mov   A, reg[PWM16_COUNTER_LSB_REG]           ; DR2 <- DR0 (in the LSB block)
0283: 5D 22    MOV   A,REG[0x22]        (0325)    mov   A, reg[PWM16_COMPARE_LSB_REG]           ; Stash the Count LSB on the stack
0285: 08       PUSH  A                  (0326)    push  A                                          ;   -stack frame is now 5 bytes-
0286: 52 00    MOV   A,[X+0]            (0327)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
0288: 60 26    MOV   REG[0x26],A        (0328)    mov   reg[PWM16_COMPARE_MSB_REG], A           ;
028A: 52 01    MOV   A,[X+1]            (0329)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
028C: 60 22    MOV   REG[0x22],A        (0330)    mov   reg[PWM16_COMPARE_LSB_REG], A           ;
028E: 71 10    OR    F,0x10             
                                        (0331)    M8C_SetBank1                                     ; ---Restore the PWM operation
0290: 52 02    MOV   A,[X+2]            (0332)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
0292: 60 21    MOV   REG[0x21],A        (0333)    mov   reg[PWM16_INPUT_LSB_REG], A             ;    and restore it
0294: 70 EF    AND   F,0xEF             
0296: 43 23 01 OR    REG[0x23],0x1      
                                        (0334)    M8C_SetBank0                                     ;
                                        (0335)    PWM16_Start_M                                 ; Now re-enable the PWM function
0299: 18       POP   A                  (0336)    pop   A                                          ; Setup the return value
029A: 20       POP   X                  (0337)    pop   X                                          ;
029B: 38 FD    ADD   SP,0xFD            (0338)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
                                        (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
029D: 7F       RET                      (0340)    ret
                                        (0341) 
                                        (0342) .ENDSECTION
                                        (0343) 
                                        (0344) ; End of File PWM16.asm
FILE: lib\i2chwmmsmstr.asm              (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: I2CHW_Mstr.asm
                                        (0004) ;;  Version: 1.90, Updated on 2012/9/21 at 11:59:4
                                        (0005) ;;  Generated by PSoC Designer 5.3.2710
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: I2CHW MultiMaster User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API
                                        (0013) ;;        function returns. Even though these registers may be preserved now,
                                        (0014) ;;        there is no guarantee they will be preserved in future releases.
                                        (0015) ;;-----------------------------------------------------------------------------
                                        (0016) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0017) ;;*****************************************************************************
                                        (0018) ;;*****************************************************************************
                                        (0019) 
                                        (0020) include "m8c.inc"
                                        (0021) include "memory.inc"
                                        (0022) include "I2CHWCommon.inc"
                                        (0023) include "I2CHWMMS.inc"
                                        (0024) include "I2CHWMstr.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) 
                                        (0030) export   I2CHW_fSendRepeatStart
                                        (0031) export  _I2CHW_fSendRepeatStart
                                        (0032) export   I2CHW_fSendStart
                                        (0033) export  _I2CHW_fSendStart
                                        (0034) export   I2CHW_SendStop
                                        (0035) export  _I2CHW_SendStop
                                        (0036) export   I2CHW_fReadBytesNoStall
                                        (0037) export  _I2CHW_fReadBytesNoStall
                                        (0038) export   I2CHW_fReadBytes
                                        (0039) export  _I2CHW_fReadBytes
                                        (0040) export   I2CHW_bWriteBytesNoStall
                                        (0041) export  _I2CHW_bWriteBytesNoStall
                                        (0042) export   I2CHW_bWriteBytes
                                        (0043) export  _I2CHW_bWriteBytes
                                        (0044) export   I2CHW_bWriteCBytesNoStall
                                        (0045) export  _I2CHW_bWriteCBytesNoStall
                                        (0046) export   I2CHW_bWriteCBytes
                                        (0047) export  _I2CHW_bWriteCBytes
                                        (0048) 
                                        (0049) export   I2CHW_fWrite
                                        (0050) export  _I2CHW_fWrite
                                        (0051) 
                                        (0052) export   I2CHW_bRead
                                        (0053) export  _I2CHW_bRead
                                        (0054) 
                                        (0055) 
                                        (0056) 
                                        (0057) ;-------------------------------------------------------------------
                                        (0058) ;  Declare the varables for both the assembler and C compiler.
                                        (0059) ;-------------------------------------------------------------------
                                        (0060) export  I2CHW_bStatus
                                        (0061) export _I2CHW_bStatus
                                        (0062) 
                                        (0063) export  I2CHW_RsrcStatus
                                        (0064) export _I2CHW_RsrcStatus
                                        (0065) ;export   I2CHW_bData
                                        (0066) ;export  _I2CHW_bData
                                        (0067) 
                                        (0068) ;-----------------------------------------------
                                        (0069) ; Variable Allocation
                                        (0070) ;-----------------------------------------------
                                        (0071) area InterruptRAM(RAM, REL, CON)
                                        (0072) 
                                        (0073) _I2CHW_bStatus:
                                        (0074)  I2CHW_bStatus:                      BLK  1   ; Bus Status during transfers
                                        (0075) 
                                        (0076) _I2CHW_RsrcStatus:
                                        (0077)  I2CHW_RsrcStatus:                   BLK  1   ; Bus Status during transfers
                                        (0078) 
                                        (0079) AREA UserModules (ROM, REL)
                                        (0080) ;-----------------------------------------------
                                        (0081) ;  EQUATES
                                        (0082) ;-----------------------------------------------
                                        (0083) I2CHW_SLAVE_ACKed:                   equ 0x01 ; This bit set if Slave ACKed Master
                                        (0084) I2CHW_SEND_ACK:                      equ 0x10 ; If this flag set, Master should send ACK
                                        (0085) 
                                        (0086) .SECTION
                                        (0087) ;-----------------------------------------------------------------------------
                                        (0088) ;  FUNCTION NAME: I2CHW_bWriteBytesNoStall
                                        (0089) ;
                                        (0090) ;  DESCRIPTION:
                                        (0091) ;    Write multiple data bytes to slave device from RAM. This function allows
                                        (0092) ;    for proper bus arbitration when there is more than one master on the bus
                                        (0093) ;    by first checking to see if the bus is busy.
                                        (0094) ;
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ;  ARGUMENTS:
                                        (0098) ; [SP-7]=> Mode flags that allow the programmer to set flags
                                        (0099) ;          to determine if:
                                        (0100) ;              0x01 => Use RePeatStart instead of Start
                                        (0101) ;              0x02 => Don't send Stop
                                        (0102) ; [SP-6]=> Count of bytes to write.
                                        (0103) ; [SP-5]=> MSB of Array address to put data in (ignored small mem model).
                                        (0104) ; [SP-4]=> LSB of Array address to put data in.
                                        (0105) ; [SP-3]=> Address of slave
                                        (0106) ;
                                        (0107) ;
                                        (0108) ;  RETURNS:  Master Status/Control register or 0xFF if the bus was busy.
                                        (0109) ;
                                        (0110) ;  SIDE EFFECTS:
                                        (0111) ;    The A and X registers may be modified by this or future implementations
                                        (0112) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0113) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0114) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0115) ;    functions.
                                        (0116) ;          
                                        (0117) ;    Currently only the page pointer registers listed below are modified: 
                                        (0118) ;          CUR_PP
                                        (0119) ;
                                        (0120) ;  THEORY of OPERATION or PROCEDURE:
                                        (0121) ;    1. Checks if the Bus is free.
                                        (0122) ;    2. If busy returns 0xFF.
                                        (0123) ;    3. Else continues the transmission via entry into the bWriteBytes API.
                                        (0124) ;
                                        (0125) ;-----------------------------------------------------------------------------
                                        (0126) TxMode:       equ  -7
                                        (0127) TxByteCount:  equ  -6
                                        (0128) TxArrayHI:    equ  -5
                                        (0129) TxArrayLO:    equ  -4
                                        (0130) TxSlaveAddr:  equ  -3
                                        (0131)  I2CHW_bWriteBytesNoStall:
                                        (0132) _I2CHW_bWriteBytesNoStall:
                                        (0133) 
                                        (0134)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0135)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0136)     RAM_SETPAGE_CUR >I2CHW_MasterStatus
                                        (0137) 
029E: 4F       MOV   X,SP               (0138) 	mov   X, SP
                                        (0139) 	;test the I2CM_BUSBUSY bit in the MSCR reg
029F: 49 D9 08 TST   REG[0xD9],0x8      (0140) 	tst reg[I2CHW_MSCR], I2CM_BUSBUSY
02A2: A0 05    JZ    0x02A8             (0141) 	jz I2C_BusFree2
02A4: 50 FF    MOV   A,0xFF             (0142)         mov A, 0xff;   bus busy
02A6: 7F       RET                      (0143) 	ret
                                        (0144)         
                                        (0145) ;-----------------------------------------------------------------------------
                                        (0146) ;  FUNCTION NAME: I2CHW_bWriteBytes
                                        (0147) ;
                                        (0148) ;  DESCRIPTION:
                                        (0149) ;    Write multiple data bytes to slave device from RAM.
                                        (0150) ;
                                        (0151) ;-----------------------------------------------------------------------------
                                        (0152) ;
                                        (0153) ;  ARGUMENTS:
                                        (0154) ; [SP-7]=> Mode flags that allow the programmer to set flags
                                        (0155) ;          to determine if:
                                        (0156) ;              0x01 => Use RePeatStart instead of Start
                                        (0157) ;              0x02 => Don't send Stop
                                        (0158) ; [SP-6]=> Count of bytes to write.
                                        (0159) ; [SP-5]=> MSB of Array address to put data in (ignored small mem model).
                                        (0160) ; [SP-4]=> LSB of Array address to put data in.
                                        (0161) ; [SP-3]=> Address of slave
                                        (0162) ;
                                        (0163) ;
                                        (0164) ;  RETURNS:  Bus Status
                                        (0165) ;
                                        (0166) ;  SIDE EFFECTS:
                                        (0167) ;    The A and X registers may be modified by this or future implementations
                                        (0168) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0169) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0170) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0171) ;    functions.
                                        (0172) ;          
                                        (0173) ;    Currently only the page pointer registers listed below are modified: 
                                        (0174) ;          CUR_PP
                                        (0175) ;
                                        (0176) ;  THEORY of OPERATION or PROCEDURE:
                                        (0177) ;    1. Checks if the Bus is free.  If not, sets the ERROR and BUS_BUSY flags and exits
                                        (0178) ;    2. If the I2CHW_ISR_ACTIVE indicates that the I2CHW_ISR is already 
                                        (0179) ;       running this routine will pend on the ISR_ACTIVE bit until it can run
                                        (0180) ;    3. Initializes the Read buffer in RAM to read data to be sent
                                        (0181) ;    4. Performs a Start or Restart according the Mode specified
                                        (0182) ;    5. The rest is taken care of by the ISR
                                        (0183) ;
                                        (0184) ;-----------------------------------------------------------------------------         
                                        (0185) TxMode:       equ  -7
                                        (0186) TxByteCount:  equ  -6
                                        (0187) TxArrayHI:    equ  -5
                                        (0188) TxArrayLO:    equ  -4
                                        (0189) TxSlaveAddr:  equ  -3
                                        (0190) 
                                        (0191)  I2CHW_bWriteBytes:
                                        (0192) _I2CHW_bWriteBytes:
                                        (0193) 
                                        (0194)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0195)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0196)     RAM_SETPAGE_CUR >I2CHW_MasterStatus
                                        (0197) 
02A7: 4F       MOV   X,SP               (0198) 	mov   X, SP
                                        (0199) 	
                                        (0200) 	; Write code here to test the bus busy flag proceed with the start only if the
                                        (0201) 	; bus is free.  If the bus is busy, set flag in the status register and exit
                                        (0202) 	
                                        (0203) I2C_BusFree2:
                                        (0204)     ;push  A
                                        (0205) I2CMSCR_NotReady2:
                                        (0206)     I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
02A8: 47 01 80 TST   [0x1],0x80         (0207)     tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE
                                        (0208)     ;mov   A, reg[I2CHW_MSCR]                              ;read the mscr register to look for pending master operations
                                        (0209)     ;and   A, 0x0f                                         ;only look at the lower bits
                                        (0210)          
                                        (0211)          
                                        (0212)          
02AB: BF FC    JNZ   0x02A8             (0213)     jnz   I2CMSCR_NotReady2
                                        (0214)     ;pop   A
                                        (0215) 
02AD: 55 01 00 MOV   [0x1],0x0          (0216) 	mov [I2CHW_bStatus],0				                                 ; Clear all Error flags
02B0: 48 F9 01 TST   [X-7],0x1          (0217) 	tst [X+RxMode],I2CHW_RepStart
02B3: B0 01    JNZ   0x02B5             (0218) 	jnz BypassBusBusy2					                                   ; Check transfer is with a Repeat Start condition
                                        (0219) 										                                                 ;  Then no need to check if the bus is busy.
                                        (0220) ;   This doesn't seem to contribute, causes lock ups
                                        (0221) ;   BUS_BUSY is cleared automatically when a stop condition happens &
                                        (0222) ;   the master will not generate a start when the bus it busy anyway.
                                        (0223) ;	tst REG[I2C_MSCR],I2CM_BUSBUSY		                         ; Test if the Bus is busy
                                        (0224) ;	jnz I2C_ReturnBusBusy				                                ; If free proceed
                                        (0225) 
                                        (0226) BypassBusBusy2:
02B5: 2E 01 80 OR    [0x1],0x80         (0227)     or    [I2CHW_bStatus], I2CHW_ISR_ACTIVE       	   ; flag set here and cleared at end of ISR
02B8: 52 FD    MOV   A,[X-3]            (0228)     mov   A, [X + TxSlaveAddr]
02BA: 64       ASL   A                  (0229)     asl   A                                                ; Shift address to the left to make
                                        (0230)                                                            ; a complete byte with the R/W bit.
                                        (0231)                                                            ; The ASL takes care of clearing bit 0.
02BB: 53 03    MOV   [0x3],A            (0232)     mov   [I2CHW_SlaveAddr], A                             ; preserve addr+r/w state for the ISR to use
02BD: 60 D8    MOV   REG[0xD8],A        (0233)     mov   reg[I2CHW_DR], A                                 ; put the write addr into the I2C_DR reg
02BF: 52 F9    MOV   A,[X-7]            (0234)     mov   A, [X+TxMode]                                                             ; place the TxMode in status so ISR can access it
02C1: 2C 01    OR    [0x1],A            (0235)     or   [I2CHW_bStatus],A
                                        (0236)     ;
                                        (0237)     ;we must now initialize a read buffer using I2CHW_InitMasterRamRead
                                        (0238)     ;
02C3: 10       PUSH  X                  (0239)     push   X                                                 ;preserve since it's used later
02C4: 77 FA    INC   [X-6]              (0240)     inc    [X+TxByteCount]                                   ;increase this by one since the init routine will decrement it by 1
                                        (0241)                                                              ;but the ISR understands the original count passed (sigh...)(F.O.E.O.)
02C6: 52 FA    MOV   A,[X-6]            (0242)     mov    A, [X+TxByteCount]                                ;get the write buf size
02C8: 08       PUSH  A                  (0243)     push   A
02C9: 52 FB    MOV   A,[X-5]            (0244)     mov    A, [X+TxArrayHI]                                  ;get the write buf addr
02CB: 08       PUSH  A                  (0245)     push   A                                                                                            ;this will be ignored
02CC: 52 FC    MOV   A,[X-4]            (0246)     mov    A, [X+TxArrayLO]                                  ;get the write buf addr
02CE: 08       PUSH  A                  (0247)     push   A
02CF: 94 6F    CALL  _I2CHW_InitMasterRamRead(0248)     call  I2CHW_InitMasterRamRead                          ;sets the addr and byte count to write to
02D1: 38 FD    ADD   SP,0xFD            (0249)     add SP, -3
02D3: 20       POP   X                  (0250)     pop X                                                    ;restore X to be used for the rest of this routine
                                        (0251)     ;and  [I2CHW_MasterStatus],~I2C_READFLASH              ;shouldn't be needed should have been taken care of in InitMasterRamRead routine
                                        (0252) 
                                        (0253) 
02D4: 51 03    MOV   A,[0x3]            (0254)     mov   A,[I2CHW_SlaveAddr]
02D6: 48 F9 01 TST   [X-7],0x1          (0255)     tst   [x+TxMode],I2CHW_RepStart
02D9: B0 0A    JNZ   0x02E4             (0256)     jnz   DoRestartTx
02DB: 49 D7 01 TST   REG[0xD7],0x1      (0257)     tst   reg[I2CHW_SCR], I2C_BYTE_COMPL                 ; indicates the I2C bus is stalled
02DE: B0 50    JNZ   0x032F             (0258)     jnz   DoRestartRx
02E0: 91 62    CALL  0x0444             (0259)     call  I2CHW_DoStart                                      ; Send a start and address.
02E2: 80 03    JMP   0x02E6             (0260)     jmp   DoTxAck
                                        (0261) DoRestartTx:
02E4: 90 AA    CALL  0x0390             (0262)     call  I2CHW_DoBufferRepeatStart                          ; Send a repeat start and address.
                                        (0263) DoTxAck:
                                        (0264) 
                                        (0265) 
                                        (0266) WriteSlaveAck:
02E6: 51 01    MOV   A,[0x1]            (0267)     mov  a,[I2CHW_bStatus]
                                        (0268)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0269) 	RAM_EPILOGUE RAM_USE_CLASS_4
02E8: 7F       RET                      (0270)     ret
                                        (0271) 
                                        (0272) .ENDSECTION
                                        (0273) 
                                        (0274) .SECTION
                                        (0275) ;-----------------------------------------------------------------------------
                                        (0276) ;  FUNCTION NAME: I2CHW_fReadBytesNoStall
                                        (0277) ;
                                        (0278) ;  DESCRIPTION:
                                        (0279) ;    Reads Multiple bytes from Slave. This function allows
                                        (0280) ;    for proper bus arbitration when there is more than one master on the bus
                                        (0281) ;    by first checking to see if the bus is busy.
                                        (0282) ;-----------------------------------------------------------------------------
                                        (0283) ;
                                        (0284) ;  ARGUMENTS:
                                        (0285) ;  [SP-7]=> Mode flags that allow the programmer to set flags
                                        (0286) ;           to determine if:
                                        (0287) ;             0x01 => Use RepeatStart instead of Start
                                        (0288) ;             0x02 => Don't send Stop
                                        (0289) ;  [SP-6]=> Count of bytes to read.
                                        (0290) ;  [SP-5]=> MSB of Array address to put data in (ignorned for small mem model)
                                        (0291) ;  [SP-4]=> LSB of Array address to put data in 
                                        (0292) ;  [SP-3]=> Address of slave
                                        (0293) ;
                                        (0294) ;  RETURNS:  Master Status/Control register or 0xFF if the bus was busy.
                                        (0295) ;
                                        (0296) ;  SIDE EFFECTS:
                                        (0297) ;    The A and X registers may be modified by this or future implementations
                                        (0298) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0299) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0300) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0301) ;    functions.
                                        (0302) ;          
                                        (0303) ;    Currently only the page pointer registers listed below are modified: 
                                        (0304) ;          CUR_PP
                                        (0305) ;
                                        (0306) ;  THEORY of OPERATION or PROCEDURE:
                                        (0307) ;    1. Checks if the Bus is free.
                                        (0308) ;    2. If busy returns 0xFF.
                                        (0309) ;    3. Else continues the transmission via entry into the fReadBytes API.
                                        (0310) ;
                                        (0311) ;-----------------------------------------------------------------------------
                                        (0312) RxMode:         equ  -7
                                        (0313) RxCnt:          equ  -6
                                        (0314) RxArrayHI:      equ  -5
                                        (0315) RxArrayLO:      equ  -4
                                        (0316) RxSlaveAddr:    equ  -3
                                        (0317)  I2CHW_fReadBytesNoStall:
                                        (0318) _I2CHW_fReadBytesNoStall:
                                        (0319) 
                                        (0320)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0321)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0322)     RAM_SETPAGE_CUR >I2CHW_MasterStatus
                                        (0323) 
02E9: 4F       MOV   X,SP               (0324) 	mov   X, SP
                                        (0325) 	;test the I2CM_BUSBUSY bit in the MSCR reg
02EA: 49 D9 08 TST   REG[0xD9],0x8      (0326) 	tst reg[I2CHW_MSCR], I2CM_BUSBUSY
02ED: A0 05    JZ    0x02F3             (0327) 	jz I2C_BusFree1
02EF: 50 FF    MOV   A,0xFF             (0328)         mov A, 0xff;   bus busy
02F1: 7F       RET                      (0329) 	ret
                                        (0330) ;-----------------------------------------------------------------------------
                                        (0331) ;  FUNCTION NAME: I2CHW_fReadBytes
                                        (0332) ;
                                        (0333) ;  DESCRIPTION:
                                        (0334) ;    Reads Multiple bytes from Slave
                                        (0335) ;-----------------------------------------------------------------------------
                                        (0336) ;
                                        (0337) ;  ARGUMENTS:
                                        (0338) ;  [SP-7]=> Mode flags that allow the programmer to set flags
                                        (0339) ;           to determine if:
                                        (0340) ;             0x01 => Use RepeatStart instead of Start
                                        (0341) ;             0x02 => Don't send Stop
                                        (0342) ;  [SP-6]=> Count of bytes to read.
                                        (0343) ;  [SP-5]=> MSB of Array address to put data in (ignorned for small mem model)
                                        (0344) ;  [SP-4]=> LSB of Array address to put data in 
                                        (0345) ;  [SP-3]=> Address of slave
                                        (0346) ;
                                        (0347) ;  RETURNS:  The Bus Status
                                        (0348) ;
                                        (0349) ;  SIDE EFFECTS:
                                        (0350) ;    The A and X registers may be modified by this or future implementations
                                        (0351) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0352) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0353) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0354) ;    functions.
                                        (0355) ;          
                                        (0356) ;    Currently only the page pointer registers listed below are modified: 
                                        (0357) ;          CUR_PP
                                        (0358) ;
                                        (0359) ;  THEORY of OPERATION or PROCEDURE:
                                        (0360) ;    1. Checks if the Bus is free.  If not, sets the ERROR and BUS_BUSY flags and exits
                                        (0361) ;    2. If the I2CHW_ISR_ACTIVE indicates that the I2CHW_ISR is already 
                                        (0362) ;       running this routine will pend on the ISR_ACTIVE bit until it can run
                                        (0363) ;    3. Initializes the write buffer in RAM for Master to deposit data
                                        (0364) ;    4. Performs a Start or Restart according the Mode specified
                                        (0365) ;    5. The rest is taken care of by the ISR
                                        (0366) ;
                                        (0367) ;----------------------------------------------------------------------------- 
                                        (0368) RxMode:         equ  -7
                                        (0369) RxCnt:          equ  -6
                                        (0370) RxArrayHI:      equ  -5
                                        (0371) RxArrayLO:      equ  -4
                                        (0372) RxSlaveAddr:    equ  -3
                                        (0373) 
                                        (0374)  I2CHW_fReadBytes:
                                        (0375) _I2CHW_fReadBytes:
                                        (0376) 
                                        (0377)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0378)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0379) 	RAM_SETPAGE_CUR >I2CHW_MasterStatus
02F2: 4F       MOV   X,SP               (0380) 	mov   X, SP
                                        (0381) 	
                                        (0382) I2C_BusFree1:	
                                        (0383)     ;push  A
                                        (0384) I2CMSCR_NotReady1:
                                        (0385)     I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
02F3: 47 01 80 TST   [0x1],0x80         (0386) 	tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE
                                        (0387)     ;mov   A, reg[I2CHW_MSCR]                            ;read the mscr register to look for pending master operations
                                        (0388)     ;and   A, 0x0f                                         ;only look at the lower bits
                                        (0389)          
                                        (0390)          
                                        (0391)          
                                        (0392)          
                                        (0393) 	; Here a Timeout condition may be used to get out if the program hangs
02F6: BF FC    JNZ   0x02F3             (0394) 	jnz   I2CMSCR_NotReady1
                                        (0395) 	;pop   A
                                        (0396) 
02F8: 55 01 00 MOV   [0x1],0x0          (0397) 	mov [I2CHW_bStatus],0						; Clear the Error Flags
                                        (0398) 
02FB: 48 F9 01 TST   [X-7],0x1          (0399) 	tst [X+RxMode],I2CHW_RepStart
02FE: B0 01    JNZ   0x0300             (0400) 	jnz BypassBusBusy1							                                 ; Check if transfer is with a Repeat Start condition
                                        (0401) 												                                               ;  Then no need to check if the bus is busy.
                                        (0402) 
                                        (0403) BypassBusBusy1:
0300: 2E 01 80 OR    [0x1],0x80         (0404) 	or    [I2CHW_bStatus], I2CHW_ISR_ACTIVE       		; flag set here and cleared by ISR
0303: 52 FD    MOV   A,[X-3]            (0405)     mov   A, [X + TxSlaveAddr]
0305: 64       ASL   A                  (0406) 	asl   A                                                	  ; Shift address to the left to make
                                        (0407)                                                            	 ; a complete byte with the R/W bit.
0306: 29 01    OR    A,0x1              (0408)     or    A,0x01                                           	 ; OR the address with the Read bit.
0308: 53 03    MOV   [0x3],A            (0409)     mov   [I2CHW_SlaveAddr], A                             ; preserve addr+r/w state for the ISR to use
030A: 60 D8    MOV   REG[0xD8],A        (0410)     mov   reg[I2CHW_DR], A                                 ; put the write addr into the I2C_DR reg
030C: 52 F9    MOV   A,[X-7]            (0411)     mov   A, [X+RxMode]                                      ; place the RxMode in status so ISR can access it
030E: 2C 01    OR    [0x1],A            (0412)     or   [I2CHW_bStatus],A						                           ; Set the Mode bit in Status register
                                        (0413) 
                                        (0414)     ;
                                        (0415)     ;we must now initialize a read buffer using I2CHW_InitMasterWrite
                                        (0416)     ;
0310: 10       PUSH  X                  (0417)     push   X                                               ;preserve since it's used later
0311: 52 FA    MOV   A,[X-6]            (0418)     mov    A, [X+RxCnt]                                    ;get the write buf size
0313: 08       PUSH  A                  (0419)     push   A										    
0314: 52 FB    MOV   A,[X-5]            (0420)     mov    A, [X+RxArrayHI]                                ;get the write addrHI
0316: 08       PUSH  A                  (0421)     push   A										   
0317: 52 FC    MOV   A,[X-4]            (0422)     mov    A, [X+RxArrayLO]							                         ;get the write addrLO
0319: 08       PUSH  A                  (0423)     push   A                                               ;this will be ignored
031A: 93 F1    CALL  _I2CHW_InitMasterWrite(0424)     call  I2CHW_InitMasterWrite                            ;sets the addr and byte count to write to
031C: 38 FD    ADD   SP,0xFD            (0425)     add    SP, -3
031E: 20       POP   X                  (0426)     pop    X                                               ;restore X to be used for the rest of this routine
                                        (0427) 
031F: 51 03    MOV   A,[0x3]            (0428)     mov   A,[I2CHW_SlaveAddr]
0321: 48 F9 01 TST   [X-7],0x1          (0429)     tst   [x+RxMode],I2CHW_RepStart
0324: B0 0A    JNZ   0x032F             (0430)     jnz   DoRestartRx
0326: 49 D7 01 TST   REG[0xD7],0x1      (0431)     tst   reg[I2CHW_SCR], I2C_BYTE_COMPL                   ; indicates the I2C bus is stalled
0329: B0 05    JNZ   0x032F             (0432)     jnz   DoRestartRx
032B: 91 17    CALL  0x0444             (0433)     call  I2CHW_DoStart                                    ; Send a start and address.
032D: 80 03    JMP   0x0331             (0434)     jmp   CheckRxAck
                                        (0435) 
                                        (0436) DoRestartRx:
                                        (0437) 	
032F: 90 5F    CALL  0x0390             (0438)     call  I2CHW_DoBufferRepeatStart                          ; Send a repeat start and address.
                                        (0439) 
                                        (0440)         ; note that REPEATSTART can only be used if this master currently has control of the bus and is at the end
                                        (0441)         ; of or ending the current data transmission/reception.  This also requres that the software (this UM)
                                        (0442)         ; as a whole be able to detect that a stop has not been sent previously in this transmission.
                                        (0443) 
                                        (0444) CheckRxAck:                                                ; Test to see if Slave ACKed
                                        (0445)         ;nothing to do here, a start and address are being transmitted, wait for the ISR to pick up, when it
                                        (0446)         ;is finished.
                                        (0447) End_RD:
0331: 51 01    MOV   A,[0x1]            (0448)     mov  a,[I2CHW_bStatus]
                                        (0449)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0450)     RAM_EPILOGUE RAM_USE_CLASS_4
0333: 7F       RET                      (0451) 	ret
                                        (0452) 
                                        (0453) .ENDSECTION
                                        (0454) 
                                        (0455) .SECTION
                                        (0456) ;-----------------------------------------------------------------------------
                                        (0457) ;  FUNCTION NAME: I2CHW_bWriteCBytesNoStall
                                        (0458) ;
                                        (0459) ;  DESCRIPTION:
                                        (0460) ;    Write multiple data bytes to slave device from ROM. This function allows
                                        (0461) ;    for proper bus arbitration when there is more than one master on the bus
                                        (0462) ;    by first checking to see if the bus is busy.
                                        (0463) ;
                                        (0464) ;-----------------------------------------------------------------------------
                                        (0465) ;
                                        (0466) ;  ARGUMENTS:
                                        (0467) ;  [SP-7]=> Mode flags that allow the programmer to set flags
                                        (0468) ;            to determine if:
                                        (0469) ;               0x01 => Use RepeatStart instead of Start
                                        (0470) ;               0x02 => Don't send Stop
                                        (0471) ;  [SP-6]=> Count of bytes to write.
                                        (0472) ;  [SP-5]=> MSB of ROM Array address to get data from
                                        (0473) ;  [SP-4]=> LSB of ROM Array address to get data from.
                                        (0474) ;  [SP-3]=> Address of slave
                                        (0475) ;
                                        (0476) ;  RETURNS:  Master Status/Control register or 0xFF if the bus was busy.
                                        (0477) ;
                                        (0478) ;  SIDE EFFECTS:
                                        (0479) ;    The A and X registers may be modified by this or future implementations
                                        (0480) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0481) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0482) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0483) ;    functions.
                                        (0484) ;          
                                        (0485) ;    Currently only the page pointer registers listed below are modified: 
                                        (0486) ;          CUR_PP
                                        (0487) ;
                                        (0488) ;  THEORY of OPERATION or PROCEDURE:
                                        (0489) ;    1. Checks if the Bus is free.
                                        (0490) ;    2. If busy returns 0xFF.
                                        (0491) ;    3. Else continues the transmission via entry into the bWriteCBytes API.
                                        (0492) ;
                                        (0493) ;-----------------------------------------------------------------------------
                                        (0494) TxCMode:       equ  -7
                                        (0495) TxCByteCount:  equ  -6
                                        (0496) TxCArrayMSB:   equ  -5
                                        (0497) TxCArrayLSB:   equ  -4
                                        (0498)  I2CHW_bWriteCBytesNoStall:
                                        (0499) _I2CHW_bWriteCBytesNoStall:
                                        (0500) 
                                        (0501)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0502)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0503)     RAM_SETPAGE_CUR >I2CHW_MasterStatus
                                        (0504) 
0334: 4F       MOV   X,SP               (0505) 	mov   X, SP
                                        (0506) 	;test the I2CM_BUSBUSY bit in the MSCR reg
0335: 49 D9 08 TST   REG[0xD9],0x8      (0507) 	tst reg[I2CHW_MSCR], I2CM_BUSBUSY
0338: A0 05    JZ    0x033E             (0508) 	jz I2C_BusFree3
033A: 50 FF    MOV   A,0xFF             (0509)         mov A, 0xff;   bus busy
033C: 7F       RET                      (0510) 	ret
                                        (0511) ;-----------------------------------------------------------------------------
                                        (0512) ;  FUNCTION NAME: I2CHW_bWriteCBytes
                                        (0513) ;
                                        (0514) ;  DESCRIPTION:
                                        (0515) ;    Write multiple data bytes to slave device from ROM
                                        (0516) ;
                                        (0517) ;-----------------------------------------------------------------------------
                                        (0518) ;
                                        (0519) ;  ARGUMENTS:
                                        (0520) ;  [SP-7]=> Mode flags that allow the programmer to set flags
                                        (0521) ;            to determine if:
                                        (0522) ;               0x01 => Use RepeatStart instead of Start
                                        (0523) ;               0x02 => Don't send Stop
                                        (0524) ;  [SP-6]=> Count of bytes to write.
                                        (0525) ;  [SP-5]=> MSB of ROM Array address to get data from
                                        (0526) ;  [SP-4]=> LSB of ROM Array address to get data from.
                                        (0527) ;  [SP-3]=> Address of slave
                                        (0528) ;
                                        (0529) ;  RETURNS:  Bus Status
                                        (0530) ;
                                        (0531) ;  SIDE EFFECTS:
                                        (0532) ;    The A and X registers may be modified by this or future implementations
                                        (0533) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0534) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0535) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0536) ;    functions.
                                        (0537) ;          
                                        (0538) ;    Currently only the page pointer registers listed below are modified: 
                                        (0539) ;          CUR_PP
                                        (0540) ;
                                        (0541) ;  THEORY of OPERATION or PROCEDURE:
                                        (0542) ;    1. Checks if the Bus is free.  If not, sets the ERROR and BUS_BUSY flags and exits
                                        (0543) ;    2. If the I2CHW_ISR_ACTIVE indicates that the I2CHW_ISR is already 
                                        (0544) ;       running this routine will pend on the ISR_ACTIVE bit until it can run
                                        (0545) ;    3. Initializes the Read buffer in ROM to read data to be sent
                                        (0546) ;    4. Performs a Start or Restart according the Mode specified
                                        (0547) ;    5. The rest is taken care of by the ISR
                                        (0548) ;
                                        (0549) ;-----------------------------------------------------------------------------    
                                        (0550) TxCMode:       equ  -7
                                        (0551) TxCByteCount:  equ  -6
                                        (0552) TxCArrayMSB:   equ  -5
                                        (0553) TxCArrayLSB:   equ  -4
                                        (0554) ;TxSlaveAddr:  equ  -3	  ;defined above this line if for reference only
                                        (0555) 
                                        (0556)  I2CHW_bWriteCBytes:
                                        (0557) _I2CHW_bWriteCBytes:
                                        (0558) 
                                        (0559)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0560) 	RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0561) 	RAM_SETPAGE_CUR >I2CHW_MasterStatus
033D: 4F       MOV   X,SP               (0562) 	mov   X, SP
                                        (0563) 
                                        (0564) 	; Write code here to test the bus busy flag proceed with the start only if the
                                        (0565) 	; bus is free.  If the bus is busy, set flag in the status register and exit
                                        (0566) 
                                        (0567) I2C_BusFree3:
                                        (0568)     ;push  A
                                        (0569) I2CMSCR_NotReady3:
                                        (0570)     I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
033E: 47 01 80 TST   [0x1],0x80         (0571)     tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE
                                        (0572)     ;mov   A, reg[I2CHW_MSCR]                              ;read the mscr register to look for pending master operations
                                        (0573)     ;and   A, 0x0f                                         ;only look at the lower bits
                                        (0574)          ;For multi master operations, a pening start or restart
                                        (0575)          ;request might be OK, the master might be waiting to
                                        (0576)          ;acquire the bus from another master
0341: BF FC    JNZ   0x033E             (0577)     jnz   I2CMSCR_NotReady3
                                        (0578)     ;pop   A
0343: 55 01 00 MOV   [0x1],0x0          (0579) 	mov [I2CHW_bStatus],0				                                 ; Clear the Error Flags
0346: 48 F9 01 TST   [X-7],0x1          (0580) 	tst [X+RxMode],I2CHW_RepStart
0349: B0 01    JNZ   0x034B             (0581) 	jnz BypassBusBusy3					; Check transfer is with a Repeat Start condition
                                        (0582) 										;  Then no need to check if the bus is busy.
                                        (0583) 
                                        (0584) BypassBusBusy3:
034B: 2E 01 80 OR    [0x1],0x80         (0585)     or    [I2CHW_bStatus], I2CHW_ISR_ACTIVE                          ;lag set here but cleared in ISRf
034E: 52 FD    MOV   A,[X-3]            (0586)     mov   A, [X + TxSlaveAddr]
0350: 64       ASL   A                  (0587)     asl   A                                                ; Shift address to the left to make
                                        (0588)                                                            ; a complete byte with the R/W bit.
                                        (0589)                                                            ; The ASL takes care of clearing bit 0.
0351: 53 03    MOV   [0x3],A            (0590)     mov   [I2CHW_SlaveAddr], A                             ; preserve addr+r/w state for the ISR to use
0353: 60 D8    MOV   REG[0xD8],A        (0591)     mov   reg[I2CHW_DR], A                                 ; put the write addr into the I2C_DR reg
0355: 52 F9    MOV   A,[X-7]            (0592)     mov   A, [X+RxMode]                                    ; place the RxMode in status so ISR can access it
0357: 2C 01    OR    [0x1],A            (0593)     or   [I2CHW_bStatus],A
                                        (0594)     ;
                                        (0595)     ;we must now initialize a read buffer using I2CHW_InitMasterFlashRead
                                        (0596)     ;
0359: 10       PUSH  X                  (0597)     push   X                                                 ;preserve X since it's used later
035A: 50 00    MOV   A,0x0              (0598)     mov    A, 0                                              ;get the write buf size (this is the hi order part)
035C: 77 FA    INC   [X-6]              (0599)     inc    [X+TxCByteCount]                                  ;increase this by one since the init routine will decrement it by 1
035E: D0 02    JNC   0x0361             (0600)     jnc     . + 3                                            ;but the ISR understands the original count passed (sigh...)(F.O.E.O.)
0360: 74       INC   A                  (0601)     inc    A                                                                                        ;if the low order part of the count happened to roll to 0x00, inc the hi part
0361: 08       PUSH  A                  (0602)     push   A
0362: 52 FA    MOV   A,[X-6]            (0603)     mov    A, [X+TxCByteCount]                               ;initFlasRead needs a 2 byte count this is the low ord byte
0364: 08       PUSH  A                  (0604)     push   A
0365: 52 FB    MOV   A,[X-5]            (0605)     mov    A, [X+TxCArrayMSB]                                ;get the write buf addr
0367: 08       PUSH  A                  (0606)     push   A                                                                                        ;this will be ignored
0368: 52 FC    MOV   A,[X-4]            (0607)     mov    A, [X+TxCArrayLSB]                                ;get the write buf addr
036A: 08       PUSH  A                  (0608)     push   A
036B: 4F       MOV   X,SP               (0609)     mov    X, sp
036C: 79       DEC   X                  (0610)     dec    X
036D: 93 F3    CALL  _I2CHW_InitMasterFlashRead(0611)     call  I2CHW_InitMasterFlashRead                        ;sets the addr and byte count to write to
036F: 38 FC    ADD   SP,0xFC            (0612)     add SP, -4
0371: 20       POP   X                  (0613)     pop X                                                    ;restore X to be used for the rest of this routine
                                        (0614) 
0372: 2E 04 08 OR    [0x4],0x8          (0615)     or  [I2CHW_MasterStatus],I2CHW_READFLASH
0375: 51 03    MOV   A,[0x3]            (0616)     mov   A,[I2CHW_SlaveAddr]
0377: 48 F9 01 TST   [X-7],0x1          (0617)     tst   [x+TxMode],I2CHW_RepStart                        ; Check if a Start or RepeatStart
037A: B0 0A    JNZ   0x0385             (0618)     jnz   DoCRestartTx                                       ; should executed.
037C: 49 D7 01 TST   REG[0xD7],0x1      (0619)     tst   reg[I2CHW_SCR], I2C_BYTE_COMPL                   ; indicates the I2C bus is stalled
037F: BF AF    JNZ   0x032F             (0620)     jnz   DoRestartRx
0381: 90 C1    CALL  0x0444             (0621)     call  I2CHW_DoStart                                    ; Send a start and address.
0383: 80 03    JMP   0x0387             (0622)     jmp   DoCTxAck
                                        (0623) DoCRestartTx:
0385: 90 09    CALL  0x0390             (0624)     call  I2CHW_DoBufferRepeatStart                            ; Send a repeat start and address.
                                        (0625) 
                                        (0626) DoCTxAck:                                                    ; Test to see if Slave is ACKed
                                        (0627) 
                                        (0628) CWriteSlaveAck:
0387: 51 01    MOV   A,[0x1]            (0629)     mov A,[I2CHW_bStatus]						                            ; Return Bus Status
                                        (0630)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0631)     RAM_EPILOGUE RAM_USE_CLASS_4
0389: 7F       RET                      (0632)     ret
                                        (0633) 
                                        (0634) 
                                        (0635) I2C_ReturnBusBusy:
038A: 2E 01 44 OR    [0x1],0x44         (0636)     or   [I2CHW_bStatus],(I2CHW_BUS_BUSY | I2CHW_ERROR)
038D: 51 01    MOV   A,[0x1]            (0637)     mov  a,[I2CHW_bStatus]
                                        (0638)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0639)     RAM_EPILOGUE RAM_USE_CLASS_4
038F: 7F       RET                      (0640)     ret
                                        (0641)     
                                        (0642) .ENDSECTION
                                        (0643) 
                                        (0644) .SECTION
                                        (0645) ;-----------------------------------------------------------------------------
                                        (0646) ;  FUNCTION NAME: I2CHW_DoBufferRepeatStart
                                        (0647) ;
                                        (0648) ;  DESCRIPTION:
                                        (0649) ;    Send repeated start condition and send slave address for buffered transfers.
                                        (0650) ;-----------------------------------------------------------------------------
                                        (0651) ;
                                        (0652) ;  ARGUMENTS:
                                        (0653) ;     This routine is called internally only.  It is not exported or intended as an API
                                        (0654) ;
                                        (0655) ;  RETURNS:
                                        (0656) ;    None
                                        (0657) ;
                                        (0658) ;  SIDE EFFECTS:
                                        (0659) ;    The A and X registers may be modified by this or future implementations
                                        (0660) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0661) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0662) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0663) ;    functions.
                                        (0664) ;          
                                        (0665) ;    Currently only the page pointer registers listed below are modified: 
                                        (0666) ;          CUR_PP
                                        (0667) ;
                                        (0668) ;  THEORY of OPERATION or PROCEDURE:
                                        (0669) ;    1. It checks if the Master is in control of the Bus.  If not, sets the ERROR
                                        (0670) ;       flag and returns
                                        (0671) ;    2. This is similar to the I2C_DoRepeatStart entry point but this function does not
                                        (0672) ;       wait for the byte_complete flag.
                                        (0673) ;
                                        (0674) ;-----------------------------------------------------------------------------
                                        (0675) 
                                        (0676) I2CHW_DoBufferRepeatStart:
                                        (0677)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0678) 	RAM_SETPAGE_CUR >I2CHW_SlaveAddr
                                        (0679)     ;here the path through the routine is dependent on the previous transmission.
                                        (0680)         ; 1. a slave being written too must have acked or nakk'ed the previous byte (generating a Byte complete
                                        (0681)         ; I2C interrupt
                                        (0682)         ; 2a. the master must NAK the byte if he is reading from the slave.
                                        (0683)         ; We do have to look at the status of the I2C block to see what is going on because if there was a
                                        (0684)         ; previous write to a slave it may have ack'ed or nak'ed so we set an address and attempt a repeat start
                                        (0685)         ; by setting the master restart bit and clearing to I2C_SCR (I2C_TX)
                                        (0686)         ; 2b. if we are reading from theslave we would NAK it by clearing the I2C_ACKOUT bit and writing I2C_TX to the
                                        (0687)         ; I2C_SCR reg.  (same as if we were writing to slave).
                                        (0688)         ; 3. once the ISR starts it will figure out which direction we are going with data (sending/receiving)
                                        (0689)         ;
0390: 60 D8    MOV   REG[0xD8],A        (0690)     mov   reg[I2CHW_DR], A
0392: 53 03    MOV   [0x3],A            (0691)     mov   [I2CHW_SlaveAddr], A
                                        (0692)         ;tst      reg[I2CHW_MSCR], I2CM_MASTEROP;               ;do we even have control of the bus?
                                        (0693)         ;jz    notBusMasterErr
0394: 5D D9    MOV   A,REG[0xD9]        (0694)     mov   A, reg[I2CHW_MSCR]                                    ;read the mscr register to look for pending master operations
0396: 21 0F    AND   A,0xF              (0695)     and   A, 0x0f                                               ;only look at the lower bits
0398: A0 16    JZ    0x03AF             (0696)     jz    BusIdleSendStart
                                        (0697)         ; for a single master system this should not be an issue,
                                        (0698)         ; so we'll go ahead and request the restart.  If a stop condition was already generated
                                        (0699)         ; the state machine will automatically generate a start instead.
                                        (0700) 
                                        (0701)     ; for a Multimaster system, we have to test if the Master is in control of the bus.
                                        (0702)     ; If the condition is Bus Busy, but Master is not in control, then
                                        (0703) 
039A: 49 D9 04 TST   REG[0xD9],0x4      (0704) 	tst reg[I2CHW_MSCR],I2CM_MASTEROP								                      ; Test if the Bus is in the control of the Master
039D: A0 58    JZ    0x03F6             (0705) 	jz NotBusMaster1										
039F: 62 D9 02 MOV   REG[0xD9],0x2      
                                        (0706) 
                                        (0707)     ;SetI2CHW_SCR I2CM_RESTRT
                                        (0708)     ;mov   reg[I2CHW_MSCR], I2CM_RESTRT
                                        (0709)     ;SetI2CHW_SCR          I2C_TX                               ;even though the restart has been requested the state
                                        (0710)         ;mov      reg[I2CHW_SCR], I2C_TX                        ;even though the restart has been requested the state
                                        (0711) 
                                        (0712) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (0713)     SetI2CHW_MSCR I2CM_RESTRT
                                        (0714) ;ELSE
                                        (0715) ;    mov  reg[I2CHW_MSCR], I2CM_RESTRT
                                        (0716) ;ENDIF
                                        (0717) 
03A2: 49 D7 04 TST   REG[0xD7],0x4      (0718)     tst   reg[I2CHW_SCR], I2C_TX
03A5: B0 05    JNZ   0x03AB             (0719)     jnz   I2C_RestartRecieve
03A7: 62 D7 04 MOV   REG[0xD7],0x4      
                                        (0720) 
                                        (0721) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (0722)     SetI2CHW_SCR I2C_TX                                         ;even though the restart has been requested the state
                                        (0723) ;ELSE
                                        (0724) ;    mov  reg[I2CHW_SCR], I2C_TX                                ;send Ack
                                        (0725) ;ENDIF
                                        (0726)     RAM_EPILOGUE RAM_USE_CLASS_4
03AA: 7F       RET                      (0727)     ret
03AB: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (0728) 
                                        (0729) I2C_RestartRecieve:
                                        (0730) 
                                        (0731) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (0732)     SetI2CHW_SCR 0                                              ;even though the restart has been requested the state
                                        (0733) ;ELSE
                                        (0734) ;    mov   reg[I2CHW_SCR], 0                                    ;send Ack
                                        (0735) ;ENDIF
                                        (0736)     RAM_EPILOGUE RAM_USE_CLASS_4
03AE: 7F       RET                      (0737)     ret
                                        (0738) 
                                        (0739) ; Since something appears to be messed up do the next best thing to 
                                        (0740) ; a repeat start, send a start.
                                        (0741) BusIdleSendStart:
03AF: 51 03    MOV   A,[0x3]            (0742)     mov    A, [I2CHW_SlaveAddr]
03B1: 90 91    CALL  0x0444             (0743)     call   I2CHW_DoStart
                                        (0744)     RAM_EPILOGUE RAM_USE_CLASS_4
03B3: 7F       RET                      (0745)     ret
                                        (0746) 
                                        (0747) .ENDSECTION
                                        (0748) 
                                        (0749) .SECTION
                                        (0750) 
                                        (0751) ;-----------------------------------------------------------------------------
                                        (0752) ;  FUNCTION NAME: I2CHW_fSendRepeatStart
                                        (0753) ;
                                        (0754) ;  DESCRIPTION:
                                        (0755) ;    Send repeated start condition and send slave address.
                                        (0756) ;
                                        (0757) ;-----------------------------------------------------------------------------
                                        (0758) ;
                                        (0759) ;  ARGUMENTS:
                                        (0760) ;    A has the Slave Address
                                        (0761) ;    X has the data direction. 0-Write, 1-Read
                                        (0762) ;
                                        (0763) ;  RETURNS: Bus Status
                                        (0764) ;    Reg A contains non-0 if there was an error
                                        (0765) ;    reg A contains 0 for success 
                                        (0766) ;	 I2CHW_bStatus contains the contains error information
                                        (0767) ;
                                        (0768) ;  SIDE EFFECTS:
                                        (0769) ;    The A and X registers may be modified by this or future implementations
                                        (0770) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0771) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0772) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0773) ;    functions.
                                        (0774) ;          
                                        (0775) ;    Currently only the page pointer registers listed below are modified: 
                                        (0776) ;          CUR_PP
                                        (0777) ;
                                        (0778) ;  THEORY of OPERATION or PROCEDURE:
                                        (0779) ;    1. If the ISR is active, waits till the action is complete
                                        (0780) ;    2. Checks if the Mater has control on the bus.  If not sets the ERROR
                                        (0781) ;       bit in the bStatus register and returns.
                                        (0782) ;    3. Sends the Repeat Start
                                        (0783) ;    4. Waits for the Byte Complete bit to be set.  
                                        (0784) ;    5. Checks if Slave has acknowledged.  If not, sets the SLAVE_NAK
                                        (0785) ;       and ERROR bits and returns.
                                        (0786) ;    
                                        (0787) ;   WARNING: This routine will disable the interrupt
                                        (0788) ;-----------------------------------------------------------------------------
                                        (0789)  I2CHW_fSendRepeatStart:
                                        (0790) _I2CHW_fSendRepeatStart:
                                        (0791)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0792) 	RAM_SETPAGE_CUR >I2CHW_bStatus
                                        (0793)     
03B4: 08       PUSH  A                  (0794)     push  A
03B5: 2E 01 01 OR    [0x1],0x1          (0795)     or   [I2CHW_bStatus], I2CHW_RepStart
                                        (0796) I2CMSCR_NotReady4:
                                        (0797)     I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
03B8: 47 01 80 TST   [0x1],0x80         (0798)     tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE                    ; Test if ISR is active on another operation
03BB: BF FC    JNZ   0x03B8             (0799)     jnz   I2CMSCR_NotReady4                                     ; Wait if the ISR is already busy...
03BD: 49 D7 01 TST   REG[0xD7],0x1      (0800)     tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                  
03C0: AF F7    JZ    0x03B8             (0801)     jz   I2CMSCR_NotReady4                                      ; Wait if the ISR is already busy...
03C2: 18       POP   A                  (0802)     pop   A
03C3: 41 DE FE AND   REG[0xDE],0xFE     
                                        (0803) 
                                        (0804)     M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
03C6: 55 01 04 MOV   [0x1],0x4          (0805)     mov   [I2CHW_bStatus], I2CHW_BUS_BUSY
03C9: 49 D9 04 TST   REG[0xD9],0x4      (0806)     tst   reg[I2CHW_MSCR],I2CM_MASTEROP                         ; Test if the Master has control on the bus
03CC: A0 26    JZ    0x03F3             (0807)     jz    Err_Exit_RepStart                                     ; If not Bus Master return
                                        (0808)     
03CE: 64       ASL   A                  (0809)     asl   a                                                     ; Shift address to the left
03CF: 79       DEC   X                  (0810)     dec   x                                                     ; If zero, C flag will be set
03D0: C0 03    JC    0x03D4             (0811)     jc    I2C_DoRepeatStart                                     ; Do a write if zero
03D2: 29 01    OR    A,0x1              (0812)     or    a,0x01                                                ; Set Read flag
                                        (0813) 
                                        (0814) I2C_DoRepeatStart:
                                        (0815)     ;here the path through the routine is dependent on the previous transmission.
                                        (0816)         ; 1. a slave being written too must have acked or nakk'ed the previous byte (generating a Byte complete
                                        (0817)         ; I2C interrupt
                                        (0818)         ; 2. the master must NAK the byte if he is reading from the slave.
                                        (0819)         ; We don't have to look at the status of the I2C block to see what is going on because if there was a
                                        (0820)         ; previous write to a slave it may have ack'ed or nak'ed so we set an address and attempt a repeat start
                                        (0821)         ; by setting the master restart bit and writing to I2C_SCR (I2C_TX)
                                        (0822)         ; if we are reading from theslave we would NAK it by clearing the I2C_ACKOUT bit and writing I2C_TX to the
                                        (0823)         ; I2C_SCR reg.  (same as if we were writing to slave).
                                        (0824)         ;
03D4: 60 D8    MOV   REG[0xD8],A        (0825)     mov   reg[I2CHW_DR], A
03D6: 53 03    MOV   [0x3],A            (0826)     mov   [I2CHW_SlaveAddr], A
03D8: 62 D9 02 MOV   REG[0xD9],0x2      
03DB: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (0827) 
                                        (0828) ; machine is stalling the SCL and has to be 'released'
                                        (0829) ; Set the RESTRT bit in I2C_MSCR
                                        (0830) ; Clear I2C_SCR to generate a restart condition
                                        (0831) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (0832)     SetI2CHW_MSCR I2CM_RESTRT						
                                        (0833)     SetI2CHW_SCR 0                                
                                        (0834) ;ELSE
                                        (0835) ;    mov   reg[I2CHW_MSCR], I2CM_RESTRT
                                        (0836) ;    mov   reg[I2CHW_SCR], 0                                   
                                        (0837) ;ENDIF
                                        (0838) 
                                        (0839) ; Wait till the Restart is complete
                                        (0840) WaitRepStrtCompl:
03DE: 5D D7    MOV   A,REG[0xD7]        (0841)     mov   A,  reg[I2CHW_SCR]
                                        (0842) ;;    I2CHW_POLL_SERVICE						                             ;Not appropriate for low level functions
03E0: 49 D7 01 TST   REG[0xD7],0x1      (0843)     tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                  
03E3: AF FA    JZ    0x03DE             (0844)     jz    WaitRepStrtCompl
03E5: 55 01 20 MOV   [0x1],0x20         (0845)     mov   [I2CHW_bStatus], I2CHW_SLAVE_NAK
03E8: 49 D7 02 TST   REG[0xD7],0x2      (0846)     tst	  reg[I2CHW_SCR], I2C_LST_BIT		                    ; Test to see if Slave ACKed
03EB: B0 07    JNZ   0x03F3             (0847)     jnz   Err_Exit_RepStart                                ; If Slave did not ACK return with SLAVE_NAK Error
                                        (0848) ;    or   [I2CHW_bStatus], I2CHW_RepStart
03ED: 55 01 00 MOV   [0x1],0x0          (0849)     mov   [I2CHW_bStatus], 0
03F0: 51 01    MOV   A,[0x1]            (0850)     mov   A, [I2CHW_bStatus]
                                        (0851)     RAM_EPILOGUE RAM_USE_CLASS_4
03F2: 7F       RET                      (0852)     ret
                                        (0853) 
                                        (0854) Err_Exit_RepStart:
                                        (0855)     
                                        (0856)     ;mov   [I2CHW_bStatus], 0xff	                          ;I2CHW_bStatus should already contain an error condition
03F3: 50 01    MOV   A,0x1              (0857)     mov   A, 01
                                        (0858)     RAM_EPILOGUE RAM_USE_CLASS_4
03F5: 7F       RET                      (0859)     ret
                                        (0860) 
                                        (0861) NotBusMaster1:
                                        (0862)     ; Some sort of improper operation is being attempted.  The Master has to be in cotrol
                                        (0863)     ; to generate a Repeat Start condition.  Set ERROR Flag and return
03F6: 2E 01 40 OR    [0x1],0x40         (0864) 	or [I2CHW_bStatus],I2CHW_ERROR
03F9: 26 01 7F AND   [0x1],0x7F         (0865) 	and [I2CHW_bStatus],~I2CHW_ISR_ACTIVE
03FC: 51 01    MOV   A,[0x1]            (0866)     mov   A,[I2CHW_bStatus] 
                                        (0867)     RAM_EPILOGUE RAM_USE_CLASS_4
03FE: 7F       RET                      (0868)     ret
                                        (0869) 
                                        (0870) .ENDSECTION
                                        (0871) 
                                        (0872) .SECTION
                                        (0873) ;-----------------------------------------------------------------------------
                                        (0874) ;  FUNCTION NAME: I2CHW_fSendStart
                                        (0875) ;
                                        (0876) ;  DESCRIPTION:
                                        (0877) ;    Generates start condition and sends slave address.
                                        (0878) ;
                                        (0879) ;-----------------------------------------------------------------------------
                                        (0880) ;
                                        (0881) ;  ARGUMENTS:
                                        (0882) ;    A => Contains the slave address.
                                        (0883) ;	 X => Conntains the value of the R/W bit. 0 for Write, and Non zero for Read
                                        (0884) ;
                                        (0885) ;  RETURNS:
                                        (0886) ;    Reg A contains non-0 if there was an error
                                        (0887) ;    reg A contains 0 for success 
                                        (0888) ;	 I2CHW_bStatus contains the contains error information
                                        (0889) ;
                                        (0890) ;  SIDE EFFECTS:
                                        (0891) ;    The A and X registers may be modified by this or future implementations
                                        (0892) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0893) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0894) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0895) ;    functions.
                                        (0896) ;          
                                        (0897) ;    Currently only the page pointer registers listed below are modified: 
                                        (0898) ;          CUR_PP
                                        (0899) ;
                                        (0900) ;  THEORY of OPERATION or PROCEDURE:
                                        (0901) ;   1. If the I2CHW_ISR_ACTIVE flag is set, it waits till this is cleared
                                        (0902) ;   2. Disables Interrupt
                                        (0903) ;   3. Checks if any BYTE_COMPLETE interrupt is pending.  If yes, sets ERROR flag and
                                        (0904) ;      returns
                                        (0905) ;   4. Checks if Bus is Busy.  If yes, sets the ERROR and BUS_BUSY flags and exits
                                        (0906) ;
                                        (0907) ;  WARNING: this routine will disable the I2C interrupt.  It will wait until the I2C_BYTE_COMPLETE
                                        (0908) ;   flag is set to return.
                                        (0909) ;
                                        (0910) ;-----------------------------------------------------------------------------
                                        (0911)  I2CHW_fSendStart:
                                        (0912) _I2CHW_fSendStart:
                                        (0913)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0914) 	RAM_SETPAGE_CUR >I2CHW_bStatus 
                                        (0915)     ;wait if the bus is already busy...
                                        (0916)     ;push  A
03FF: 55 01 00 MOV   [0x1],0x0          (0917)     mov   [I2CHW_bStatus], 0x00
                                        (0918) I2CMSCR_NotReady5:
                                        (0919)     I2CHW_POLL_SERVICE						                               ;Call Poll service function while waiting
0402: 47 01 80 TST   [0x1],0x80         (0920)     tst    [I2CHW_bStatus], I2CHW_ISR_ACTIVE
0405: BF FC    JNZ   0x0402             (0921)     jnz   I2CMSCR_NotReady5
                                        (0922) 	
                                        (0923)     ;mov   A, reg[I2CHW_MSCR]                              ;read the mscr register to look for pending master operations
                                        (0924)     ;and   A, 0x0f                                         ;only look at the lower bits
                                        (0925)           ;For multi master operations, a pening start or restart
                                        (0926)           ;request might be OK, the master might be waiting to
                                        (0927)           ;acquire the bus from another master
                                        (0928)     ;pop   A
                                        (0929) 
                                        (0930)     ; disable the interrupt
                                        (0931)         ; *** NOT REENABLED ***
                                        (0932)         ;
0407: 55 01 40 MOV   [0x1],0x40         (0933)     mov    [I2CHW_bStatus], I2CHW_ERROR
040A: 41 DE FE AND   REG[0xDE],0xFE     
                                        (0934)     M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
040D: 49 D7 01 TST   REG[0xD7],0x1      (0935)     tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                    ; If there is a pending BYTE_COMPL here
                                        (0936)                                                            ; it is highly probable that a start is not the
                                        (0937)                                                            ; right thing to do
0410: B0 2D    JNZ   0x043E             (0938)     jnz   Err_Exit_Start
                                        (0939) 
0412: 55 01 04 MOV   [0x1],0x4          (0940)     mov    [I2CHW_bStatus], I2CHW_BUS_BUSY
0415: 49 D9 08 TST   REG[0xD9],0x8      (0941) 	tst   REG[I2CHW_MSCR],I2CM_BUSBUSY                        ; Test if the Bus is busy
0418: A0 03    JZ    0x041C             (0942) 	jz    I2C_BusFree4                                        ; If free proceed
041A: 80 23    JMP   0x043E             (0943) 	jmp   Err_Exit_Start                                      ; If busy return with Bus Busy Error
                                        (0944) 
                                        (0945) I2C_BusFree4:	
041C: 64       ASL   A                  (0946)     asl   a                                                ; Shift address to the left
041D: 79       DEC   X                  (0947)     dec   x                                                ; If zero, C flag will be set
041E: C0 03    JC    0x0422             (0948)     jc    I2C_SndWRStart                                   ; Do a write if zero
0420: 29 01    OR    A,0x1              (0949)     or    a,0x01                                           ; Set Read flag
                                        (0950) I2C_SndWRStart:
                                        (0951) 
0422: 60 D8    MOV   REG[0xD8],A        (0952)     mov   reg[I2CHW_DR], A
0424: 53 03    MOV   [0x3],A            (0953)     mov   [I2CHW_SlaveAddr], A
0426: 62 D9 01 MOV   REG[0xD9],0x1      
                                        (0954) 
                                        (0955) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (0956)     SetI2CHW_MSCR I2CM_SNDSTRT
                                        (0957) ;ELSE
                                        (0958) ;    mov   reg[I2CHW_MSCR], I2CM_SNDSTRT
                                        (0959) ;ENDIF
                                        (0960) 
                                        (0961) WaitStrtByteCompl:
0429: 5D D7    MOV   A,REG[0xD7]        (0962)     mov   A,  reg[I2CHW_SCR]
042B: 49 D7 01 TST   REG[0xD7],0x1      (0963)     tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                         ; Test to see if Slave ACKed
042E: AF FA    JZ    0x0429             (0964)     jz    WaitStrtByteCompl
0430: 49 D7 02 TST   REG[0xD7],0x2      (0965)     tst   reg[I2CHW_SCR], I2C_LST_BIT
0433: B0 07    JNZ   0x043B             (0966)     jnz   Err_Exit_SlaveNak
0435: 55 01 00 MOV   [0x1],0x0          (0967)     mov    [I2CHW_bStatus], 0
0438: 51 01    MOV   A,[0x1]            (0968)     mov   A,[I2CHW_bStatus]
                                        (0969)     ;mov  A, 0 ;effective result of previous two operations
                                        (0970)     RAM_EPILOGUE RAM_USE_CLASS_4
043A: 7F       RET                      (0971)     ret
                                        (0972) 
                                        (0973) Err_Exit_SlaveNak:
043B: 2E 01 20 OR    [0x1],0x20         (0974) 	or    [I2CHW_bStatus],I2CHW_SLAVE_NAK
                                        (0975) 
                                        (0976) Err_Exit_Start:
043E: 2E 01 40 OR    [0x1],0x40         (0977) 	or    [I2CHW_bStatus],I2CHW_ERROR
0441: 51 01    MOV   A,[0x1]            (0978)     mov   A, [I2CHW_bStatus]
                                        (0979)     RAM_EPILOGUE RAM_USE_CLASS_4
0443: 7F       RET                      (0980)     ret
                                        (0981) 
                                        (0982) 
                                        (0983) ;-----------------------------------------------------------------------------
                                        (0984) ;  FUNCTION NAME: I2CHW_DoStart
                                        (0985) ;
                                        (0986) ;  DESCRIPTION:
                                        (0987) ;    Generates start condition and sends slave address.
                                        (0988) ;-----------------------------------------------------------------------------
                                        (0989) ;
                                        (0990) ;  ARGUMENTS:
                                        (0991) ;    A => Contains the slave address with the R/W bit.
                                        (0992) ;
                                        (0993) ;  RETURNS:
                                        (0994) ;    I2CHW_bSTatus - SLAVE_NAK bit indicates if the Slave responded.
                                        (0995) ;	                   If this bit is set, the Slave did not Acknowledge
                                        (0996) ;
                                        (0997) ;  SIDE EFFECTS:
                                        (0998) ;    The A and X registers may be modified by this or future implementations
                                        (0999) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1000) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1001) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1002) ;    functions.
                                        (1003) ;          
                                        (1004) ;    Currently only the page pointer registers listed below are modified: 
                                        (1005) ;          CUR_PP
                                        (1006) ;
                                        (1007) ;  THEORY of OPERATION or PROCEDURE:
                                        (1008) ;   Writes the Address in Accumulator to the I2C_DR register and sets the
                                        (1009) ;	  SendStart bit in the I2C_MSCR.
                                        (1010) ;
                                        (1011) ;-----------------------------------------------------------------------------
                                        (1012) 
                                        (1013) I2CHW_DoStart:
                                        (1014)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1015)     RAM_SETPAGE_CUR >I2CHW_SlaveAddr
                                        (1016) ; Here we are not required to test for master operation since we are only attempting 
                                        (1017) ; to gain control of the bus by attempting to assert a Start.  It is the calling routine's
                                        (1018) ; responsibility to ensure that the bus is free.
                                        (1019) 
0444: 60 D8    MOV   REG[0xD8],A        (1020)     mov   reg[I2CHW_DR], A
0446: 53 03    MOV   [0x3],A            (1021)     mov   [I2CHW_SlaveAddr], A
0448: 62 D9 01 MOV   REG[0xD9],0x1      
                                        (1022) 
                                        (1023) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (1024)     SetI2CHW_MSCR I2CM_SNDSTRT
                                        (1025) ;ELSE
                                        (1026) ;    mov   reg[I2CHW_MSCR], I2CM_SNDSTRT
                                        (1027) ;ENDIF
                                        (1028) 
                                        (1029) ;WaitStrtByteCompl1:
                                        (1030) ;    mov   A,  reg[I2CHW_SCR]
                                        (1031) ;	tst	  [I2CHW_bStatus],I2CHW_SLAVE_NAK
                                        (1032) ;	jnz   Error1
                                        (1033) ;   tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                         ; Test to see if Slave ACKed
                                        (1034) ;    jz    WaitStrtByteCompl1
                                        (1035) ;Error1:
                                        (1036)     RAM_EPILOGUE RAM_USE_CLASS_4
044B: 7F       RET                      (1037)     ret
                                        (1038) ;
                                        (1039) ;   DO NOT PLACE
                                        (1040) ;   .SECTION
                                        (1041) ;   .ENDSECTION
                                        (1042) ;   _fSendStart USES CODE BELOW
                                        (1043) ;
                                        (1044) ;-----------------------------------------------------------------------------
                                        (1045) ;  FUNCTION NAME: I2CHW_fWrite
                                        (1046) ;
                                        (1047) ;  DESCRIPTION:
                                        (1048) ;    Writes a byte to the I2C master bus.
                                        (1049) ;
                                        (1050) ;-----------------------------------------------------------------------------
                                        (1051) ;
                                        (1052) ;  ARGUMENTS:
                                        (1053) ;    A contains Data to be written to I2C slave.
                                        (1054) ;
                                        (1055) ;  RETURNS:
                                        (1056) ;   I2CHW_bStatus - If Master is not in control of bus, the ERROR flag is set.
                                        (1057) ;	 If the Slave does not ACK then SLAVE_NAK, and ERROR flags are set
                                        (1058) ;
                                        (1059) ;  SIDE EFFECTS:
                                        (1060) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (1061) ;
                                        (1062) ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (1063) ;
                                        (1064) ;  FUNCTION NAME: I2CHW_write
                                        (1065) ;
                                        (1066) ;  DESCRIPTION:
                                        (1067) ;    Writes a byte to the I2C master bus. Also used for sending the address.
                                        (1068) ;
                                        (1069) ;  ARGUMENTS:
                                        (1070) ;    Reg A contains data to be written to the bus (destroyed).
                                        (1071) ;
                                        (1072) ;  PROCEDURE:
                                        (1073) ;    This routine first disables the I2C interrupt.  Then it checks if the Master
                                        (1074) ;    is in control of the bus.  If not, sets the ERROR flag in bStatus and returns.
                                        (1075) ;	 Then it writes the data to the Data register and enables the I2C_TX bit to
                                        (1076) ;	 transmit the data.  It waits till the Byte Tx is complete.  It checks for the
                                        (1077) ;	 Slave ACK or NAK condition.  If slave ACKed then it returns.  If slave NAKed,
                                        (1078) ;	 then it sets the ERROR and SLAVE_NAK flags of bStatus and returns.	
                                        (1079) ;
                                        (1080) ;  RETURNS:
                                        (1081) ;   I2CHW_bStatus - If Master is not in control of bus, the ERROR flag is set.
                                        (1082) ;	 If the Slave does not ACK then SLAVE_NAK, and ERROR flags are set
                                        (1083) ;    returns A=01 (non zero= TRUE) for success, A= 0 (false = 0) for failure
                                        (1084) ;    I2CHW_bStatus contains error flags
                                        (1085) ;
                                        (1086) ;  SIDE EFFECTS:
                                        (1087) ;    The A and X registers may be modified by this or future implementations
                                        (1088) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1089) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1090) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1091) ;    functions.
                                        (1092) ;          
                                        (1093) ;    Currently only the page pointer registers listed below are modified: 
                                        (1094) ;          CUR_PP
                                        (1095) ;
                                        (1096) ;   WARNING: This routine will explicitly disable the I2C interrupt.  
                                        (1097) ;
                                        (1098) ;-----------------------------------------------------------------------------
                                        (1099) I2CHW_fWrite:
                                        (1100) _I2CHW_fWrite:
                                        (1101)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1102) 	RAM_SETPAGE_CUR >I2CHW_bStatus
                                        (1103)     ; disable the interrupt
                                        (1104)         ; *** NOT REENABLED ***
                                        (1105)         ;
                                        (1106) 
044C: 60 D8    MOV   REG[0xD8],A        (1107)     mov   reg[I2CHW_DR],A                                       ; Put data in Data Reg
044E: 41 DE FE AND   REG[0xDE],0xFE     
                                        (1108)     M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
0451: 5D D9    MOV   A,REG[0xD9]        (1109)     mov   A,  reg[I2CHW_MSCR]                                   ; MSCR into A incase there is an error here
0453: 2E 01 04 OR    [0x1],0x4          (1110)     or    [I2CHW_bStatus], I2CHW_BUS_BUSY
0456: 49 D9 04 TST   REG[0xD9],0x4      (1111)     tst   reg[I2CHW_MSCR],I2CM_MASTEROP                         ; Do we have control of the bus?
0459: A0 24    JZ    0x047E             (1112) 	jz    Err_Exit_fWrite								                                  ; If Master not in control of the bus, set ERROR flag
                                        (1113) 														                                                  ;   and exit
                                        (1114) 
                                        (1115) I2CHW_write:
                                        (1116) _I2CHW_write:
045B: 55 01 00 MOV   [0x1],0x0          (1117)     mov   [I2CHW_bStatus],0x00                                  ; Clear ACK flag
045E: 62 D7 04 MOV   REG[0xD7],0x4      
                                        (1118) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (1119)     SetI2CHW_SCR I2C_TX                                         ; Transmit Data in Data Reg
                                        (1120) ;ELSE
                                        (1121) ;    mov   reg[I2CHW_SCR], I2C_TX                               ; Transmit Data in Data Reg
                                        (1122) ;ENDIF
                                        (1123) 
                                        (1124) 
                                        (1125) WaitTXByteCompl:
0461: 5D D7    MOV   A,REG[0xD7]        (1126)     mov   A, reg[I2CHW_SCR]
0463: 55 01 40 MOV   [0x1],0x40         (1127)     mov    [I2CHW_bStatus], I2CHW_ERROR
0466: 49 D7 20 TST   REG[0xD7],0x20     (1128)     tst   reg[I2CHW_SCR],I2C_STOP_ST					                       ; Not precisely sure what happened but transaction is done
0469: B0 14    JNZ   0x047E             (1129)     jnz   Err_Exit_fWrite                  
046B: 49 D7 01 TST   REG[0xD7],0x1      (1130)     tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                  
046E: AF F2    JZ    0x0461             (1131)     jz    WaitTXByteCompl									                              ; Wait till Byte Completes
0470: 55 01 20 MOV   [0x1],0x20         (1132)     mov    [I2CHW_bStatus], I2CHW_SLAVE_NAK
0473: 49 D7 02 TST   REG[0xD7],0x2      (1133)     tst   reg[I2CHW_SCR], I2C_LST_BIT				                       ; Test to see if Slave ACKed
0476: B0 07    JNZ   0x047E             (1134)     jnz   Err_Exit_fWrite							                                ; Report SLAVE_NAK error, if slave did not respond
0478: 55 01 00 MOV   [0x1],0x0          (1135)     mov   [I2CHW_bStatus], 0x0
047B: 50 00    MOV   A,0x0              (1136)     mov   A, 0
                                        (1137)     RAM_EPILOGUE RAM_USE_CLASS_4
047D: 7F       RET                      (1138)     ret
                                        (1139) 
                                        (1140) Err_Exit_fWrite:
047E: 50 01    MOV   A,0x1              (1141)     mov   A, 01
                                        (1142)     RAM_EPILOGUE RAM_USE_CLASS_4
0480: 7F       RET                      (1143)     ret
                                        (1144) 
                                        (1145) 
                                        (1146) .ENDSECTION
                                        (1147) 
                                        (1148) .SECTION
                                        (1149) ;-----------------------------------------------------------------------------
                                        (1150) ;  FUNCTION NAME: I2CHW_get_ack
                                        (1151) ;
                                        (1152) ;  DESCRIPTION:
                                        (1153) ;    Get slave acknowledge response. Used to poll for I2C_BYTE_COMPL and then test Ack (I2C_LST_BIT)
                                        (1154) ;
                                        (1155) ;-----------------------------------------------------------------------------
                                        (1156) ;
                                        (1157) ;  ARGUMENTS:
                                        (1158) ;
                                        (1159) ;  RETURNS:
                                        (1160) ;    Sets the SLAVE_NAK flag in the bStatus register if the Slave did not Acknowledge
                                        (1161) ;
                                        (1162) ;  SIDE EFFECTS:
                                        (1163) ;    The A and X registers may be modified by this or future implementations
                                        (1164) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1165) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1166) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1167) ;    functions.
                                        (1168) ;          
                                        (1169) ;    Currently only the page pointer registers listed below are modified: 
                                        (1170) ;          CUR_PP
                                        (1171) ;
                                        (1172) ;    Do the ack clock and check for Slave ACK
                                        (1173) ;
                                        (1174) ;-----------------------------------------------------------------------------
                                        (1175) I2CHW_get_ack:
                                        (1176) _I2CHW_get_ack:
                                        (1177)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1178) 	RAM_SETPAGE_CUR >I2CHW_bStatus
0481: 26 01 DF AND   [0x1],0xDF         (1179)     and [I2CHW_bStatus], ~I2CHW_SLAVE_NAK
0484: 49 D7 01 TST   REG[0xD7],0x1      (1180)     tst reg[I2CHW_SCR], I2C_BYTE_COMPL
0487: BF F9    JNZ   0x0481             (1181)     jnz I2CHW_get_ack
0489: 49 D7 02 TST   REG[0xD7],0x2      (1182)     tst reg[I2CHW_SCR], I2C_LST_BIT
048C: B0 05    JNZ   0x0492             (1183)     jnz notAcked
048E: 55 01 00 MOV   [0x1],0x0          (1184)     mov [I2CHW_bStatus], 0
0491: 7F       RET                      (1185)     ret
                                        (1186)     
                                        (1187) notAcked:
0492: 2E 01 20 OR    [0x1],0x20         (1188)     or [I2CHW_bStatus], I2CHW_SLAVE_NAK
                                        (1189)     RAM_EPILOGUE RAM_USE_CLASS_4
0495: 7F       RET                      (1190)     ret
0496: 41 DE FE AND   REG[0xDE],0xFE     
                                        (1191) 
                                        (1192) .ENDSECTION
                                        (1193) 
                                        (1194) .SECTION
                                        (1195) 
                                        (1196) ;-----------------------------------------------------------------------------
                                        (1197) ;  FUNCTION NAME: I2CHW_bRead
                                        (1198) ;
                                        (1199) ;  DESCRIPTION:
                                        (1200) ;    Reads 1 data byte from the I2C master bus.
                                        (1201) ;
                                        (1202) ;-----------------------------------------------------------------------------
                                        (1203) ;
                                        (1204) ;  ARGUMENTS:
                                        (1205) ;    Reg A Contains Ack or Nak information. If 0, the received byte is NAKed.
                                        (1206) ;	 If Reg A contains 1, then the received byte is ACKed.	  
                                        (1207) ;
                                        (1208) ;  RETURNS:
                                        (1209) ;    ret A contains returned data
                                        (1210) ;    Reg A contains 0 if there was an error 
                                        (1211) ;	 I2CHW_bStatus contains the contains error information
                                        (1212) ;
                                        (1213) ;  SIDE EFFECTS:
                                        (1214) ;    The A and X registers may be modified by this or future implementations
                                        (1215) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1216) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1217) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1218) ;    functions.
                                        (1219) ;          
                                        (1220) ;    Currently only the page pointer registers listed below are modified: 
                                        (1221) ;          CUR_PP
                                        (1222) ;
                                        (1223) ;    The I2CHW interrupt should be disabled since this routine will poll the
                                        (1224) ;    reg[I2CHW_SCR] to determine when a byte is available
                                        (1225) ;
                                        (1226) ;   WARNING: This routine will disable the I2C interrupt.  It will wait until the I2C_BYTE_COMPLETE
                                        (1227) ;    flag is set to return.
                                        (1228) ;
                                        (1229) ;
                                        (1230) ;-----------------------------------------------------------------------------
                                        (1231) I2CHW_bRead:
                                        (1232) _I2CHW_bRead:
                                        (1233)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1234) 	RAM_SETPAGE_CUR >I2CHW_bStatus
                                        (1235)     ; disable the interrupt
                                        (1236)     ; *** NOT REENABLED ***
                                        (1237)     ;
                                        (1238) 
                                        (1239)     M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK	; Disable I2C Interrupt
0499: 49 D9 04 TST   REG[0xD9],0x4      (1240)     tst   reg[I2CHW_MSCR], I2CM_MASTEROP         	              ; Do we have control of the bus?
049C: 55 01 04 MOV   [0x1],0x4          (1241)     mov    [I2CHW_bStatus], I2CHW_BUS_BUSY
049F: A0 28    JZ    0x04C8             (1242)     jz    Err_Exit_bRead                                        ; Set Error Flag and Return
04A1: 55 01 00 MOV   [0x1],0x0          (1243)     mov   [I2CHW_bStatus],0x00                                  ; Clear Status
                                        (1244) 
                                        (1245) ; Check for the special case of the first read after and address is sent
04A4: 08       PUSH  A                  (1246)     push  A                                                     ;preserve the information about wether to ACK or NAK this byte
04A5: 5D D7    MOV   A,REG[0xD7]        (1247)     mov   A, reg[I2CHW_SCR]
04A7: 49 D7 08 TST   REG[0xD7],0x8      (1248)     tst   reg[I2CHW_SCR], I2C_ADDRIN
04AA: A0 04    JZ    0x04AF             (1249)     jz    WaitRXByteCompl                                       ;addr bit not set then this is a normal read
04AC: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (1250) 
                                        (1251) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (1252)     SetI2CHW_SCR 0                                              ;clear the I2C_ADDR bit (to unstall SCL) & wait for next byte
                                        (1253) ;ELSE
                                        (1254) ;    mov   reg[I2CHW_SCR], 0                                    ;clear the I2C_ADDR bit (to unstall SCL) & wait for next byte
                                        (1255) ;ENDIF
                                        (1256)                                                                 ; through to I2CHW_put_ack.
                                        (1257) 
                                        (1258)     ;must DROP through to send an Ack and another byte,
                                        (1259)     ;to stop reading we NAK the slave
                                        (1260) WaitRXByteCompl:
04AF: 49 D7 01 TST   REG[0xD7],0x1      (1261)     tst   reg[I2CHW_SCR],I2C_BYTE_COMPL                         ; Wait till Byte is read
04B2: AF FC    JZ    0x04AF             (1262)     jz    WaitRXByteCompl
                                        (1263) 
04B4: 18       POP   A                  (1264)     pop   A                                                     ; Recover the saved ACK/NAK flag
04B5: 21 FF    AND   A,0xFF             (1265)     and   A,0xFF                                                ; Is Ack flag set?
04B7: A0 0A    JZ    0x04C2             (1266)     jz    exit_bRead_NOACK                                      ; Don't ACK
                                        (1267) 
                                        (1268)     ;now if the ACK flag was set, Ack the data which will release the bus and start the next byte in
                                        (1269)     ;otherwise do NOTHING to the SCR reg.  This will allow the calling routine to generate a repeat start
                                        (1270)     ;or a stop depending on it's preference.
                                        (1271) 
04B9: 5D D8    MOV   A,REG[0xD8]        (1272)     mov   A, reg[I2CHW_DR]                                      ; Record data received
04BB: 62 D7 10 MOV   REG[0xD7],0x10     
                                        (1273)     ;mov   [I2CHW_bData],A							                               ; Write received data to bData
                                        (1274) 
                                        (1275) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (1276)     SetI2CHW_SCR I2C_ACKOUT                                     ; Send Ack
                                        (1277) ;ELSE
                                        (1278) ;    mov   reg[I2CHW_SCR], I2C_ACKOUT                           ; Send Ack
                                        (1279) ;ENDIF
                                        (1280) 
04BE: 55 01 00 MOV   [0x1],0x0          (1281)     mov   [I2CHW_bStatus],0x00                             ; No error bits set
                                        (1282)     RAM_EPILOGUE RAM_USE_CLASS_4
04C1: 7F       RET                      (1283)     ret
                                        (1284) 
                                        (1285) exit_bRead_NOACK:
04C2: 5D D8    MOV   A,REG[0xD8]        (1286)     mov   A, reg[I2CHW_DR]                                      ; Record data received
                                        (1287)     ;mov   [I2CHW_bData],A							                               ; Write received data to bData
                                        (1288) 	
                                        (1289)     ; send no Ack or Nak, the calling routine will have to decide to NAK or execute a repeat start.
                                        (1290)     ; sending nothing leaves the bus held in wait until a decision is made.
04C4: 55 01 00 MOV   [0x1],0x0          (1291)     mov   [I2CHW_bStatus],0x00                             ; Clear ACK flag
                                        (1292)     RAM_EPILOGUE RAM_USE_CLASS_4
04C7: 7F       RET                      (1293)     ret
                                        (1294) 
                                        (1295) 
                                        (1296) Err_Exit_bRead:
04C8: 50 00    MOV   A,0x0              (1297)     mov   A, 00	                                                 ;Data should be in A but something went wrong
                                        (1298)     RAM_EPILOGUE RAM_USE_CLASS_4
04CA: 7F       RET                      (1299)     ret
                                        (1300) 
                                        (1301) .ENDSECTION
                                        (1302) 
                                        (1303) 
                                        (1304) .SECTION
                                        (1305) ;-----------------------------------------------------------------------------
                                        (1306) ;  FUNCTION NAME: I2CHW_SendStop
                                        (1307) ;
                                        (1308) ;  DESCRIPTION:
                                        (1309) ;    Assert stop condition.
                                        (1310) ;
                                        (1311) ;-----------------------------------------------------------------------------
                                        (1312) ;
                                        (1313) ;  ARGUMENTS: none
                                        (1314) ;
                                        (1315) ;  RETURNS: none
                                        (1316) ;
                                        (1317) ;  SIDE EFFECTS:
                                        (1318) ;    The A and X registers may be modified by this or future implementations
                                        (1319) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1320) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1321) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1322) ;    functions.
                                        (1323) ;          
                                        (1324) ;  THEORY of OPERATION or PROCEDURE:
                                        (1325) ;     Send stop by releasing SDA high while SCL high. 
                                        (1326) ;	  When in Master Read Mode, this is done by clearing the ACK bit to NAK a read 
                                        (1327) ;	     from the slave.
                                        (1328) ;	  In Master Write Mode this is done by clearing I2C_TX bit in the I2C_SCR register
                                        (1329) ;     In either case this is a zero written to I2CHW_SCR register.
                                        (1330) ;
                                        (1331) ;-----------------------------------------------------------------------------
                                        (1332)  I2CHW_SendStop:
                                        (1333) _I2CHW_SendStop:
                                        (1334)     RAM_PROLOGUE RAM_USE_CLASS_1
04CB: 49 D9 04 TST   REG[0xD9],0x4      (1335)     tst   reg[I2CHW_MSCR], I2CM_MASTEROP                        ; Do we have control of the bus?
04CE: A0 04    JZ    0x04D3             (1336)     jz    notBusMaster3							                                  ; If not nothing to do
04D0: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (1337) 
                                        (1338) ; Clear ACK bit in SCR register to release the bus and to generate a Stop
                                        (1339) ;IF I2CHW_THROTTLE_CLK_RATE
                                        (1340)         SetI2CHW_SCR 0                           
                                        (1341) ;ELSE
                                        (1342) ;    mov   reg[I2CHW_SCR], 0                      
                                        (1343) ;ENDIF
                                        (1344) 
                                        (1345) notBusMaster3:
                                        (1346)     RAM_EPILOGUE RAM_USE_CLASS_1
04D3: 7F       RET                      (1347)     ret
                                        (1348) .ENDSECTION
                                        (1349) 
                                        (1350) 
                                        (1351) 
                                        (1352) 
                                        (1353) ; End of File I2CHW.asm
FILE: lib\i2chwmmsint.asm               (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: I2CHWINT.asm
                                        (0004) ;;  Version: 1.90, Updated on 2012/9/21 at 11:59:4
                                        (0005) ;;  Generated by PSoC Designer 5.3.2710
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: I2CHW MultiMaster Interrupt Service Routine.
                                        (0008) ;;
                                        (0009) ;;	File stored in Master directory of user module
                                        (0010) ;;	program flow would likely be to first determine what 'mode' the device is in.  
                                        (0011) ;;  I.e. is Master and Slave mode enabled?  Control of program flow must take 
                                        (0012) ;;  more into account when all more modes are enabled.
                                        (0013) ;;
                                        (0014) ;;
                                        (0015) ;;-----------------------------------------------------------------------------
                                        (0016) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0017) ;;*****************************************************************************
                                        (0018) ;;*****************************************************************************
                                        (0019) 
                                        (0020) include "m8c.inc"
                                        (0021) include "memory.inc"
                                        (0022) include "I2CHWCommon.inc"
                                        (0023) include "I2CHWMstr.inc"
                                        (0024) include "I2CHWMMS.inc"
                                        (0025) include "I2CHWSlave.inc"
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) 
                                        (0030) export     I2CHW_MasterRead_Count
                                        (0031) export    _I2CHW_MasterRead_Count
                                        (0032) export     I2CHW_MasterWrite_Count
                                        (0033) export    _I2CHW_MasterWrite_Count
                                        (0034) export    pI2CHW_MasterRead_BufLO
                                        (0035) export   _pI2CHW_MasterRead_BufLO
                                        (0036) export    pI2CHW_MasterWrite_BufLO
                                        (0037) export   _pI2CHW_MasterWrite_BufLO
                                        (0038) export    I2CHW_MasterStatus
                                        (0039) export   _I2CHW_MasterStatus
                                        (0040) export    I2CHW_SlaveAddr
                                        (0041) export   _I2CHW_SlaveAddr
                                        (0042) 
                                        (0043) 
                                        (0044) area InterruptRAM(RAM, REL, CON)
                                        (0045) ;-----------------------------------------------
                                        (0046) ; Variable Allocation
                                        (0047) ;-----------------------------------------------
                                        (0048) 
                                        (0049)   I2CHW_SlaveAddr:
                                        (0050)  _I2CHW_SlaveAddr:                     BLK    1
                                        (0051)   I2CHW_MasterStatus:
                                        (0052)  _I2CHW_MasterStatus:                  BLK    1
                                        (0053) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0054) export    pI2CHW_MasterWrite_BufHI
                                        (0055) export   _pI2CHW_MasterWrite_BufHI
                                        (0056) 
                                        (0057)  pI2CHW_MasterWrite_BufHI:
                                        (0058) _pI2CHW_MasterWrite_BufHI:                   blk     1
                                        (0059) ENDIF
                                        (0060)  pI2CHW_MasterWrite_BufLO:
                                        (0061) _pI2CHW_MasterWrite_BufLO:             BLK    1
                                        (0062)   I2CHW_MasterWrite_Count:
                                        (0063)  _I2CHW_MasterWrite_Count:             BLK    1
                                        (0064) IF I2CHW_READ_FLASH
                                        (0065) export    pI2CHW_MasterRead_BufHI
                                        (0066) export   _pI2CHW_MasterRead_BufHI
                                        (0067) 
                                        (0068)  pI2CHW_MasterRead_BufHI:
                                        (0069) _pI2CHW_MasterRead_BufHI:                    blk     1
                                        (0070) ELSE
                                        (0071) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0072) export    pI2CHW_MasterRead_BufHI
                                        (0073) export   _pI2CHW_MasterRead_BufHI
                                        (0074) 
                                        (0075)  pI2CHW_MasterRead_BufHI:
                                        (0076) _pI2CHW_MasterRead_BufHI:                    blk     1
                                        (0077) ENDIF
                                        (0078) ENDIF
                                        (0079)  pI2CHW_MasterRead_BufLO:
                                        (0080) _pI2CHW_MasterRead_BufLO:              BLK    1
                                        (0081) IF I2CHW_READ_FLASH
                                        (0082) export    I2CHW_MasterRead_CountHI
                                        (0083) export   _I2CHW_MasterRead_CountHI
                                        (0084) 
                                        (0085)  I2CHW_MasterRead_CountHI:
                                        (0086) _I2CHW_MasterRead_CountHI:                   blk    1
                                        (0087) ENDIF
                                        (0088)  I2CHW_MasterRead_Count:
                                        (0089) _I2CHW_MasterRead_Count:               BLK    1
                                        (0090) 
                                        (0091) 
                                        (0092) 
                                        (0093) IF I2CHW_SLAVE_OPTION
                                        (0094) 
                                        (0095) export    I2CHW_SlaveStatus
                                        (0096) export   _I2CHW_SlaveStatus
                                        (0097) export     I2CHW_SlaveRead_Count
                                        (0098) export    _I2CHW_SlaveRead_Count
                                        (0099) export     I2CHW_SlaveWrite_Count
                                        (0100) export    _I2CHW_SlaveWrite_Count
                                        (0101) export    pI2CHW_SlaveRead_BufLO
                                        (0102) export   _pI2CHW_SlaveRead_BufLO
                                        (0103) export    pI2CHW_SlaveWrite_BufLO
                                        (0104) export   _pI2CHW_SlaveWrite_BufLO
                                        (0105) export    I2CHW_SlaveRead_CountHI
                                        (0106) export   _I2CHW_SlaveRead_CountHI
                                        (0107) 
                                        (0108) 
                                        (0109)   I2CHW_SlaveStatus:
                                        (0110)  _I2CHW_SlaveStatus:                   BLK    1
                                        (0111) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0112) export    pI2CHW_SlaveWrite_BufHI
                                        (0113) export   _pI2CHW_SlaveWrite_BufHI
                                        (0114) 
                                        (0115)  pI2CHW_SlaveWrite_BufHI:
                                        (0116) _pI2CHW_SlaveWrite_BufHI:                    blk     1
                                        (0117) ENDIF
                                        (0118)  pI2CHW_SlaveWrite_BufLO:
                                        (0119) _pI2CHW_SlaveWrite_BufLO:              BLK    1
                                        (0120)   I2CHW_SlaveWrite_Count:
                                        (0121)  _I2CHW_SlaveWrite_Count:              BLK    1
                                        (0122) IF I2CHW_READ_FLASH
                                        (0123) export    pI2CHW_SlaveRead_BufHI
                                        (0124) export   _pI2CHW_SlaveRead_BufHI
                                        (0125) 
                                        (0126)  pI2CHW_SlaveRead_BufHI:
                                        (0127) _pI2CHW_SlaveRead_BufHI:                     blk     1
                                        (0128) ELSE
                                        (0129) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0130) export    pI2CHW_SlaveRead_BufHI
                                        (0131) export   _pI2CHW_SlaveRead_BufHI
                                        (0132) 
                                        (0133)  pI2CHW_SlaveRead_BufHI:
                                        (0134) _pI2CHW_SlaveRead_BufHI:                     blk     1
                                        (0135) ENDIF
                                        (0136) ENDIF
                                        (0137)  pI2CHW_SlaveRead_BufLO:
                                        (0138) _pI2CHW_SlaveRead_BufLO:               BLK    1
                                        (0139)  I2CHW_SlaveRead_CountHI:
                                        (0140) _I2CHW_SlaveRead_CountHI:              BLK    1
                                        (0141)  I2CHW_SlaveRead_Count:
                                        (0142) _I2CHW_SlaveRead_Count:                BLK    1
                                        (0143) 
                                        (0144) ENDIF
                                        (0145) 
                                        (0146) 
                                        (0147) IF I2CHW_POLLED_PROCESS
                                        (0148) 
                                        (0149) I2CHW_Poll_Status:                             blk      1  ;internal variable used for polled operation
                                        (0150) ;bit 0 - Write transaction started begin looking for the STOP state to terminate the transaction
                                        (0151) I2C_WRITE_STARTED:       equ     0x01
                                        (0152) ;bit 1 - Undefined
                                        (0153) ;bit 2 - Undefined
                                        (0154) ;bit 3 - Undefined
                                        (0155) ;bit 4 - Undefined
                                        (0156) ;bit 5 - Undefined
                                        (0157) ;bit 6 - Undefined
                                        (0158) ;bit 7 - Undefined
                                        (0159) 
                                        (0160) ENDIF
                                        (0161) 
                                        (0162) 
                                        (0163) SNIFF_DATA:  equ 0
                                        (0164) DEBUG_STATE: equ 0
                                        (0165) 
                                        (0166) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0167) ;---------------------------------------------------
                                        (0168) ; Insert your custom declarations below this banner
                                        (0169) ;---------------------------------------------------
                                        (0170) 
                                        (0171) ;------------------------
                                        (0172) ; Includes
                                        (0173) ;------------------------
                                        (0174) 
                                        (0175) 	
                                        (0176) ;------------------------
                                        (0177) ;  Constant Definitions
                                        (0178) ;------------------------
                                        (0179) 
                                        (0180) 
                                        (0181) ;------------------------
                                        (0182) ; Variable Allocation
                                        (0183) ;------------------------
                                        (0184) 
                                        (0185) 
                                        (0186) ;---------------------------------------------------
                                        (0187) ; Insert your custom declarations above this banner
                                        (0188) ;---------------------------------------------------
                                        (0189) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0190) 
                                        (0191) 
                                        (0192) 
                                        (0193) AREA UserModules (ROM, REL)
                                        (0194) 
                                        (0195) export _I2CHW_ISR
                                        (0196) export _I2CHW_Poll
                                        (0197) export  I2CHW_Poll
                                        (0198) 
                                        (0199) ;;****************************************************
                                        (0200) ;; I2C_ISR  main entry point from vector 60h
                                        (0201) ;;
                                        (0202) ;;****************************************************
                                        (0203) 
                                        (0204) IF I2CHW_POLLED_PROCESS
                                        (0205) 
                                        (0206) _I2CHW_ISR:
                                        (0207)     reti ; stub out the ISR if this is going to be a polled function
                                        (0208) 
                                        (0209)  
                                        (0210)  
                                        (0211)  I2CHW_Poll:
                                        (0212) _I2CHW_Poll:
                                        (0213) ;    cases are:
                                        (0214) ;    1. Stop state after a Master write to this slave
                                        (0215) ;    2. possible Stop condition COMBINED with a new transaction is not a problem since the Stop will only flag that the 
                                        (0216) ;       previous write has been completed. (so just call the I2CA_Process routine for this case and let the process routine take
                                        (0217) ;       care of it.
                                        (0218)     ;case 1
                                        (0219)     RAM_SETPAGE_CUR	( >I2CHW_Poll_Status )
                                        (0220) 
                                        (0221)     tst [I2CHW_Poll_Status], I2C_WRITE_STARTED
                                        (0222)     jz  NOT_I2C_Write
                                        (0223)     tst reg[ I2CHW_SCR], I2C_STOP_ST
                                        (0224)     ;make sure the pushes and pops 'line up' or die horribly
                                        (0225)     jz  NOT_I2C_Write
                                        (0226)     push A
                                        (0227)     push X
                                        (0228) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0229)     REG_PRESERVE IDX_PP
                                        (0230) ENDIF
                                        (0231)     jmp Slave_STOPTRAP
                                        (0232)     
                                        (0233) NOT_I2C_Write:    
                                        (0234)     tst reg[ I2CHW_SCR], I2C_BYTE_COMPL
                                        (0235)     jnz I2CHW_Process   ;if no other critical events are in evidence, process an I2C byte if it's done
                                        (0236)     ret
                                        (0237) 
                                        (0238)  I2CHW_Process:
                                        (0239) _I2CHW_Process:  ;don't need to export user will call I2CA_POLL which will call the I2CA_Process routine if necessary
                                        (0240) 
                                        (0241) 
                                        (0242) 
                                        (0243) ELSE
                                        (0244) ;; STUB for polling function when it's un-defined
                                        (0245)  I2CHW_Poll:
                                        (0246) _I2CHW_Poll:
04D4: 7F       RET                      (0247)     ret
                                        (0248) 
                                        (0249) 
                                        (0250) ;;*****************************************************************************************
                                        (0251) ;;                 I2C_MASTER  main entry point from vector 60h
                                        (0252) ;;*****************************************************************************************
                                        (0253) 
                                        (0254) _I2CHW_ISR:
                                        (0255) ENDIF
04D5: 08       PUSH  A                  (0256)     push A
04D6: 10       PUSH  X                  (0257)     push X
                                        (0258) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0259)     REG_PRESERVE IDX_PP
                                        (0260) ENDIF
                                        (0261) 
                                        (0262) Process_REENTRY:
                                        (0263) ;******************************************************************************************
                                        (0264) ;If two masters attempt to address one another and do so simultaneously within the window of
                                        (0265) ;the start bit, one may still have it's address bit set indicating that it failed in acquiring
                                        (0266) ;the bus prior to an arbitration loss event.  Since the Data register may be overwritten
                                        (0267) ;the presence of the address request bit can cause an address event with incorrect data
                                        (0268) ;if undetected.  A byte-complete event when the address bit is still set indicates that this
                                        (0269) ;has happened.
                                        (0270) ;          
                                        (0271) ;******************************************************************************************
04D7: 5D D9    MOV   A,REG[0xD9]        (0272)     mov A, reg[I2CHW_MSCR]
04D9: 21 01    AND   A,0x1              (0273)     and A, 0x01                                              ;;Test if Start_Gen/address req is Set
04DB: A0 07    JZ    0x04E3             (0274)     jz  ContinueByteCompl                                    ;;If not jump out
04DD: 41 D9 FE AND   REG[0xD9],0xFE     (0275)     and reg[I2CHW_MSCR], ~0x01                               ;;If address req is set clear it
04E0: 2E 01 48 OR    [0x1],0x48         (0276)     or  [I2CHW_bStatus],(I2CHW_LOST_ARB | I2CHW_ERROR)       ; Set the ERROR and LOST_ARB flags in the bus status register
                                        (0277)     ;or  [I2CHW_bStatus], I2CHW_ERROR // Then flag an error
                                        (0278) 	;; if an address has been received it's possible that it's this devices slave address
                                        (0279) ContinueByteCompl:
                                        (0280) ;******************************************************************************************
                                        (0281) ;Before doing anything else check for the presence of a STOP_ST in combination with the
                                        (0282) ;STOP Interrupt Enable (STOPIE).  If this is what happened set appropriate bits, 
                                        (0283) ;clear and reset the main I2CHW interrupt to assure that we haven't missed a BYTE_COMPLETE
                                        (0284) ;interrupt and exit the interrupt.  If a BYTE_COMPLETE interrupt is concurrent with the STOP 
                                        (0285) ;interrupt the next entry to this interrupt will be immediate and the STOPIE bit will now be 
                                        (0286) ;cleared.  This removes the possibility of trying to process two different events within one 
                                        (0287) ;interrupt.
                                        (0288) ;          
                                        (0289) ;******************************************************************************************
                                        (0290) ;first check to see if the slave function is enabled
                                        (0291) ;so no valid address are detected without the interrupt 
                                        (0292) ;capability to ACK them
                                        (0293)     IF(I2CHW_USED_I2C_BLOCK)
                                        (0294)     M8C_SetBank1
                                        (0295)     tst reg[I2CHW_CFG],I2C_S_EN                                ; is the slave function enabled?
                                        (0296)     M8C_SetBank0
                                        (0297)     ELSE
04E3: 49 D6 01 TST   REG[0xD6],0x1      (0298)     tst reg[I2CHW_CFG],I2C_S_EN                                ; is the slave function enabled?
                                        (0299)     ENDIF
04E6: A0 0B    JZ    0x04F2             (0300)     jz  ByteComplProcess 
                                        (0301) ; Check the Stop Bit in SCR only if the Stop Interrupt is enabled.    
                                        (0302)     IF(I2CHW_USED_I2C_BLOCK)
                                        (0303)     M8C_SetBank1
                                        (0304)     tst reg[I2CHW_CFG],I2C_STOPIE
                                        (0305)     M8C_SetBank0
                                        (0306)     ELSE
04E8: 49 D6 10 TST   REG[0xD6],0x10     (0307)     tst reg[I2CHW_CFG],I2C_STOPIE
                                        (0308)     ENDIF
04EB: A0 06    JZ    0x04F2             (0309)     jz  ByteComplProcess
04ED: 49 D7 20 TST   REG[0xD7],0x20     (0310)     tst reg[I2CHW_SCR],I2C_STOP_ST                         ; Test if the Interrupt is due to Stop Condition
                                        (0311) ;conditions that must be met here are Slave-enabled, STOP int enabled (STOPIE), and STOP_ST (status bit set)
04F0: B2 06    JNZ   0x06F7             (0312)     jnz Slave_STOPTRAP                                       ; If yes process Stop Trap
                                        (0313) 
                                        (0314) ByteComplProcess:
                                        (0315) ;*********END TEST OF STOP STATUS**********************************************************       
                                        (0316) 
04F2: 49 D7 80 TST   REG[0xD7],0x80     (0317)     tst reg[I2CHW_SCR],I2CM_BUSERR                           ; Test if the Interrupt is due to Bus Error
04F5: B0 1C    JNZ   0x0512             (0318)     jnz ReportBusError                                       ; If yes Report Bus Error
                                        (0319) 
                                        (0320)     
04F7: 49 D7 40 TST   REG[0xD7],0x40     (0321)     tst reg[I2CHW_SCR],I2CM_LOSTARB                          ; Test the Lost Arbitration bit
04FA: A0 23    JZ    0x051E             (0322)     jz  NoLostArb                                            ; If not set, proceed
                                        (0323) 
                                        (0324) ;******************************************************************************************
                                        (0325) ;                     Control is here if Master Lost Arbitration
                                        (0326) ;******************************************************************************************
                                        (0327) ; 1. Set the ERROR and LOST_ARB flags in the bStatus register.
                                        (0328) ; 2. Branch to Slave ISR if the Address bit is set in I2C_SCR and Slave mode enabled.
                                        (0329) ; 3. If Slave mode not enabled or Address bit not set, release the bus.
                                        (0330) 
04FC: 2E 01 48 OR    [0x1],0x48         (0331)     or  [I2CHW_bStatus],(I2CHW_LOST_ARB | I2CHW_ERROR)       ; Set the ERROR and LOST_ARB flags in the bus status register
                                        (0332) IF I2CHW_SLAVE_OPTION
                                        (0333) ;first check to see if the slave function is enabled
                                        (0334) ;so no valid address are detected without the interrupt 
                                        (0335) ;capability to ACK them
                                        (0336) IF DEBUG_STATE
                                        (0337)    mov A, 'b'
                                        (0338)    lcall TX8_1_PutChar
                                        (0339)    mov A, '0'
                                        (0340)    lcall TX8_1_PutChar
                                        (0341)    mov A, 0x2c
                                        (0342)    lcall TX8_1_PutChar
                                        (0343)    lcall TX8_1_PutCRLF
                                        (0344) ENDIF
                                        (0345)     IF(I2CHW_USED_I2C_BLOCK)
                                        (0346)     M8C_SetBank1
                                        (0347)     tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
                                        (0348)     M8C_SetBank0
                                        (0349)     ELSE
04FF: 49 D6 01 TST   REG[0xD6],0x1      (0350)     tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
                                        (0351)     ENDIF
0502: A0 06    JZ    0x0509             (0352)     jz  ArbitrationLossBusRelease 
0504: 49 D7 08 TST   REG[0xD7],0x8      (0353)     tst reg[I2CHW_SCR],I2C_ADDRIN                            ; Test if the Received byte is an address
0507: B1 34    JNZ   0x063C             (0354)     jnz I2CHW_ISR_SLAVE                                      ; If yes, the master probably has been addressed as slave
0509: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (0355) ENDIF
                                        (0356) 
                                        (0357) ArbitrationLossBusRelease:
                                        (0358) ;******************************************************************************************
                                        (0359) ;;; EXIT ON ARBITRATION LOSS, RELEASE BUS IGNORE FURTHER ACTIVITY ;;;
                                        (0360) ;******************************************************************************************
                                        (0361) IF DEBUG_STATE
                                        (0362)    mov A, "b"
                                        (0363)    lcall TX8_1_PutChar
                                        (0364)    mov A, "1"
                                        (0365)    lcall TX8_1_PutChar
                                        (0366)    mov A, 0x2c
                                        (0367)    lcall TX8_1_PutChar
                                        (0368)    lcall TX8_1_PutCRLF
                                        (0369) ENDIF
                                        (0370) 
                                        (0371) ;
                                        (0372) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0373) ;
                                        (0374)     SetI2CHW_SCR 0                                           ; Release the Bus by clearing the I2C_SCR register
                                        (0375) 
                                        (0376) ; Enable Stop Trap.  The ISR_ACTIVE bit will be cleared only when a Stop condition is
                                        (0377) ; detected. ie, when the winning master releases the bus
                                        (0378) ; On the other hand why bother?  The bit is therefore decreed to be cleared,
                                        (0379) ; IFF the Slave it NOT enabled. 
                                        (0380) ;    BitSetI2CHW_CFG I2C_STOPIE
050C: 26 01 7F AND   [0x1],0x7F         (0381)     and [I2CHW_bStatus],~I2CHW_ISR_ACTIVE
                                        (0382) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0383)     REG_RESTORE IDX_PP
                                        (0384) ENDIF
050F: 20       POP   X                  (0385)     pop X
0510: 18       POP   A                  (0386)     pop A
0511: 7E       RETI                     
0512: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (0387)     RAM_RESTORE_NATIVE_PAGING		;has no effect if this is an ISR
                                        (0388)     I2CHW_SERVICE_RETURN
                                        (0389) 
                                        (0390) ;******************************************************************************************
                                        (0391) ;                          Interrupt Caused by Bus Error
                                        (0392) ;******************************************************************************************
                                        (0393) ; Set the ERROR and BUS_ERROR flags in the bStatus register
                                        (0394) ReportBusError:
                                        (0395) ;******************************************************************************************
                                        (0396) ;;; EXIT ON BUS ERROR (STATE OF BUS IS UNKNOWN--PROBABLY STALLED), RELEASE BUS IGNORE FURTHER ACTIVITY ;;;
                                        (0397) ;******************************************************************************************
                                        (0398) IF DEBUG_STATE
                                        (0399)    mov A, 'b'
                                        (0400)    lcall TX8_1_PutChar
                                        (0401)    mov A, 'E'
                                        (0402)    lcall TX8_1_PutChar
                                        (0403)    mov A, 0x2c
                                        (0404)    lcall TX8_1_PutChar
                                        (0405) ENDIF
                                        (0406) 
                                        (0407) ;
                                        (0408) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0409) ;
                                        (0410)     SetI2CHW_SCR 0                                           ; Release the Bus by clearing the I2C_SCR register
                                        (0411) 
0515: 2E 01 50 OR    [0x1],0x50         (0412)     or [I2CHW_bStatus],(I2CHW_ERROR | I2CHW_BUS_ERROR)
0518: 26 01 7F AND   [0x1],0x7F         (0413)     and [I2CHW_bStatus],~I2CHW_ISR_ACTIVE
                                        (0414) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0415)     REG_RESTORE IDX_PP
                                        (0416) ENDIF
051B: 20       POP   X                  (0417)     pop X
051C: 18       POP   A                  (0418)     pop A
051D: 7E       RETI                     
                                        (0419)     RAM_RESTORE_NATIVE_PAGING		;has no effect if this is an ISR
                                        (0420)     I2CHW_SERVICE_RETURN
                                        (0421) 
                                        (0422) ;******************************************************************************************
                                        (0423) ;                              No Errors encountered
                                        (0424) ;******************************************************************************************
                                        (0425) NoLostArb:
                                        (0426) 
                                        (0427) IF I2CHW_SLAVE_OPTION
051E: 49 D9 04 TST   REG[0xD9],0x4      (0428) 	tst REG[I2CHW_MSCR],I2CM_MASTEROP                           ; Test if Master is in control
0521: A0 03    JZ    0x0525             (0429) 	jz TstSlaveOperational                                      ; If not branch to SLAVE_ISR
0523: 80 08    JMP   0x052C             (0430) 	jmp ProceedWithMasterOp  
                                        (0431) TstSlaveOperational:
                                        (0432)     
                                        (0433) ;first check to see if the slave function is enabled
                                        (0434) ;so no valid address are detected without the interrupt 
                                        (0435) ;capability to ACK them
                                        (0436)     IF(I2CHW_USED_I2C_BLOCK)
                                        (0437)     M8C_SetBank1
                                        (0438)     tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
                                        (0439)     M8C_SetBank0
                                        (0440)     ELSE
0525: 49 D6 01 TST   REG[0xD6],0x1      (0441)     tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
                                        (0442)     ENDIF
0528: AF E0    JZ    0x0509             (0443)     jz  ArbitrationLossBusRelease 
052A: 81 11    JMP   0x063C             (0444)     jmp I2CHW_ISR_SLAVE                                      ; If not branch to SLAVE_ISR  
                                        (0445) ENDIF
                                        (0446) 
                                        (0447) ProceedWithMasterOp:
                                        (0448) ;******************************************************************************************
                                        (0449) 	;Only use the SLAVE stop trap for Writes to the Slave from and external master.
                                        (0450) 	;The stop interrupt will only cause problems otherwise.
                                        (0451) 	;Do not use stop interrupts for multi-master (master) mode.
                                        (0452) ;******************************************************************************************
                                        (0453) 
052C: 49 D7 08 TST   REG[0xD7],0x8      (0454)     tst reg[I2CHW_SCR], I2C_ADDRIN
052F: A0 15    JZ    0x0545             (0455)     jz DataState
                                        (0456) 
                                        (0457) ; Test if a Start Generation is pending, or the if the Slave ACK'ed or NAKed the address.
                                        (0458) AddrState:
0531: 49 D9 01 TST   REG[0xD9],0x1      (0459)     tst reg[I2CHW_MSCR], I2CM_SNDSTRT
0534: B0 29    JNZ   0x055E             (0460)     jnz NoStart                                              ; A start is pending                            
0536: 49 D7 02 TST   REG[0xD7],0x2      (0461)     tst reg[I2CHW_SCR], ( I2C_LST_BIT )         
0539: B0 18    JNZ   0x0552             (0462)     jnz SlaveAddrNAK                                         ; Slave did not answer 
                                        (0463) 
                                        (0464) ; Slave has acknowledged here.  Now it is to be decided if data has to be transmitted or
                                        (0465) ; received.  This is done by testing the R/W bit of the SlaveAddr.  If this bit is 0, then
                                        (0466) ; it is a write operation.  If 1, then it is a read operation
053B: 47 03 01 TST   [0x3],0x1          (0467)     tst [I2CHW_SlaveAddr], 01                   
053E: B0 29    JNZ   0x0568             (0468)     jnz I2C_ReadSlave1stByte                                 ; Branch to Read byte
0540: 80 87    JMP   0x05C8             (0469)     jmp I2C_WriteSlave1stByte                                ; Branch to Write byte
                                        (0470) ;******************************************************************************************
                                        (0471) ;;; UNREACHABLE EXIT POINT STACK MAY BE CORRUPTED ;;;
                                        (0472) ;******************************************************************************************
                                        (0473) IF DEBUG_STATE
                                        (0474)    mov A, 0xEE
                                        (0475)    lcall TX8_1_PutSHexByte
                                        (0476)    mov A, 0x2c
                                        (0477)    lcall TX8_1_PutChar
                                        (0478) ENDIF
                                        (0479) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0480)     REG_RESTORE IDX_PP
                                        (0481) ENDIF
0542: 20       POP   X                  (0482)     pop X
0543: 18       POP   A                  (0483)     pop A
0544: 7E       RETI                     
                                        (0484)     RAM_RESTORE_NATIVE_PAGING		;has no effect if this is an ISR
                                        (0485)     I2CHW_SERVICE_RETURN
                                        (0486) 
                                        (0487) ; A data byte has been transmitted or has been received.  This is again decided by testing
                                        (0488) ; the R/W bit of the SlaveAddr byte.  If 0, then a byte transmission has been completed and
                                        (0489) ; the next byte has to be transmitted.  If 1, a byte has been received and has to be ACK'ed
                                        (0490) ; or NAKed
                                        (0491) DataState:
0545: 2E 01 80 OR    [0x1],0x80         (0492)     or [I2CHW_bStatus], I2CHW_ISR_ACTIVE
0548: 47 03 01 TST   [0x3],0x1          (0493)     tst [I2CHW_SlaveAddr], 01                                
054B: B0 28    JNZ   0x0574             (0494)     jnz I2C_ReadSlave                                        ; Process the received byte
054D: 80 80    JMP   0x05CE             (0495)     jmp I2C_WriteSlave                                       ; Write next byte to Slave
                                        (0496) ;******************************************************************************************
                                        (0497) ;;; UNREACHABLE EXIT POINT STACK MAY BE CORRUPTED ;;;
                                        (0498) ;******************************************************************************************
                                        (0499) IF DEBUG_STATE
                                        (0500)    mov A, 0xEE
                                        (0501)    lcall TX8_1_PutSHexByte
                                        (0502)    mov A, 0x2c
                                        (0503)    lcall TX8_1_PutChar
                                        (0504) ENDIF
                                        (0505) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0506)     REG_RESTORE IDX_PP
                                        (0507) ENDIF
054F: 20       POP   X                  (0508) 	pop X
0550: 18       POP   A                  (0509) 	pop A
0551: 7E       RETI                     
0552: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (0510)     RAM_RESTORE_NATIVE_PAGING		;has no effect if this is an ISR
                                        (0511)     I2CHW_SERVICE_RETURN
                                        (0512) 
                                        (0513) ; Slave did not ACK.  Either the Slave was not present or is busy.  So release the bus,
                                        (0514) ; set the ERROR and SLAVE_NAK bits in the bStatus register and return
                                        (0515) SlaveAddrNAK:
                                        (0516) ;******************************************************************************************
                                        (0517) ;;; EXIT STATE: SLAVE NAK'ED IT'S ADDRESS ,RELEASE BUS (MASTER OPERATION STATE An);;;
                                        (0518) ;******************************************************************************************
                                        (0519) IF DEBUG_STATE
                                        (0520)    mov A, 'A'
                                        (0521)    lcall TX8_1_PutChar
                                        (0522)    mov A, 'n'
                                        (0523)    lcall TX8_1_PutChar
                                        (0524)    mov A, 0x2c
                                        (0525)    lcall TX8_1_PutChar
                                        (0526) ENDIF
                                        (0527) IF SNIFF_DATA
                                        (0528)    mov A, reg[I2CHW_DR]
                                        (0529)    lcall TX8_1_PutSHexByte
                                        (0530)    mov A, 0x2c
                                        (0531)    lcall TX8_1_PutChar
                                        (0532) ENDIF
                                        (0533) IF DEBUG_STATE
                                        (0534)    lcall TX8_1_PutCRLF
                                        (0535) ENDIF
                                        (0536) 
                                        (0537) 
                                        (0538) ;
                                        (0539) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0540) ;
                                        (0541)     SetI2CHW_SCR 0                                           ; Sets the tx/rx bit to receive, generates a stop without sending any data
                                        (0542) 
0555: 26 01 7F AND   [0x1],0x7F         (0543)     and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
0558: 2E 01 60 OR    [0x1],0x60         (0544)     or [I2CHW_bStatus], (I2CHW_ERROR | I2CHW_SLAVE_NAK )        ; Set the ERROR and SLAVE_NAK Flag
                                        (0545) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0546)     REG_RESTORE IDX_PP
                                        (0547) ENDIF
055B: 20       POP   X                  (0548)     pop X
055C: 18       POP   A                  (0549)     pop A
055D: 7E       RETI                     
                                        (0550)     RAM_RESTORE_NATIVE_PAGING
                                        (0551)     I2CHW_SERVICE_RETURN
                                        (0552) 
                                        (0553) NoStart:
                                        (0554) ; A previous generated start could not be sent.  This could be because the bus has already
                                        (0555) ; been acquired by another Master.  So test the Address bit.  If it is set, it is possible
                                        (0556) ; that the Slave has been addressed.  Branch to Slave ISR to compare the address.
                                        (0557) 
                                        (0558) ;first check to see if the slave function is enabled
                                        (0559) ;so no valid address are detected without the interrupt 
                                        (0560) ;capability to ACK them
                                        (0561)     IF(I2CHW_USED_I2C_BLOCK)
                                        (0562)     M8C_SetBank1
                                        (0563)     tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
                                        (0564)     M8C_SetBank0
                                        (0565)     ELSE
055E: 49 D6 01 TST   REG[0xD6],0x1      (0566)     tst reg[I2CHW_CFG],I2C_S_EN                              ; is the slave function enabled?
                                        (0567)     ENDIF
0561: AF A7    JZ    0x0509             (0568)     jz  ArbitrationLossBusRelease 
                                        (0569) 
0563: 49 D7 08 TST   REG[0xD7],0x8      (0570)     tst reg[I2CHW_SCR],I2C_ADDRIN                            ; Test if the Received byte is an address
                                        (0571) 
                                        (0572) IF I2CHW_SLAVE_OPTION
0566: B0 D5    JNZ   0x063C             (0573)     jnz I2CHW_ISR_SLAVE                                      ; If yes, branch to Slave ISR
                                        (0574) ELSE
                                        (0575) ; If Slave mode is not enabled then nothing to do.  In fact, this condition could never
                                        (0576) ; occur.  If the Slave were disabled, then a Byte complete interrupt will only be 
                                        (0577) ; generated on successful completion of Start.  In that case, the Start bit will already
                                        (0578) ; have been cleared and the program can never branch here.  Still just to make sure...
                                        (0579)     and [I2CHW_bStatus],~I2CHW_ISR_ACTIVE    
                                        (0580) ;******************************************************************************************
                                        (0581) ;;; UNREACHABLE EXIT POINT STACK MAY BE CORRUPTED: RELEASE BUS COMPLETELY;;;
                                        (0582) ;;; ISR program flow should not reach this point.
                                        (0583) ;******************************************************************************************
                                        (0584) IF DEBUG_STATE
                                        (0585)    mov [I2CHW_ExitState], 0xE1
                                        (0586)    mov A, 0xE1
                                        (0587)    lcall TX8_1_PutSHexByte
                                        (0588)    mov A, 0x2c
                                        (0589)    lcall TX8_1_PutChar
                                        (0590) ENDIF
                                        (0591) 
                                        (0592) ;
                                        (0593) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0594) ;
                                        (0595)     SetI2CHW_SCR 0                                           ; Sets the tx/rx bit to receive, generates a stop without sending any data
                                        (0596) 
                                        (0597) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0598)     REG_RESTORE IDX_PP
                                        (0599) ENDIF
                                        (0600)     pop X
                                        (0601)     pop A
                                        (0602)     RAM_RESTORE_NATIVE_PAGING
                                        (0603)     I2CHW_SERVICE_RETURN
                                        (0604) ENDIF
                                        (0605)     
                                        (0606) ; The control has branched here because a byte has been received from the Slave.  Process
                                        (0607) ; this received data.
                                        (0608) I2C_ReadSlave1stByte:
                                        (0609) 
0568: 2E 01 80 OR    [0x1],0x80         (0610)     or [I2CHW_bStatus], I2CHW_ISR_ACTIVE
056B: 26 04 FB AND   [0x4],0xFB         (0611)     and [I2CHW_MasterStatus], ~I2CHW_RD_COMPLETE
056E: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (0612) 
                                        (0613) ;read normal data in from slave immediately after the address is sent, there is no data to read
                                        (0614) ;but the bus is stalled at byte complete
                                        (0615) ;******************************************************************************************
                                        (0616) ;;; EXIT STATE: READING FROM SLAVE (MASTER OPERATION STATE Ar);;;
                                        (0617) ;******************************************************************************************
                                        (0618) IF DEBUG_STATE
                                        (0619)    mov A, 'A'
                                        (0620)    lcall TX8_1_PutChar
                                        (0621)    mov A, 'r'
                                        (0622)    lcall TX8_1_PutChar
                                        (0623)    mov A, 0x2c
                                        (0624)    lcall TX8_1_PutChar
                                        (0625) ENDIF
                                        (0626) IF SNIFF_DATA
                                        (0627)    mov A, reg[I2CHW_DR]
                                        (0628)    lcall TX8_1_PutSHexByte
                                        (0629)    mov A, 0x2c
                                        (0630)    lcall TX8_1_PutChar
                                        (0631) ENDIF
                                        (0632) 
                                        (0633) 
                                        (0634) ;
                                        (0635) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0636) ;
                                        (0637)     SetI2CHW_SCR 0                                           ;sets the tx/rx bit to receive, and clocks a byte in
                                        (0638) 
                                        (0639) 
                                        (0640) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0641)     REG_RESTORE IDX_PP
                                        (0642) ENDIF
0571: 20       POP   X                  (0643)     pop X
0572: 18       POP   A                  (0644)     pop A
0573: 7E       RETI                     
                                        (0645)     RAM_RESTORE_NATIVE_PAGING
                                        (0646)     I2CHW_SERVICE_RETURN
                                        (0647) 
                                        (0648) I2C_ReadSlave:                                               ;this is just a normal read
                                        (0649) 
                                        (0650) ; MASTER READ from SLAVE
                                        (0651) ; (and writing to it's own RAM--Write_Buf and Write_Cnt)
                                        (0652) ;
                                        (0653) ;@PSoC_UserCode_BODY1@ (Do not change this line.)
                                        (0654) ;---------------------------------------------------
                                        (0655) ; Insert your custom code below this banner
                                        (0656) ;---------------------------------------------------
                                        (0657) 
                                        (0658) ;********************************************************
                                        (0659) ; By modifying the section from here down to the next comment block
                                        (0660) ; a user could process data for a custom I2C Master Read (write to RAM) application
                                        (0661) ; NOTE: I2C handshakes (ACK/NAK may be effected by any introduced bugs)
                                        (0662) ;********************************************************
0574: 47 04 80 TST   [0x4],0x80         (0663)    tst   [I2CHW_MasterStatus], fMULTIMASTER_NAK_NEXT_WR
0577: B0 14    JNZ   0x058C             (0664)    jnz   InStoreData
                                        (0665)    ;
                                        (0666)    ;process write data here
                                        (0667)    ;
0579: 7A 06    DEC   [0x6]              (0668)    dec   [I2CHW_MasterWrite_Count]
057B: C0 3D    JC    0x05B9             (0669)    jc    CompleteRDXfer                                      ; carry set if value became -1
                                        (0670) 
057D: 3C 06 00 CMP   [0x6],0x0          (0671)    cmp   [I2CHW_MasterWrite_Count], 00                       ;set nak flag, dec count, and store data
0580: A0 03    JZ    0x0584             (0672)    jz    InNakNextByte
0582: 80 06    JMP   0x0589             (0673)    jmp   InNotBufEnd
                                        (0674) InNakNextByte:                                               ;set the nakflag in I2CHW_bStatus
0584: 2E 04 80 OR    [0x4],0x80         (0675)    or    [I2CHW_MasterStatus], fMULTIMASTER_NAK_NEXT_WR
0587: 80 04    JMP   0x058C             (0676)    jmp   InStoreData
                                        (0677) InNotBufEnd:
0589: 26 04 7F AND   [0x4],0x7F         (0678)    and   [I2CHW_MasterStatus], ~fMULTIMASTER_NAK_NEXT_WR     ;clear the nak flag in case it was set from a previous operation
                                        (0679) InStoreData:
                                        (0680)    ;This is the ONLY place this bit is set  This bit should never be cleared by the isr ONLY by the API ClrWrStatus()
058C: 2E 04 01 OR    [0x4],0x1          (0681)    or    [I2CHW_MasterStatus], I2CHW_RD_NOERR                ;set current status
                                        (0682) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0683)    mov   A, [pI2CHW_MasterWrite_BufHI]
                                        (0684) ENDIF
                                        (0685)    RAM_SETPAGE_IDX A
058F: 58 05    MOV   X,[0x5]            (0686)    mov   X, [pI2CHW_MasterWrite_BufLO]
0591: 5D D8    MOV   A,REG[0xD8]        (0687)    mov   A, reg[I2CHW_DR]
                                        (0688)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0593: 54 00    MOV   [X+0],A            (0689)    mov   [X],A                                               ;save the last byte
                                        (0690)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0595: 76 05    INC   [0x5]              (0691)    inc   [pI2CHW_MasterWrite_BufLO]
                                        (0692) 
0597: 47 04 80 TST   [0x4],0x80         (0693)    tst   [I2CHW_MasterStatus], fMULTIMASTER_NAK_NEXT_WR
059A: B0 07    JNZ   0x05A2             (0694)    jnz   NAK_this_one
059C: 62 D7 10 MOV   REG[0xD7],0x10     
                                        (0695) 
                                        (0696) ;********************************************************
                                        (0697) ; End user I2C Buffered WRITE (to RAM) Customization
                                        (0698) ;********************************************************
                                        (0699) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0700) 
                                        (0701) AckTheRead:
                                        (0702) ;******************************************************************************************
                                        (0703) ;;; NORMAL ACK UPON READING SLAVE DATA (STATE DATA Ra);;;
                                        (0704) ;******************************************************************************************
                                        (0705) IF DEBUG_STATE
                                        (0706)    mov A, 'R'
                                        (0707)    lcall TX8_1_PutChar
                                        (0708)    mov A, 'a'
                                        (0709)    lcall TX8_1_PutChar
                                        (0710)    mov A, 0x2c
                                        (0711)    lcall TX8_1_PutChar
                                        (0712) ENDIF
                                        (0713) IF SNIFF_DATA
                                        (0714)    mov A, reg[I2CHW_DR]
                                        (0715)    lcall TX8_1_PutSHexByte
                                        (0716)    mov A, 0x2c
                                        (0717)    lcall TX8_1_PutChar
                                        (0718) ENDIF
                                        (0719) 
                                        (0720) ;
                                        (0721) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0722) ;
                                        (0723)     SetI2CHW_SCR I2C_ACKOUT                                  ;send Ack
                                        (0724) 
                                        (0725) 
                                        (0726) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0727)     REG_RESTORE IDX_PP
                                        (0728) ENDIF
059F: 20       POP   X                  (0729)     pop X
05A0: 18       POP   A                  (0730)     pop A
05A1: 7E       RETI                     
                                        (0731)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (0732)     I2CHW_SERVICE_RETURN
                                        (0733) 
                                        (0734) NAK_this_one:
05A2: 26 04 7F AND   [0x4],0x7F         (0735)     and  [I2CHW_MasterStatus], ~fMULTIMASTER_NAK_NEXT_WR     ; Clear NAKNextWr bit
05A5: 26 04 F8 AND   [0x4],0xF8         (0736)     and   [I2CHW_MasterStatus], ~0x07                        ; Clear the read status bits
05A8: 26 01 03 AND   [0x1],0x3          (0737)     and [I2CHW_bStatus], (I2CHW_NoStop | I2CHW_RepStart)
05AB: A0 0D    JZ    0x05B9             (0738)     jz      CompleteRDXfer
                                        (0739) ; If No stop mode, then do not send ACK or NAK.  The next transaction should be
                                        (0740) ; with a Repeat Start Condition.  The bus is stalled till next transaction.
05AD: 26 01 7F AND   [0x1],0x7F         (0741)     and   [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
05B0: 2E 04 01 OR    [0x4],0x1          (0742)     or    [I2CHW_MasterStatus], I2CHW_RD_NOERR
05B3: 2E 04 04 OR    [0x4],0x4          (0743)     or    [I2CHW_MasterStatus], I2CHW_RD_COMPLETE
                                        (0744) 
                                        (0745) ;******************************************************************************************
                                        (0746) ;;; EXIT ISR WITHOUT RELEASING BUS: A RESTART/REPEAT START WAS REQUESTED (STATE DATA Rx);;;
                                        (0747) ;******************************************************************************************
                                        (0748) IF DEBUG_STATE
                                        (0749)    mov A, 'R'
                                        (0750)    lcall TX8_1_PutChar
                                        (0751)    mov A, 'x'
                                        (0752)    lcall TX8_1_PutChar
                                        (0753)    mov A, 0x2c
                                        (0754)    lcall TX8_1_PutChar
                                        (0755) ENDIF
                                        (0756) IF SNIFF_DATA
                                        (0757)    mov A, reg[I2CHW_DR]
                                        (0758)    lcall TX8_1_PutSHexByte
                                        (0759)    mov A, 0x2c
                                        (0760)    lcall TX8_1_PutChar
                                        (0761) ENDIF
                                        (0762) IF DEBUG_STATE
                                        (0763)    lcall TX8_1_PutCRLF
                                        (0764) ENDIF
                                        (0765) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0766)     REG_RESTORE IDX_PP
                                        (0767) ENDIF
05B6: 20       POP   X                  (0768)     pop X
05B7: 18       POP   A                  (0769)     pop A
05B8: 7E       RETI                     
                                        (0770)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (0771)     I2CHW_SERVICE_RETURN
                                        (0772) 
                                        (0773) ;if neither a repeat start or a NoStop, then this must be a CompleteXfer request.
                                        (0774) ;The NAK (not I2C_SNDACK) bit in I2C_SCR below will automatically generate a stop
                                        (0775) CompleteRDXfer:
                                        (0776) ;@PSoC_UserCode_BODY7@ (Do not change this line.)
                                        (0777) ;---------------------------------------------------
                                        (0778) ; Insert your custom code below this banner
                                        (0779) ;---------------------------------------------------
                                        (0780)         ; *****
                                        (0781)         ; Here the user can write code to process the received data
                                        (0782)         ; The bus will be stalled till the processing is complete.
                                        (0783)         ; ******
                                        (0784) ;********************************************************
                                        (0785) ; End user I2C Buffered WRITE (to RAM) Customization
                                        (0786) ;********************************************************
                                        (0787) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0788) 
                                        (0789) ;******************************************************************************************
                                        (0790) ;;; NORMAL NAK UPON READING LAST SLAVE DATA BYTE (STATE DATA Rs);;;
                                        (0791) ;******************************************************************************************
                                        (0792) IF DEBUG_STATE
                                        (0793)    mov A, 'R'
                                        (0794)    lcall TX8_1_PutChar
                                        (0795)    mov A, 's'
                                        (0796)    lcall TX8_1_PutChar
                                        (0797)    mov A, 0x2c
                                        (0798)    lcall TX8_1_PutChar
                                        (0799) ENDIF
                                        (0800) IF SNIFF_DATA
                                        (0801)    mov A, reg[I2CHW_DR]
                                        (0802)    lcall TX8_1_PutSHexByte
                                        (0803)    mov A, 0x2c
                                        (0804)    lcall TX8_1_PutChar
                                        (0805) ENDIF
                                        (0806) IF DEBUG_STATE
                                        (0807)    lcall TX8_1_PutCRLF
                                        (0808) ENDIF
05B9: 2E 04 01 OR    [0x4],0x1          (0809)     or    [I2CHW_MasterStatus], I2CHW_RD_NOERR
05BC: 2E 04 04 OR    [0x4],0x4          (0810)     or    [I2CHW_MasterStatus], I2CHW_RD_COMPLETE
                                        (0811) ; Clear the NoStop and RepStart and ISR_ACTIVE bits in the bStatus register
05BF: 26 01 7C AND   [0x1],0x7C         (0812)     and [I2CHW_bStatus], ~(I2CHW_RepStart | I2CHW_NoStop | I2CHW_ISR_ACTIVE)
05C2: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (0813) 
                                        (0814) ;
                                        (0815) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0816) ;
                                        (0817)     SetI2CHW_SCR 0                                           ;Generate NAK (Stop)
                                        (0818) 
                                        (0819) 
                                        (0820) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0821)     REG_RESTORE IDX_PP
                                        (0822) ENDIF
05C5: 20       POP   X                  (0823)     pop X
05C6: 18       POP   A                  (0824)     pop A
05C7: 7E       RETI                     
                                        (0825)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (0826)     I2CHW_SERVICE_RETURN                                     ; return and wait for the next interrupt (on data)
                                        (0827) 
                                        (0828) 
                                        (0829) ; Control has branched here because a byte transmit has completed.  Check if more bytes
                                        (0830) ; have to be transmitted to slave.  If this is the first byte to be transmitted, then
                                        (0831) ; clear the WR_COMPLETE flag in the MaterStatus register and set the ISR_ACTIVE flag
                                        (0832) ; in the bStatus register.
                                        (0833) 
                                        (0834) I2C_WriteSlave1stByte:
                                        (0835) ;******************************************************************************************
                                        (0836) ;;; SLAVE ACK'ED ADDR BEGIN DATA WRITE (STATE DATA Aw);;;
                                        (0837) ;******************************************************************************************
05C8: 26 04 BF AND   [0x4],0xBF         (0838)     and [I2CHW_MasterStatus], ~I2CHW_WR_COMPLETE
05CB: 2E 01 80 OR    [0x1],0x80         (0839)     or [I2CHW_bStatus], I2CHW_ISR_ACTIVE
                                        (0840) IF DEBUG_STATE
                                        (0841)    mov A, 'A'
                                        (0842)    lcall TX8_1_PutChar
                                        (0843)    mov A, 'w'
                                        (0844)    lcall TX8_1_PutChar
                                        (0845)    mov A, 0x2c
                                        (0846)    lcall TX8_1_PutChar
                                        (0847) ENDIF
                                        (0848) IF SNIFF_DATA
                                        (0849)    mov A, reg[I2CHW_DR]
                                        (0850)    lcall TX8_1_PutSHexByte
                                        (0851)    mov A, 0x2c
                                        (0852)    lcall TX8_1_PutChar
                                        (0853) ENDIF
                                        (0854) 
                                        (0855) I2C_WriteSlave:
05CE: 49 D7 02 TST   REG[0xD7],0x2      (0856)     tst reg[I2CHW_SCR], ( I2C_LST_BIT )                      ;must be a zero or no slave answered
05D1: B0 40    JNZ   0x0612             (0857)     jnz SlaveDataNAK
05D3: 50 04    MOV   A,0x4              (0858)     mov A, (I2C_TX)
05D5: 08       PUSH  A                  (0859)     push A
                                        (0860) 
                                        (0861) ;
                                        (0862) ;MASTER is WRITING TO SLAVE (& reading data from ram or flash buffer)
                                        (0863) ;
                                        (0864) ;;code snipped from SW I2C below
                                        (0865) 
                                        (0866) I2C_ObtainOutData:
                                        (0867) 
                                        (0868) ;********************************************************
                                        (0869) ; here we need to get the next data to output (master-read)
                                        (0870) ; also set the status byte for use on exit
                                        (0871) ;********************************************************
                                        (0872) 
                                        (0873) IF I2CHW_READ_FLASH
                                        (0874) ;@PSoC_UserCode_BODY2@ (Do not change this line.)
                                        (0875) ;---------------------------------------------------
                                        (0876) ; Insert your custom code below this banner
                                        (0877) ; to modify the way a master might read non-volatile data
                                        (0878) ; to send.
                                        (0879) ;---------------------------------------------------
                                        (0880) 
                                        (0881)     tst  [I2CHW_MasterStatus],I2CHW_READFLASH
                                        (0882)     jz   ReadOutData
                                        (0883) 
                                        (0884)     ;
                                        (0885)     ;get the data
                                        (0886)     ;
                                        (0887)     mov  X, [pI2CHW_MasterRead_BufLO]
                                        (0888)     mov  A, [pI2CHW_MasterRead_BufHI]
                                        (0889)     romx
                                        (0890)     mov  reg[I2CHW_DR],A
                                        (0891)     dec  [I2CHW_MasterRead_Count]                            ;calculate addr lsb
                                        (0892)     jnc  NoDecHighCount
                                        (0893)     dec  [I2CHW_MasterRead_CountHI]
                                        (0894)     jc   MstrWRComplete
                                        (0895) 
                                        (0896) NoDecHighCount:
                                        (0897)     inc  [pI2CHW_MasterRead_BufLO]                           ;set the next flash address to read
                                        (0898)     jnc  NoIncHiAddr
                                        (0899)     inc  [pI2CHW_MasterRead_BufHI]
                                        (0900) NoIncHiAddr:
                                        (0901)    jmp   I2CNormalOutput
                                        (0902) ;
                                        (0903) ;****** THERE SHOULD BE NO WAY TO REACH THIS STATE WE'LL JUST TERMINATE THE ACTIVITY SINCE WERE THE MASTER
                                        (0904) ;********    MAY LEAVE IT IN TO DEAL WITH MULTI MASTER SLAVE CONFIGS THOUGH BUT NOT IN THIS FILE
                                        (0905) ;
                                        (0906) ;FlashRdOverflow:
                                        (0907)     ;deal with the over flow condition by re-sending last data byte (dec the low addr)
                                        (0908) 
                                        (0909) ;   or    [I2CHW_MasterStatus], I2CHW_RD_OVERFLOW
                                        (0910) ;                                                                      ;set count back to 0
                                        (0911) ;   mov   [I2CHW_MasterReadCountHI], 0                                  ;functionally the same as incrementing ffff and less instructions
                                        (0912) ;   mov   [I2CHW_MasterReadCount], 0
                                        (0913) ;   jmp   I2CNormalRead
                                        (0914) 
                                        (0915) ;---------------------------------------------------
                                        (0916) ; Insert your custom code above this banner
                                        (0917) ;---------------------------------------------------
                                        (0918) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0919) 
                                        (0920) ENDIF
                                        (0921) 
                                        (0922) ;@PSoC_UserCode_BODY3@ (Do not change this line.)
                                        (0923) ;---------------------------------------------------
                                        (0924) ; Insert your custom code below this banner
                                        (0925) ; to modify the way a master might read RAM data to send
                                        (0926) ; to an I2C device
                                        (0927) ; By replacing the section from here down to the next block
                                        (0928) ; a user could process data for a custom I2C READ application
                                        (0929) ;---------------------------------------------------
                                        (0930) ReadOutData:
                                        (0931)    ;read the current data byte
                                        (0932) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0933)    mov   A, [pI2CHW_MasterRead_BufHI]
                                        (0934) ENDIF
                                        (0935)    RAM_SETPAGE_IDX A
05D6: 58 07    MOV   X,[0x7]            (0936)    mov   X, [pI2CHW_MasterRead_BufLO]
                                        (0937)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
05D8: 52 00    MOV   A,[X+0]            (0938)    mov   A, [X]
                                        (0939)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
05DA: 60 D8    MOV   REG[0xD8],A        (0940)    mov   reg[I2CHW_DR], A
05DC: 7A 08    DEC   [0x8]              (0941)    dec   [I2CHW_MasterRead_Count]
                                        (0942) 
05DE: C0 0C    JC    0x05EB             (0943)    jc    MstrWRComplete
05E0: 76 07    INC   [0x7]              (0944)    inc   [pI2CHW_MasterRead_BufLO]
05E2: 80 01    JMP   0x05E4             (0945)    jmp   I2CNormalOutput
                                        (0946) ;
                                        (0947) ;ram read overflow detected here, just re-send the last location in the buffer
                                        (0948) ;
                                        (0949) ;********        THERE SHOULD BE NO WAY TO OVERFLOW FOR THIS CASE
                                        (0950) ;********    MAY LEAVE IT IN TO DEAL WITH MULTI MASTER SLAVE CONFIGS THOUGH BUT NOT IN THIS FILE
                                        (0951) ;
                                        (0952) ;RamRDOverflow:
                                        (0953) ;   or    [I2CHW_MasterStatus], I2CHW_RD_OVERFLOW
                                        (0954) ;   inc   [I2CHW_MasterReadCount]                                       ; set back to zero
                                        (0955) 
                                        (0956) ;---------------------------------------------------
                                        (0957) ; End user I2C MASTER WRITE TO SLAVE /READ buffer customization section
                                        (0958) ; Insert your custom code above this banner
                                        (0959) ;---------------------------------------------------
                                        (0960) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0961) 
                                        (0962) I2CNormalOutput:
                                        (0963) ;******************************************************************************************
                                        (0964) ;;; NORMAL WRITE TO SLAVE (SET I2C_TX bit) (STATE DATA W);;;
                                        (0965) ;******************************************************************************************
                                        (0966) IF DEBUG_STATE
                                        (0967)    mov A, 'W'
                                        (0968)    lcall TX8_1_PutChar
                                        (0969) ENDIF
                                        (0970) IF SNIFF_DATA
                                        (0971)    mov A, reg[I2CHW_DR]
                                        (0972)    lcall TX8_1_PutSHexByte
                                        (0973) ENDIF
                                        (0974) 
                                        (0975)         ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                        (0976)         ;and place there based on whether or not the previous transmission was our I2C address.
05E4: 18       POP   A                  (0977)         pop   A
05E5: 40       NOP                      (0978)         nop
05E6: 60 D7    MOV   REG[0xD7],A        
                                        (0979) 
                                        (0980) 
                                        (0981) ;
                                        (0982) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (0983) ;
                                        (0984)     SetI2CHW_SCR A                                           ;Sets the I2C_TX bit in the I2C_SCR reg.
                                        (0985) 
                                        (0986) 
                                        (0987) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0988)     REG_RESTORE IDX_PP
                                        (0989) ENDIF
05E8: 20       POP   X                  (0990)     pop X
05E9: 18       POP   A                  (0991)     pop A
05EA: 7E       RETI                     
                                        (0992)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (0993)     I2CHW_SERVICE_RETURN 
                                        (0994) 
                                        (0995) MstrWRComplete:
05EB: 26 04 8F AND   [0x4],0x8F         (0996)     and   [I2CHW_MasterStatus], ~0x70                        ;clear the write status bits
                                        (0997) ; Check if the write was called under No stop or repeat start conditions.
                                        (0998) ; If yes, then do not generate the stop condition.  The bus is stalled.
                                        (0999) ; The user may want to use the bus for the next transaction by using repeat start.
05EE: 26 01 03 AND   [0x1],0x3          (1000)     and [I2CHW_bStatus], (I2CHW_NoStop | I2CHW_RepStart)
05F1: A0 0E    JZ    0x0600             (1001)     jz      CompleteWRXfer                                   ; Complete Transfer condition   
05F3: 18       POP   A                  (1002)     pop  A                                                   ; Clear the stack for return
05F4: 2E 04 40 OR    [0x4],0x40         (1003)     or    [I2CHW_MasterStatus], I2CHW_WR_COMPLETE
05F7: 2E 04 10 OR    [0x4],0x10         (1004)     or    [I2CHW_MasterStatus], I2CHW_WR_NOERR
                                        (1005) 
05FA: 26 01 7F AND   [0x1],0x7F         (1006)     and  [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
                                        (1007) 
                                        (1008) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1009)     REG_RESTORE IDX_PP
                                        (1010) ENDIF
                                        (1011) ;******************************************************************************************
                                        (1012) ;;; EXIT ISR WITHOUT RELEASING BUS REPEAT START/RESTART REQUESTED (STATE DATA Wx);;;
                                        (1013) ;******************************************************************************************
                                        (1014) IF DEBUG_STATE
                                        (1015)    mov A, 0x2c
                                        (1016)    lcall TX8_1_PutChar
                                        (1017)    mov A, 'x'
                                        (1018)    lcall TX8_1_PutChar
                                        (1019)    mov A, 0x2c
                                        (1020)    lcall TX8_1_PutChar
                                        (1021)    lcall TX8_1_PutCRLF
                                        (1022) ENDIF
05FD: 20       POP   X                  (1023)     pop X
05FE: 18       POP   A                  (1024)     pop A
05FF: 7E       RETI                     
                                        (1025)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1026)     I2CHW_SERVICE_RETURN
                                        (1027) 
                                        (1028) ; Complete Transfer condition. Set the WR_COMPLETE, and WR_NOERR bits and generate
                                        (1029) ; a Stop.  The release of the I2C_TX bit in I2C_SCR below will automatically generate a stop
                                        (1030) CompleteWRXfer:
                                        (1031) ;******************************************************************************************
                                        (1032) ;;; RELEASE BUS AFTER LAST BYTE TRANSMITTED TO SLAVE (STATE DATA Ws);;;
                                        (1033) ;******************************************************************************************
                                        (1034) ;must also fix up the data count because it was decremented past zero on the Byte_Complete 
                                        (1035) ;AFTER the last byte was transmitted.  This makes sure that if the entire transmission was
                                        (1036) ;successful the count will be 0.  
0600: 76 08    INC   [0x8]              (1037)     inc  [I2CHW_MasterRead_Count]                          
                                        (1038) IF I2CHW_READ_FLASH
                                        (1039)     inc  [I2CHW_MasterRead_CountHI]						 ;if a two byte count decremented past zero
                                        (1040) 	                                                         ;both high and lo addrs should be incremented.
                                        (1041) ENDIF
                                        (1042) 
                                        (1043) IF DEBUG_STATE
                                        (1044)    mov A, 0x2c
                                        (1045)    lcall TX8_1_PutChar
                                        (1046)    mov A, 's'
                                        (1047)    lcall TX8_1_PutChar
                                        (1048)    mov A, 0x2c
                                        (1049)    lcall TX8_1_PutChar
                                        (1050)    lcall TX8_1_PutCRLF
                                        (1051) ENDIF
0602: 18       POP   A                  (1052)     pop   A
                                        (1053) 
0603: 2E 04 40 OR    [0x4],0x40         (1054)     or    [I2CHW_MasterStatus], I2CHW_WR_COMPLETE
0606: 2E 04 10 OR    [0x4],0x10         (1055)     or    [I2CHW_MasterStatus], I2CHW_WR_NOERR
                                        (1056) ; Clear the NoStop and RepStart and ISR_ACTIVEbits in the bus status register
0609: 26 01 7C AND   [0x1],0x7C         (1057)     and [I2CHW_bStatus], ~(I2CHW_RepStart | I2CHW_NoStop | I2CHW_ISR_ACTIVE)
060C: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (1058) 
                                        (1059) ;
                                        (1060) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (1061) ;
                                        (1062)     SetI2CHW_SCR 0                                           ;this will release the bus and generate a stop condition
                                        (1063) 
                                        (1064) 
                                        (1065) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1066)     REG_RESTORE IDX_PP
                                        (1067) ENDIF
060F: 20       POP   X                  (1068)     pop X
0610: 18       POP   A                  (1069)     pop A
0611: 7E       RETI                     
                                        (1070)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1071)     I2CHW_SERVICE_RETURN
                                        (1072) 
                                        (1073) ; We are here because the Slave NAKed the previous data byte.
                                        (1074) ; Set the WR_COMPLETE and WR_OVERFLOW bits in the MasterStatus register.
                                        (1075) ; Also check for NoStop, RepeatStart conditions and accordingly generate a Stop or leave
                                        (1076) ; the bus stalled
                                        (1077) SlaveDataNAK:
                                        (1078) ;must also fix up the data buffer.  While it is marginally safe to nak a byte as a slave and 
                                        (1079) ;store it.  It is NEVER safe as a master to notice that a written byte has been nak'ed by a 
                                        (1080) ;slave and fail to re-send it.
                                        (1081) ;this piece of code fixes up the count and buffer that the master is using to get data from
                                        (1082) ;to re-transmit the byte when the next master write is done.
0612: 76 08    INC   [0x8]              (1083)     inc  [I2CHW_MasterRead_Count]                          ;calculate addr lsb
                                        (1084) IF I2CHW_READ_FLASH
                                        (1085)     jnc  NoIncHighCount
                                        (1086)     inc  [I2CHW_MasterRead_CountHI]
                                        (1087) 
                                        (1088) NoIncHighCount:
                                        (1089) ENDIF
0614: 7A 07    DEC   [0x7]              (1090)     dec  [pI2CHW_MasterRead_BufLO]                         ;set the next flash address to read
                                        (1091) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1092)     jnc  NoDecHiAddr
                                        (1093)     dec  [pI2CHW_MasterRead_BufHI]
                                        (1094) NoDecHiAddr:
                                        (1095) ELSE
                                        (1096) IF I2CHW_READ_FLASH
                                        (1097)     jnc  NoDecHiCAddr
                                        (1098)     dec  [pI2CHW_MasterRead_BufHI]
                                        (1099) NoDecHiCAddr:
                                        (1100) ENDIF
                                        (1101) ENDIF
                                        (1102) 
0616: 47 01 02 TST   [0x1],0x2          (1103)     tst [I2CHW_bStatus],I2CHW_NoStop
0619: B0 07    JNZ   0x0621             (1104)     jnz ReturnSlaveDataNAK
061B: 40       NOP                      (1105)     nop
061C: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (1106) ;******************************************************************************************
                                        (1107) ;;; SLAVE NAK'ED A TRANSMISSION (STATE DATA 0xWn);;;
                                        (1108) ;******************************************************************************************
                                        (1109) IF DEBUG_STATE
                                        (1110)    mov A, 0x2c
                                        (1111)    lcall TX8_1_PutChar
                                        (1112)    mov A, 'n'
                                        (1113)    lcall TX8_1_PutChar
                                        (1114)    mov A, 0x2c
                                        (1115)    lcall TX8_1_PutChar
                                        (1116) ENDIF
                                        (1117) 
                                        (1118) ;
                                        (1119) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (1120) ;
                                        (1121)     SetI2CHW_SCR 0                                           ;this will release the bus and generate a stop condition
                                        (1122) 
061F: 80 01    JMP   0x0621             (1123)     jmp UpdateSlaveDataNAKStatus
                                        (1124) 
                                        (1125) ReturnSlaveDataNAK:
                                        (1126) ;******************************************************************************************
                                        (1127) ;;; SLAVE NAK'ED BUT A DON'T RELEASE BUS AT INITIATING ROUTINES REQUEST (STATE DATA Wz);;;
                                        (1128) ;******************************************************************************************
                                        (1129) IF DEBUG_STATE
                                        (1130)    mov A, 0x2c
                                        (1131)    lcall TX8_1_PutChar
                                        (1132)    mov A, 'z'
                                        (1133)    lcall TX8_1_PutChar
                                        (1134)    mov A, 0x2c
                                        (1135)    lcall TX8_1_PutChar
                                        (1136)    lcall TX8_1_PutCRLF
                                        (1137) ENDIF
                                        (1138) UpdateSlaveDataNAKStatus:
0621: 26 01 7F AND   [0x1],0x7F         (1139)     and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
0624: 26 04 8F AND   [0x4],0x8F         (1140)     and   [I2CHW_MasterStatus], ~0x70                        ;clear the write status bits
0627: 2E 04 40 OR    [0x4],0x40         (1141)     or    [I2CHW_MasterStatus], I2CHW_WR_COMPLETE
062A: 2E 04 20 OR    [0x4],0x20         (1142)     or    [I2CHW_MasterStatus], I2CHW_WR_OVERFLOW
                                        (1143) 
                                        (1144) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1145)     REG_RESTORE IDX_PP
                                        (1146) ENDIF
062D: 20       POP   X                  (1147)     pop X
062E: 18       POP   A                  (1148)     pop A
062F: 7E       RETI                     
0630: 41 D6 EF AND   REG[0xD6],0xEF     
0633: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (1149)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1150)     I2CHW_SERVICE_RETURN
                                        (1151) 
                                        (1152) STOPTRAP:
                                        (1153) ;******************************************************************************************
                                        (1154) ;;; STOP INTERRUPTS SHOULD NOT GENERALLY BE USED FOR MULTI-MASTER-SLAVE OPERATIONS (STATE DATA Es);;;
                                        (1155) ;******************************************************************************************
                                        (1156) IF DEBUG_STATE
                                        (1157)    mov A, 'E'
                                        (1158)    lcall TX8_1_PutChar
                                        (1159)    mov A, 's'
                                        (1160)    lcall TX8_1_PutChar
                                        (1161)    mov A, 0x2c
                                        (1162)    lcall TX8_1_PutChar
                                        (1163)    lcall TX8_1_PutCRLF
                                        (1164) ENDIF
                                        (1165)     BitClrI2CHW_CFG I2C_STOPIE                               ; Disable Stop Interrupt
                                        (1166) 
                                        (1167) ;
                                        (1168) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (1169) ;
                                        (1170)     SetI2CHW_SCR 0                                           ;this will clear the Stop bit and release the bus
                                        (1171) 
                                        (1172) 
0636: 26 01 7F AND   [0x1],0x7F         (1173)     and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
                                        (1174) 
                                        (1175) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1176)     REG_RESTORE IDX_PP
                                        (1177) ENDIF
0639: 20       POP   X                  (1178)     pop X
063A: 18       POP   A                  (1179)     pop A
063B: 7E       RETI                     
                                        (1180)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1181)     I2CHW_SERVICE_RETURN
                                        (1182) 
                                        (1183) ;****************************************************************************************
                                        (1184) ;                                  Slave ISR 
                                        (1185) ;****************************************************************************************
                                        (1186) ; 1. Test the Address In bit of I2C_SCR.  If set, then compare the received address with
                                        (1187) ;    self address.  If match occurs, generate ACK, else NAK.
                                        (1188) ; 2. If I2C_TX bit of I2C_SCR is set, then we are transmitting and a byte complete interrupt
                                        (1189) ;    has occurred.  So check the ACK or NAK condition received from the Master.
                                        (1190) ; 3. If the Stop detect bit of I2C_SCR is set, then process a stop condition.
                                        (1191) ; 4. If none of the above, then process data received from Master
                                        (1192) 
                                        (1193) IF I2CHW_SLAVE_OPTION
                                        (1194) 
                                        (1195) I2CHW_ISR_SLAVE:
                                        (1196) 
063C: 49 D7 08 TST   REG[0xD7],0x8      (1197)     tst reg[I2CHW_SCR], I2C_ADDRIN
063F: B0 5D    JNZ   0x069D             (1198)     jnz I2C_EvaluateADDRIN                                   ; Process received Address
                                        (1199) 
0641: 49 D7 04 TST   REG[0xD7],0x4      (1200)     tst reg[I2CHW_SCR], I2C_TX  
0644: B0 94    JNZ   0x06D9             (1201)     jnz I2C_EvaluateACKIN                                    ; Process ACK or NAK from Master
                                        (1202) 
                                        (1203)     ; KLY Only check stop status if stop interrupt enabled
                                        (1204)     IF(I2CHW_USED_I2C_BLOCK)
                                        (1205)     M8C_SetBank1
                                        (1206)     tst reg[I2CHW_CFG],I2C_STOPIE
                                        (1207)     M8C_SetBank0
                                        (1208)     ELSE
0646: 49 D6 10 TST   REG[0xD6],0x10     (1209)     tst reg[I2CHW_CFG],I2C_STOPIE
                                        (1210)     ENDIF
0649: A0 06    JZ    0x0650             (1211)     jz ProcessRxData
                                        (1212) 
064B: 49 D7 20 TST   REG[0xD7],0x20     (1213)     tst reg[I2CHW_SCR], I2C_STOP_ST
064E: B0 A8    JNZ   0x06F7             (1214)     jnz Slave_STOPTRAP ; Process Stop condition
                                        (1215) 
                                        (1216)     ProcessRxData:
                                        (1217) 
0650: 49 D7 20 TST   REG[0xD7],0x20     (1218)     tst reg[I2CHW_SCR], I2C_STOP_ST
0653: B0 A3    JNZ   0x06F7             (1219)     jnz Slave_STOPTRAP                                       ; Process Stop condition
                                        (1220) 
                                        (1221) ; Process Received Data here
                                        (1222) 
                                        (1223) ;;code snipped from old SW I2C below
                                        (1224) ;
                                        (1225) ; MASTER WRITE to SLAVE
                                        (1226) ;
                                        (1227) ;@PSoC_UserCode_BODY4@ (Do not change this line.)
                                        (1228) ;---------------------------------------------------
                                        (1229) ; Insert your custom code below this banner
                                        (1230) ;---------------------------------------------------
                                        (1231) ; By modifying the section from here down to the next comment block
                                        (1232) ; a user could process data for a custom I2C WRITE application
                                        (1233) ; NOTE: I2C handshakes (ACK/NAK may be effected by any introduced bugs)
                                        (1234) ;********************************************************
0655: 47 09 80 TST   [0x9],0x80         (1235)     tst   [I2CHW_SlaveStatus], fMULTIMASTER_NAK_NEXT_WR
0658: B0 14    JNZ   0x066D             (1236)     jnz   WrStoreData
                                        (1237) ;
                                        (1238) ;process write data here
                                        (1239) ;
065A: 7A 0B    DEC   [0xB]              (1240)     dec   [I2CHW_SlaveWrite_Count]
065C: C0 26    JC    0x0683             (1241)     jc    I2CHW_WriteOverflow                                ; carry set if value became -1
                                        (1242) ;jz    WrStoreData
065E: 3C 0B 00 CMP   [0xB],0x0          (1243)     cmp   [I2CHW_SlaveWrite_Count], 00                       ;set nak flag, dec count, and store data
0661: A0 03    JZ    0x0665             (1244)     jz    WrNakNextByte
0663: 80 06    JMP   0x066A             (1245)     jmp   WrNotBufEnd
                                        (1246) WrNakNextByte:                                               ;set the ank flag in I2CHW_bStatus
0665: 2E 09 80 OR    [0x9],0x80         (1247)     or    [I2CHW_SlaveStatus], fMULTIMASTER_NAK_NEXT_WR
0668: 80 04    JMP   0x066D             (1248)     jmp   WrStoreData
                                        (1249) WrNotBufEnd:
066A: 26 09 7F AND   [0x9],0x7F         (1250)     and   [I2CHW_SlaveStatus], ~fMULTIMASTER_NAK_NEXT_WR     ;clear the nak flag in case it was set from a previous operation
                                        (1251) WrStoreData:
                                        (1252) ;This is the ONLY place this bit is set  This bit should never be cleared by the isr ONLY by the API ClrWrStatus()
066D: 2E 09 10 OR    [0x9],0x10         (1253)     or    [I2CHW_SlaveStatus], I2CHW_WR_NOERR                ;set current status
                                        (1254) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1255)     mov   A, [pI2CHW_SlaveWrite_BufHI]
                                        (1256) ENDIF
                                        (1257)     RAM_SETPAGE_IDX A
0670: 58 0A    MOV   X,[0xA]            (1258)     mov   X, [pI2CHW_SlaveWrite_BufLO]
0672: 5D D8    MOV   A,REG[0xD8]        (1259)     mov   A, reg[I2CHW_DR]
                                        (1260)     RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0674: 54 00    MOV   [X+0],A            (1261)     mov   [X],A                                              ;save the last byte
                                        (1262)     RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0676: 76 0A    INC   [0xA]              (1263)     inc   [pI2CHW_SlaveWrite_BufLO] 
                                        (1264) 
0678: 47 09 80 TST   [0x9],0x80         (1265)     tst   [I2CHW_SlaveStatus], fMULTIMASTER_NAK_NEXT_WR
067B: B0 0F    JNZ   0x068B             (1266)     jnz   Slave_NAK_this_one
067D: 62 D7 10 MOV   REG[0xD7],0x10     
                                        (1267) 
                                        (1268) ;---------------------------------------------------
                                        (1269) ; End user I2C WRITE Customization
                                        (1270) ; Insert your custom code above this banner
                                        (1271) ;---------------------------------------------------
                                        (1272) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (1273) 
                                        (1274) ;******************************************************************************************
                                        (1275) ;;; ACK DATA RECEIVED FROM ANOTHER MASTER (STATE DATA wa);;;
                                        (1276) ;******************************************************************************************
                                        (1277) IF DEBUG_STATE
                                        (1278)    mov A, 'w'
                                        (1279)    lcall TX8_1_PutChar
                                        (1280)    mov A, 'a'
                                        (1281)    lcall TX8_1_PutChar
                                        (1282)    mov A, 0x2c
                                        (1283)    lcall TX8_1_PutChar
                                        (1284) ENDIF
                                        (1285) IF SNIFF_DATA
                                        (1286)    mov A, reg[I2CHW_DR]
                                        (1287)    lcall TX8_1_PutSHexByte
                                        (1288)    mov A, 0x2c
                                        (1289)    lcall TX8_1_PutChar
                                        (1290) ENDIF
                                        (1291) 
                                        (1292) 
                                        (1293) ;
                                        (1294) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (1295) ;
                                        (1296)     SetI2CHW_SCR  (I2C_ACKOUT )
                                        (1297) 
                                        (1298) 
                                        (1299) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1300)     REG_RESTORE IDX_PP
                                        (1301) ENDIF
0680: 20       POP   X                  (1302)     pop X
0681: 18       POP   A                  (1303)     pop A
0682: 7E       RETI                     
                                        (1304)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1305)     I2CHW_SERVICE_RETURN
                                        (1306) 
                                        (1307) 
                                        (1308) ;
                                        (1309) ;ram-write-overflow label here, just rewrite the last location in the buffer
                                        (1310) ;    and set the overflow flag
                                        (1311) ;
                                        (1312) I2CHW_WriteOverflow:
0683: 2E 09 20 OR    [0x9],0x20         (1313)    or    [I2CHW_SlaveStatus], I2CHW_WR_OVERFLOW              ; flag the overflow
0686: 26 09 EF AND   [0x9],0xEF         (1314)    and   [I2CHW_SlaveStatus], ~I2CHW_WR_NOERR
0689: 76 0B    INC   [0xB]              (1315)    inc   [I2CHW_SlaveWrite_Count]                            ; put it back to zero
                                        (1316) ;If data is to be Nak'ed
                                        (1317) Slave_NAK_this_one:
                                        (1318) ;******************************************************************************************
                                        (1319) ;;; NAK DATA RECEIVED FROM ANOTHER MASTER (IGNORE FURTHER TRAFFIC) (STATE DATA wn);;;
                                        (1320) ;******************************************************************************************
                                        (1321) IF DEBUG_STATE
                                        (1322)    mov A, 'w'
                                        (1323)    lcall TX8_1_PutChar
                                        (1324)    mov A, 'n'
                                        (1325)    lcall TX8_1_PutChar
                                        (1326)    mov A, 0x2c
                                        (1327)    lcall TX8_1_PutChar
                                        (1328) ENDIF
                                        (1329) IF SNIFF_DATA
                                        (1330)    mov A, reg[I2CHW_DR]
                                        (1331)    lcall TX8_1_PutSHexByte
                                        (1332)    mov A, 0x2c
                                        (1333)    lcall TX8_1_PutChar
                                        (1334) ENDIF
                                        (1335) ;
                                        (1336) ; If the user wants to process the received data before NAK
                                        (1337) ; this is the place to do it.
                                        (1338) ; The Bus will be stalled till the processing is complete.
                                        (1339) ;
068B: 26 09 7F AND   [0x9],0x7F         (1340)     and   [I2CHW_SlaveStatus], ~fMULTIMASTER_NAK_NEXT_WR     ;clear the nak flag in case it was set from a previous operation
068E: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (1341) 
                                        (1342) 
                                        (1343) ;
                                        (1344) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (1345) ;
                                        (1346)     SetI2CHW_SCR ( 0 )
                                        (1347) 
                                        (1348) 
                                        (1349) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1350)     REG_RESTORE IDX_PP
                                        (1351) ENDIF
0691: 20       POP   X                  (1352)     pop X
0692: 18       POP   A                  (1353)     pop A
0693: 7E       RETI                     
0694: 43 D6 10 OR    REG[0xD6],0x10     
0697: 62 D7 10 MOV   REG[0xD7],0x10     
                                        (1354)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1355)     I2CHW_SERVICE_RETURN                                                       ;return and wait for the next interrupt (on data)
                                        (1356) 
                                        (1357) 
                                        (1358) ;********************************************************
                                        (1359) ; Treat the case where the Slave will be continuing to
                                        (1360) ; receive data after receiving the address
                                        (1361) ;********************************************************
                                        (1362) I2C_AckAddr_RXdata:
                                        (1363) IF I2CHW_POLLED_PROCESS
                                        (1364)     or [I2CHW_Poll_Status], I2C_WRITE_STARTED
                                        (1365) ELSE
                                        (1366)     IF(I2CHW_USED_I2C_BLOCK)
                                        (1367)     M8C_SetBank1
                                        (1368)     BitSetI2CHW_CFG ( I2C_STOPIE )
                                        (1369)     M8C_SetBank0
                                        (1370)     ELSE
                                        (1371)     BitSetI2CHW_CFG ( I2C_STOPIE )
                                        (1372)     ENDIF
                                        (1373) ENDIF
                                        (1374) ;******************************************************************************************
                                        (1375) ;;; ACK ADDRESS FOR SLAVE WRITE (STATE DATA aw);;;
                                        (1376) ;******************************************************************************************
                                        (1377) IF DEBUG_STATE
                                        (1378)    mov A, 'a'
                                        (1379)    lcall TX8_1_PutChar
                                        (1380)    mov A, 'w'
                                        (1381)    lcall TX8_1_PutChar
                                        (1382)    mov A, 0x2c
                                        (1383)    lcall TX8_1_PutChar
                                        (1384) ENDIF
                                        (1385) IF SNIFF_DATA
                                        (1386)    mov A, reg[I2CHW_DR]
                                        (1387)    lcall TX8_1_PutSHexByte
                                        (1388)    mov A, 0x2c
                                        (1389)    lcall TX8_1_PutChar
                                        (1390) ENDIF
                                        (1391) 
                                        (1392) 
                                        (1393) ;
                                        (1394) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (1395) ;
                                        (1396)     SetI2CHW_SCR ( I2C_ACKOUT )
                                        (1397) 
                                        (1398) 
                                        (1399) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1400)     REG_RESTORE IDX_PP
                                        (1401) ENDIF
069A: 20       POP   X                  (1402)     pop X
069B: 18       POP   A                  (1403)     pop A
069C: 7E       RETI                     
                                        (1404)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1405)     I2CHW_SERVICE_RETURN
                                        (1406) 
                                        (1407) ;********************************************************
                                        (1408) ; Look to see if the address is us or someone else
                                        (1409) ; use the carry flag to identify a READ or WRITE address
                                        (1410) ;********************************************************
                                        (1411) I2C_EvaluateADDRIN:
069D: 51 09    MOV   A,[0x9]            (1412)     mov A, [I2CHW_SlaveStatus]
069F: 21 30    AND   A,0x30             (1413)     and A, (I2CHW_WR_NOERR | I2CHW_WR_OVERFLOW)
06A1: A0 07    JZ    0x06A9             (1414)     jz  NewADDRNotSet                                        ;set new addr only if previous data appears to be in buffer
06A3: 2E 09 40 OR    [0x9],0x40         (1415)     or  [I2CHW_SlaveStatus], I2CHW_WR_COMPLETE               ;Same bit as I2CHW_ISR_NEW_ADDR
06A6: 41 D6 EF AND   REG[0xD6],0xEF     
                                        (1416)                                                              ;SET WR_COMPL bit if it appears there was write taking place just previous
                                        (1417)                                                              ;to this new address by looking at the status bits
                                        (1418) 
                                        (1419) 
                                        (1420) IF I2CHW_POLLED_PROCESS						                                ;if a new addr was received it's OK to terminate stop detection
                                        (1421)     and [I2CHW_Poll_Status], ~I2C_WRITE_STARTED              ;used to determine the end of a Master write to a slave.
                                        (1422) ELSE													                                            ;A REPEAT START could have terminated the transaction without a STOP
                                        (1423)     BitClrI2CHW_CFG I2C_STOPIE
                                        (1424) ENDIF
                                        (1425)     
                                        (1426) 
                                        (1427) NewADDRNotSet:                                               ;use as a way to tag the end of a master write to slave
                                        (1428) 
                                        (1429) ;@PSoC_UserCode_BODY8@ (Do not change this line.)
                                        (1430) ;---------------------------------------------------
                                        (1431) ; Insert your custom code below this banner
                                        (1432) ;---------------------------------------------------
                                        (1433) ;
                                        (1434) ; User could modify this section to allow the I2C routine
                                        (1435) ; to respond to multiple addresses, memory based soft addresses,
                                        (1436) ; I/O pin based addresses etc.
                                        (1437) ;
                                        (1438) 
06A9: 5D D8    MOV   A,REG[0xD8]        (1439)     mov A, reg[I2CHW_DR]
06AB: 70 F9    AND   F,0xF9             (1440)     and F, 0xF9                                              ;clear Carry (C) AND Zero (Z) in Flag register
06AD: 6D       RRC   A                  (1441)     rrc A                                                    ;carry now holds bit 0 (r/~w) from addr byte
                                        (1442) IF (I2CHW_AUTO_ADDR_CHECK^1)   ;; for CY8C28X45 chip: skip address comparison and NACK sending stage-hardware will do this for us  if AutoAddressCompare feature is enabled.
                                        (1443)                                           ;; The code in this pre-compiler directive will be executed for all chips except CY8C28X45.
06AE: 31 20    XOR   A,0x20             (1444)     xor A,  I2CHW_SLAVE_ADDR                                 ;for an equate
06B0: B0 3D    JNZ   0x06EE             (1445)     jnz I2C_Terminate
                                        (1446) ENDIF
06B2: 2E 01 80 OR    [0x1],0x80         (1447)     or [I2CHW_bStatus], I2CHW_ISR_ACTIVE
                                        (1448) 
                                        (1449) 
                                        (1450) ;********************************************************
                                        (1451) ; End user I2C Buffered WRITE (to RAM) Customization
                                        (1452) ;********************************************************
                                        (1453) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (1454) 
                                        (1455) I2CHW_send_ack:                                              ;slave send address ack
                                        (1456) 
                                        (1457) ;OK so the addresses were the same was it a read (c=1) or a write (c=0)
06B5: DF DE    JNC   0x0694             (1458)     jnc I2C_AckAddr_RXdata                                   ;(Master Write/Slave Receive) for this case we receive data and ack it
                                        (1459) 
                                        (1460) ;********************************************************
                                        (1461) ;Master Read (Master Read/Slave Transmit) Ack the address too.
                                        (1462) ;for this case the master has just sent us OUR read address which must be Ack'ed and will
                                        (1463) ;subsequently be reading from us (which the master will Ack.  So for the first bit we must
                                        (1464) ; set the I2C_TX AND the ACK bits in the I2C_SCR (first byte only)
                                        (1465) ; THEN we'll just be reading the ACK from the master as it reads our data
                                        (1466) ;********************************************************
                                        (1467) IF DEBUG_STATE
                                        (1468)    mov A, 'a'
                                        (1469)    lcall TX8_1_PutChar
                                        (1470)    mov A, 'r'
                                        (1471)    lcall TX8_1_PutChar
                                        (1472)    mov A, 0x2c
                                        (1473)    lcall TX8_1_PutChar
                                        (1474) ENDIF
                                        (1475) IF SNIFF_DATA
                                        (1476)    mov A, reg[I2CHW_DR]
                                        (1477)    lcall TX8_1_PutSHexByte
                                        (1478)    mov A, 0x2c
                                        (1479)    lcall TX8_1_PutChar
                                        (1480) ENDIF
                                        (1481) 
06B7: 26 09 FB AND   [0x9],0xFB         (1482)     and [I2CHW_SlaveStatus], ~I2CHW_RD_COMPLETE              ;Master will NAK us at the end of transaction
06BA: 50 14    MOV   A,0x14             (1483)     mov A, (I2C_ACKOUT | I2C_TX)
06BC: 08       PUSH  A                  (1484)     push A
                                        (1485) 
                                        (1486) ;
                                        (1487) ;MASTER is READING FROM SLAVE (ram or flash buffer)
                                        (1488) ;
                                        (1489) ;;code snipped from old SW I2C below
                                        (1490) 
                                        (1491) I2C_ObtainReadData:
                                        (1492) 
                                        (1493) ;********************************************************
                                        (1494) ; here we need to get the next data to output (master-read)
                                        (1495) ; also set the status byte for use on exit
                                        (1496) ;********************************************************
                                        (1497) IF I2CHW_READ_FLASH
                                        (1498) ;@PSoC_UserCode_BODY5@ (Do not change this line.)
                                        (1499) ;---------------------------------------------------
                                        (1500) ; Insert your custom code below this banner
                                        (1501) ; User flash read customization could take place within
                                        (1502) ; this area
                                        (1503) ;---------------------------------------------------
                                        (1504)     tst  [I2CHW_SlaveStatus],I2CHW_READFLASH
                                        (1505)     jz   ReadRamData
                                        (1506) 
                                        (1507) ;
                                        (1508) ;get the data
                                        (1509) ;
                                        (1510)     mov  X, [pI2CHW_SlaveRead_BufLO]
                                        (1511)     mov  A, [pI2CHW_SlaveRead_BufHI]
                                        (1512)     romx
                                        (1513)     mov  reg[I2CHW_DR],A
                                        (1514)     dec  [I2CHW_SlaveRead_Count]                             ;calculate addr lsb
                                        (1515)     jnc  SlaveNoDecHighCount
                                        (1516)     dec  [I2CHW_SlaveRead_CountHI]
                                        (1517)     jc   FlashRdOverflow
                                        (1518) 
                                        (1519) SlaveNoDecHighCount:
                                        (1520) 
                                        (1521)     inc  [pI2CHW_SlaveRead_BufLO]                            ;set the next flash address to read
                                        (1522)     jnc  SlaveNoIncHiAddr
                                        (1523)     inc  [pI2CHW_SlaveRead_BufHI]
                                        (1524) SlaveNoIncHiAddr:
                                        (1525)     jmp   I2CNormalRead
                                        (1526) 
                                        (1527) FlashRdOverflow:
                                        (1528) ;deal with the over flow condition by re-sending last data byte (dec the low order addr byte)
                                        (1529) 
                                        (1530)     or    [I2CHW_SlaveStatus], I2CHW_RD_OVERFLOW
                                        (1531)     and   [I2CHW_SlaveStatus], ~I2CHW_RD_NOERR
                                        (1532) ;set count back to 0
                                        (1533)     mov   [I2CHW_SlaveRead_CountHI], 0                       ;functionally the same as incrementing ffff and less instructions
                                        (1534)     mov   [I2CHW_SlaveRead_Count], 0
                                        (1535)     jmp   I2CNormalRead				 
                                        (1536) ;---------------------------------------------------
                                        (1537) ; Insert your custom code above this banner
                                        (1538) ; END User flash read customization
                                        (1539) ;---------------------------------------------------
                                        (1540) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (1541) 
                                        (1542) ENDIF
                                        (1543) 
                                        (1544) ;@PSoC_UserCode_BODY6@ (Do not change this line.)
                                        (1545) ;---------------------------------------------------
                                        (1546) ; Insert your custom code below this banner
                                        (1547) ;---------------------------------------------------
                                        (1548) ; By replacing the section from here down to the next block
                                        (1549) ; a user could process data for a custom I2C READ application
                                        (1550) ;********************************************************
                                        (1551) ReadRamData:
                                        (1552) ;read the current data byte
                                        (1553) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1554)     mov   A, [pI2CHW_SlaveRead_BufHI]
                                        (1555) ENDIF
                                        (1556)     RAM_SETPAGE_IDX A
06BD: 58 0C    MOV   X,[0xC]            (1557)     mov   X, [pI2CHW_SlaveRead_BufLO]
                                        (1558)     RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
06BF: 52 00    MOV   A,[X+0]            (1559)     mov   A, [X]
                                        (1560)     RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
06C1: 60 D8    MOV   REG[0xD8],A        (1561)     mov   reg[I2CHW_DR], A
06C3: 7A 0E    DEC   [0xE]              (1562)     dec   [I2CHW_SlaveRead_Count]
06C5: C0 05    JC    0x06CB             (1563)     jc    I2CHW_readOverflow
06C7: 76 0C    INC   [0xC]              (1564)     inc   [pI2CHW_SlaveRead_BufLO]
06C9: 80 09    JMP   0x06D3             (1565)     jmp   I2CNormalRead
                                        (1566) ;
                                        (1567) ;ram read overflow detected here, just re-send the last location in the buffer
                                        (1568) ;
                                        (1569) I2CHW_readOverflow:
06CB: 2E 09 02 OR    [0x9],0x2          (1570)     or    [I2CHW_SlaveStatus], I2CHW_RD_OVERFLOW
06CE: 26 09 FE AND   [0x9],0xFE         (1571)     and   [I2CHW_SlaveStatus], ~I2CHW_RD_NOERR
06D1: 76 0E    INC   [0xE]              (1572)     inc   [I2CHW_SlaveRead_Count]                            ; set back to zero
                                        (1573) 
                                        (1574) ;********************************************************
                                        (1575) ; End user I2C READ customization section
                                        (1576) ;********************************************************
                                        (1577) ; Insert your custom code above this banner
                                        (1578) ;---------------------------------------------------
                                        (1579) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (1580) 
                                        (1581) 
                                        (1582) I2CNormalRead:
                                        (1583) 
                                        (1584) ;******************************************************************************************
                                        (1585) ;;; MASTER READ (SLAVE TRANSMITTING DATA) (STATE DATA r);;;
                                        (1586) ;******************************************************************************************
                                        (1587) IF DEBUG_STATE
                                        (1588)    mov A, 'r'
                                        (1589)    lcall TX8_1_PutChar
                                        (1590)    mov A, 0x2c
                                        (1591)    lcall TX8_1_PutChar
                                        (1592) ENDIF
                                        (1593) IF SNIFF_DATA
                                        (1594)    mov A, reg[I2CHW_DR]
                                        (1595)    lcall TX8_1_PutSHexByte
                                        (1596)    mov A, 0x2c
                                        (1597)    lcall TX8_1_PutChar
                                        (1598) ENDIF
                                        (1599) ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                        (1600) ;and place there based on whether or not the previous transmission was our I2C address.
06D3: 18       POP   A                  (1601)     pop A
06D4: 60 D7    MOV   REG[0xD7],A        
                                        (1602) 
                                        (1603) ;
                                        (1604) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (1605) ;
                                        (1606)     SetI2CHW_SCR A                                           ;set read bit as (bit0) and addr bit (bit7)in the I2C_SCR
                                        (1607) 
                                        (1608) 
                                        (1609) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1610)     REG_RESTORE IDX_PP
                                        (1611) ENDIF
06D6: 20       POP   X                  (1612)     pop X
06D7: 18       POP   A                  (1613)     pop A
06D8: 7E       RETI                     
                                        (1614)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1615)     I2CHW_SERVICE_RETURN                                                       ;return and wait for the next interrupt (on data)
                                        (1616) 
                                        (1617) ; 1. If NAK received from Master, then clear the ISR_ACTIVE flag in bStatus register, set
                                        (1618) ;    the RD_NO_ERR and RD_COMPLETE flags in SlaveStatus register and wait for the next 
                                        (1619) ;    address to be received.
                                        (1620) ; 2. If ACK received from Master, then transmit the next byte.
                                        (1621) I2C_EvaluateACKIN:
06D9: 49 D7 02 TST   REG[0xD7],0x2      (1622)     tst reg[I2CHW_SCR], I2C_LST_BIT
06DC: B0 06    JNZ   0x06E3             (1623)     jnz I2C_LastByteToMstr                                   ; Terminate and wait for next address
                                        (1624)     
06DE: 50 04    MOV   A,0x4              (1625)     mov A, ( I2C_TX )
06E0: 08       PUSH  A                  (1626)     push A
06E1: 8F DB    JMP   0x06BD             (1627)     jmp I2C_ObtainReadData                                   ; Send next byte to Master
                                        (1628) 
                                        (1629) I2C_LastByteToMstr:
06E3: 2E 09 01 OR    [0x9],0x1          (1630)     or  [I2CHW_SlaveStatus], I2CHW_RD_NOERR 
06E6: 2E 09 04 OR    [0x9],0x4          (1631)     or  [I2CHW_SlaveStatus], I2CHW_RD_COMPLETE
06E9: 26 01 7F AND   [0x1],0x7F         (1632) 	and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
                                        (1633) ;******************************************************************************************
                                        (1634) ;;; MASTER NAK'ED READ DATA (STATE DATA rn);;;
                                        (1635) ;******************************************************************************************
                                        (1636) IF DEBUG_STATE
                                        (1637)    mov A, 'r'
                                        (1638)    lcall TX8_1_PutChar
                                        (1639)    mov A, 'n'
                                        (1640)    lcall TX8_1_PutChar
                                        (1641)    mov A, 0x2c
                                        (1642)    lcall TX8_1_PutChar
                                        (1643) ENDIF
                                        (1644) IF SNIFF_DATA
                                        (1645)    mov A, reg[I2CHW_DR]
                                        (1646)    lcall TX8_1_PutSHexByte
                                        (1647)    mov A, 0x2c
                                        (1648)    lcall TX8_1_PutChar
                                        (1649) ENDIF
                                        (1650) IF DEBUG_STATE
                                        (1651)    lcall TX8_1_PutCRLF
                                        (1652) ENDIF
06EC: 80 01    JMP   0x06EE             (1653) jmp  I2C_TerminateSlaveRead
                                        (1654) 
                                        (1655) I2C_Terminate:
                                        (1656) ;******************************************************************************************
                                        (1657) ;;; NAK ADDRESS FOR SLAVE (STATE DATA an);;;
                                        (1658) ;******************************************************************************************
                                        (1659) IF DEBUG_STATE
                                        (1660)    mov A, 'a'
                                        (1661)    lcall TX8_1_PutChar
                                        (1662)    mov A, 'n'
                                        (1663)    lcall TX8_1_PutChar
                                        (1664)    mov A, 0x2c
                                        (1665)    lcall TX8_1_PutChar
                                        (1666) ENDIF
                                        (1667) IF SNIFF_DATA
                                        (1668)    mov A, reg[I2CHW_DR]
                                        (1669)    lcall TX8_1_PutSHexByte
                                        (1670)    mov A, 0x2c
                                        (1671)    lcall TX8_1_PutChar
                                        (1672) ENDIF
                                        (1673) I2C_TerminateSlaveRead:
06EE: 26 01 7F AND   [0x1],0x7F         (1674)     and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
06F1: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (1675) 
                                        (1676) 
                                        (1677) ;
                                        (1678) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                        (1679) ;
                                        (1680)     SetI2CHW_SCR 0                                           ;the default mode to wait for an address
                                        (1681) 
                                        (1682) 
                                        (1683) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1684)     REG_RESTORE IDX_PP
                                        (1685) ENDIF
06F4: 20       POP   X                  (1686)     pop X
06F5: 18       POP   A                  (1687)     pop A
06F6: 7E       RETI                     
                                        (1688)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1689)     I2CHW_SERVICE_RETURN
                                        (1690) 
                                        (1691) ; A Stop Condition has been detected.
                                        (1692) Slave_STOPTRAP:
                                        (1693)     ;I2C stop detected
                                        (1694) ;
                                        (1695) ; set a flag to indicate END OF TRANSMISSION
                                        (1696) ;
06F7: 2E 09 40 OR    [0x9],0x40         (1697)     or  [I2CHW_SlaveStatus], I2CHW_WR_COMPLETE               ;only SET by ISR USER must clear.
06FA: 26 01 7F AND   [0x1],0x7F         (1698)     and [I2CHW_bStatus], ~I2CHW_ISR_ACTIVE
06FD: 41 D6 EF AND   REG[0xD6],0xEF     
                                        (1699) IF I2CHW_POLLED_PROCESS
                                        (1700)     and [I2CHW_Poll_Status], ~I2C_WRITE_STARTED
                                        (1701)     jmp ExitISR
                                        (1702) ELSE
                                        (1703)     BitClrI2CHW_CFG I2C_STOPIE
0700: 49 D7 01 TST   REG[0xD7],0x1      (1704)     tst reg[I2CHW_SCR], I2C_BYTE_COMPL
                                        (1705) ;;if BYTE_COMPL is set, there's an excellent chance to lose an ISR.  Because of the way they are
                                        (1706) ;; latched into the INT_MSK.  Therefore clear the applicable bit (STOPIE) and jump directly to the 
                                        (1707) ;; top of this routing since the bus is currently stalled.  Just in case the ISR is properly latched,
                                        (1708) ;; clear the mask bit since it's is serviced manually.
0703: A0 06    JZ    0x070A             (1709)     jz ExitISR
0705: 41 DD FE AND   REG[0xDD],0xFE     (1710)     and  reg[INT_CLR3], ~0x01                                ;clear the I2C interrupt
                                        (1711) ENDIF
                                        (1712) ;******************************************************************************************
                                        (1713) ;;;  FORCING INTERRUPT REPROCESS (STATE DATA Sf);;;
                                        (1714) ;******************************************************************************************
                                        (1715) IF DEBUG_STATE
                                        (1716)    mov A, 'S'
                                        (1717)    lcall TX8_1_PutChar
                                        (1718)    mov A, 'f'
                                        (1719)    lcall TX8_1_PutChar
                                        (1720)    mov A, 0x2c
                                        (1721)    lcall TX8_1_PutChar
                                        (1722)    lcall TX8_1_PutCRLF
                                        (1723) ENDIF
0708: 8D CE    JMP   0x04D7             (1724) 	jmp Process_REENTRY
                                        (1725) 	
                                        (1726) ExitISR: 
                                        (1727) ;******************************************************************************************
                                        (1728) ;;; SLAVE NORMAL STOP (STATE DATA S);;;
                                        (1729) ;******************************************************************************************
                                        (1730) IF DEBUG_STATE
                                        (1731)    mov A, 'S'
                                        (1732)    lcall TX8_1_PutChar
                                        (1733)    mov A, 0x2c
                                        (1734)    lcall TX8_1_PutChar
                                        (1735)    lcall TX8_1_PutCRLF
                                        (1736) ENDIF
                                        (1737) 
                                        (1738) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (1739)     REG_RESTORE IDX_PP
                                        (1740) ENDIF
070A: 20       POP   X                  (1741)     pop X
070B: 18       POP   A                  (1742)     pop A
070C: 7E       RETI                     
                                        (1743)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
                                        (1744)     I2CHW_SERVICE_RETURN
                                        (1745) 
                                        (1746) ENDIF
                                        (1747) 
                                        (1748) ; end of file I2CHWINT.asm
FILE: lib\i2chwmms.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: I2CHWCommon.asm
                                        (0004) ;;  Version: 1.90, Updated on 2012/9/21 at 11:59:4
                                        (0005) ;;  Generated by PSoC Designer 5.3.2710
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: I2CHW Multi-Master User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API
                                        (0013) ;;        function returns. Even though these registers may be preserved now,
                                        (0014) ;;        there is no guarantee they will be preserved in future releases.
                                        (0015) ;;-----------------------------------------------------------------------------
                                        (0016) ;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0017) ;;*****************************************************************************
                                        (0018) ;;*****************************************************************************
                                        (0019) 
                                        (0020) include "m8c.inc"
                                        (0021) include "memory.inc"
                                        (0022) include "I2CHWCommon.inc"
                                        (0023) include "I2CHWMMS.inc"
                                        (0024) include "I2CHWMstr.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ; include instance specific register definitions
                                        (0028) ;-----------------------------------------------
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) ;-------------------------------------------------------------------
                                        (0034) ;  Declare the functions global for both assembler and C compiler.
                                        (0035) ;
                                        (0036) ;  Note that there are two names for each API. First name is
                                        (0037) ;  assembler reference. Name with underscore is name refence for
                                        (0038) ;  C compiler.  Calling function in C source code does not require
                                        (0039) ;  the underscore.
                                        (0040) ;-------------------------------------------------------------------
                                        (0041) 
                                        (0042) export    I2CHW_InitMasterWrite
                                        (0043) export   _I2CHW_InitMasterWrite
                                        (0044) export    I2CHW_InitMasterRamRead
                                        (0045) export   _I2CHW_InitMasterRamRead
                                        (0046) export    I2CHW_InitMasterFlashRead
                                        (0047) export   _I2CHW_InitMasterFlashRead
                                        (0048) export    I2CHW_bReadMasterStatus
                                        (0049) export   _I2CHW_bReadMasterStatus
                                        (0050) export    I2CHW_ClrMasterRdStatus
                                        (0051) export   _I2CHW_ClrMasterRdStatus
                                        (0052) export    I2CHW_ClrMasterWrStatus
                                        (0053) export   _I2CHW_ClrMasterWrStatus
                                        (0054) export    I2CHW_bReadBusStatus
                                        (0055) export   _I2CHW_bReadBusStatus
                                        (0056) 
                                        (0057) IF I2CHW_SLAVE_OPTION
                                        (0058) 
                                        (0059) export    I2CHW_InitSlaveWrite
                                        (0060) export   _I2CHW_InitSlaveWrite
                                        (0061) export    I2CHW_InitSlaveRamRead
                                        (0062) export   _I2CHW_InitSlaveRamRead
                                        (0063) export    I2CHW_InitSlaveFlashRead
                                        (0064) export   _I2CHW_InitSlaveFlashRead
                                        (0065) export    I2CHW_bReadSlaveStatus
                                        (0066) export   _I2CHW_bReadSlaveStatus
                                        (0067) export    I2CHW_ClrSlaveRdStatus
                                        (0068) export   _I2CHW_ClrSlaveRdStatus
                                        (0069) export    I2CHW_ClrSlaveWrStatus
                                        (0070) export   _I2CHW_ClrSlaveWrStatus
                                        (0071) 
                                        (0072) ENDIF
                                        (0073) 
                                        (0074) AREA UserModules (ROM, REL)
                                        (0075) 
                                        (0076) .SECTION
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: I2CHW_InitMasterWrite
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Initializes a data buffer pointer for the Master to use to deposit data
                                        (0082) ;     Typically used when the MASTER READS data from a SLAVE
                                        (0083) ;     Function also zeroes the value of a count byte for the same buffer.
                                        (0084) ;
                                        (0085) ;-----------------------------------------------------------------------------
                                        (0086) ;
                                        (0087) ;  ARGUMENTS:  [SP-5]   -- count of bytes to write
                                        (0088) ;              [SP-4]   -- Hi order part of address Wrbuf
                                        (0089) ;              [SP-3]   -- Low order part of the address Wrbuf 
                                        (0090) ;
                                        (0091) ;  RETURNS:  none
                                        (0092) ;
                                        (0093) ;  SIDE EFFECTS:
                                        (0094) ;    The A and X registers may be modified by this or future implementations
                                        (0095) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0096) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0097) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0098) ;    functions.
                                        (0099) ;          
                                        (0100) ;    Currently only the page pointer registers listed below are modified: 
                                        (0101) ;          CUR_PP
                                        (0102) ;
                                        (0103) ;  THEORY of OPERATION or PROCEDURE:
                                        (0104) ;     The C compiler will always place a 0 (the upper order byte of the address pointer) in
                                        (0105) ;     the accumulator.  X register is the low order pointer.
                                        (0106) ;     IF a one byte buffer is established, set a flag to NAK the first written data byte.
                                        (0107) ;
                                        (0108) 
                                        (0109)  I2CHW_InitMasterWrite:
                                        (0110) _I2CHW_InitMasterWrite:
                                        (0111) 
                                        (0112) WrCnt:   equ -5
                                        (0113) WrBufHi: equ -4
                                        (0114) WrBufLo: equ -3
                                        (0115) 
                                        (0116)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0117)    RAM_PROLOGUE RAM_USE_CLASS_2
070D: 10       PUSH  X                  (0118)    push  X
070E: 4F       MOV   X,SP               (0119)    mov   X, SP
070F: 79       DEC   X                  (0120)    dec   X                                                           ;set up the pointer for correct param access
0710: 08       PUSH  A                  (0121)    push  A
0711: 5D DE    MOV   A,REG[0xDE]        (0122)    mov   A, reg[I2CHW_INT_REG]
0713: 08       PUSH  A                  (0123)    push  A                                                           ;preserve flags prior to disabling int
0714: 41 DE FE AND   REG[0xDE],0xFE     
                                        (0124)    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
                                        (0125) 
                                        (0126)    RAM_SETPAGE_CUR >I2CHW_bStatus						                              ;Set the Page Pointer for LMM
0717: 26 04 7F AND   [0x4],0x7F         (0127)    and    [I2CHW_MasterStatus], ~fMULTIMASTER_NAK_NEXT_WR                         ;reset the nak-next-written-byte flag.
                                        (0128) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0129)    mov   A, [X + WrBufHi]                                            ;move wrbuf addr to A
                                        (0130)    mov   [pI2CHW_MasterWrite_BufHI], A
                                        (0131) ENDIF
071A: 52 FD    MOV   A,[X-3]            (0132)    mov   A, [X + WrBufLo]                                                      ;move wrbuf addr to A
071C: 53 05    MOV   [0x5],A            (0133)    mov   [pI2CHW_MasterWrite_BufLO], A
071E: 52 FB    MOV   A,[X-5]            (0134)    mov   A, [X + WrCnt]                                              ;move Write_count to A
0720: 53 06    MOV   [0x6],A            (0135)    mov   [I2CHW_MasterWrite_Count], A
0722: 39 01    CMP   A,0x1              (0136)    cmp   A, 01                                                       ;if data buffer is one byte long or less
0724: A0 08    JZ    0x072D             (0137)    jz    I2CHW_SetNak
0726: C0 06    JC    0x072D             (0138)    jc    I2CHW_SetNak
0728: 26 04 8F AND   [0x4],0x8F         (0139)    and   [I2CHW_MasterStatus], ~0x70                                 ;clear the 0x10, 0x20 (Write status bits)
072B: 80 09    JMP   0x0735             (0140)    jmp   I2Cs_1_ResetFlgs
                                        (0141) 
                                        (0142) I2CHW_SetNak:
072D: 2E 04 80 OR    [0x4],0x80         (0143)    or    [I2CHW_MasterStatus], fMULTIMASTER_NAK_NEXT_WR                           ;set the nak-next-written-byte flag.
0730: 26 04 8F AND   [0x4],0x8F         (0144)    and   [I2CHW_MasterStatus], ~0x70                                 ; clear the 0x10, 0x20 (Write status bits)
0733: 80 01    JMP   0x0735             (0145)    jmp   I2Cs_1_ResetFlgs
                                        (0146) 
                                        (0147) I2Cs_1_ResetFlgs:
0735: 18       POP   A                  (0148)    pop A
0736: 21 01    AND   A,0x1              (0149)    and A, I2CHW_INT_MASK                                                ; Only enable if it was previously enabled
0738: A0 04    JZ    0x073D             (0150)    jz  . + 5
073A: 43 DE 01 OR    REG[0xDE],0x1      
                                        (0151)    M8C_EnableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
073D: 18       POP   A                  (0152)    pop A
073E: 20       POP   X                  (0153)     pop X
                                        (0154) 
                                        (0155)     RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0156)     RAM_EPILOGUE RAM_USE_CLASS_2
073F: 7F       RET                      (0157)    ret
                                        (0158) 
                                        (0159) .ENDSECTION
                                        (0160) 
                                        (0161) .SECTION
                                        (0162) ;-----------------------------------------------------------------------------
                                        (0163) ;  FUNCTION NAME: I2CHW_InitMasterRamRead
                                        (0164) ;
                                        (0165) ;  DESCRIPTION:
                                        (0166) ;     Initializes a data buffer pointer for the Master to use to retrieve data from,
                                        (0167) ;     and zeroes the value of a count byte for the same buffer.
                                        (0168) ;     Typically used when the MASTER WRITES data to a SLAVE
                                        (0169) ;
                                        (0170) ;-----------------------------------------------------------------------------
                                        (0171) ;
                                        (0172) ;  ARGUMENTS:  [SP-5]  -- count of bytes to read
                                        (0173) ;              [SP-4]  -- Hi order part of addr to ReadBuf
                                        (0174) ;              [SP-3]  -- Low order part of the address to ReadBuf
                                        (0175) ;
                                        (0176) ;  RETURNS: none
                                        (0177) ;
                                        (0178) ;  SIDE EFFECTS:
                                        (0179) ;    The A and X registers may be modified by this or future implementations
                                        (0180) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0181) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0182) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0183) ;    functions.
                                        (0184) ;          
                                        (0185) ;    Currently only the page pointer registers listed below are modified: 
                                        (0186) ;          CUR_PP
                                        (0187) ;
                                        (0188) 
                                        (0189)  I2CHW_InitMasterRamRead:
                                        (0190) _I2CHW_InitMasterRamRead:
                                        (0191) 
                                        (0192) RdCnt:     equ   -5
                                        (0193) RdBufHi:   equ   -4
                                        (0194) RdBufLo:   equ   -3
                                        (0195) 
                                        (0196)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0197)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0198)    RAM_SETPAGE_CUR >I2CHW_MasterRead_Count
0740: 10       PUSH  X                  (0199)    push  X
0741: 4F       MOV   X,SP               (0200)    mov   X, SP
0742: 79       DEC   X                  (0201)    dec   X                                                           ;set up the pointer for correct param access
0743: 08       PUSH  A                  (0202)    push  A
0744: 5D DE    MOV   A,REG[0xDE]        (0203)    mov   A, reg[I2CHW_INT_REG]
0746: 08       PUSH  A                  (0204)    push  A                                                           ;preserve flags prior to disabling int
0747: 41 DE FE AND   REG[0xDE],0xFE     
                                        (0205)    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
                                        (0206) 
                                        (0207) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0208)    mov   A, [X + RdBufHi]                                            ;move wrbuf addr to A
                                        (0209)    mov   [pI2CHW_MasterRead_BufHI], A
                                        (0210) ENDIF
074A: 52 FD    MOV   A,[X-3]            (0211)    mov   A, [X + RdBufLo]                                            ; move rdbuf addr to A
074C: 53 07    MOV   [0x7],A            (0212)    mov   [pI2CHW_MasterRead_BufLO], A
074E: 52 FB    MOV   A,[X-5]            (0213)    mov   A, [X + RdCnt]                                              ; move RamRead_count to A
0750: 53 08    MOV   [0x8],A            (0214)    mov   [I2CHW_MasterRead_Count], A
0752: 7A 08    DEC   [0x8]              (0215)    dec   [I2CHW_MasterRead_Count]                                        ; since we decrement through zero...
0754: 26 04 70 AND   [0x4],0x70         (0216)    and   [I2CHW_MasterStatus], ~0x8f                                 ; clear the lower 4 (read status bits) & fMULTIMASTER_NAK_NEXT_WR
                                        (0217) 
0757: 18       POP   A                  (0218)    pop A
0758: 21 01    AND   A,0x1              (0219)    and A, I2CHW_INT_MASK                                               ; Only enable if it was previously enabled
075A: A0 04    JZ    0x075F             (0220)    jz  . + 5
075C: 43 DE 01 OR    REG[0xDE],0x1      
                                        (0221)    M8C_EnableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
075F: 18       POP   A                  (0222)    pop A
0760: 20       POP   X                  (0223)    pop X
                                        (0224) 
                                        (0225)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0226)    RAM_EPILOGUE RAM_USE_CLASS_2
0761: 7F       RET                      (0227)    ret
                                        (0228) 
                                        (0229) .ENDSECTION
                                        (0230) 
                                        (0231) .SECTION
                                        (0232) ;-----------------------------------------------------------------------------
                                        (0233) ;  FUNCTION NAME: I2CHW_InitMasterFlashRead
                                        (0234) ;
                                        (0235) ;  DESCRIPTION:
                                        (0236) ;     Initializes a flash data buffer pointer for the Master to use to retrieve
                                        (0237) ;     data from, and zeroes the value of a count byte for the same buffer.
                                        (0238) ;     Typically used to set up a buffer for the Master to READ to WRITE data to a SLAVE.
                                        (0239) ;
                                        (0240) ;-----------------------------------------------------------------------------
                                        (0241) ;
                                        (0242) ;  ARGUMENTS:  [SP-6]   -- Hi order part of flash Read count
                                        (0243) ;              [SP-5]   -- Low order part of flashRead counts
                                        (0244) ;              [SP-4]   -- Hi order part of the flash buf address
                                        (0245) ;              [SP-3]   -- Lo order part of flash buf address
                                        (0246) ;
                                        (0247) ;  RETURNS:	 None
                                        (0248) ;
                                        (0249) ;  SIDE EFFECTS:
                                        (0250) ;    The A and X registers may be modified by this or future implementations
                                        (0251) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0252) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0253) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0254) ;    functions.
                                        (0255) ;          
                                        (0256) ;    Currently only the page pointer registers listed below are modified: 
                                        (0257) ;          CUR_PP
                                        (0258) ;
                                        (0259)  I2CHW_InitMasterFlashRead:
                                        (0260) _I2CHW_InitMasterFlashRead:
                                        (0261) 
                                        (0262) FlRdCntHI:     equ   -6
                                        (0263) FlRdCntLO:     equ   -5
                                        (0264) FlBufAdrHI:    equ   -4
                                        (0265) FlBufAdrLO:    equ   -3
                                        (0266) 
                                        (0267) IF I2CHW_READ_FLASH
                                        (0268)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0269)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0270)    RAM_SETPAGE_CUR >pI2CHW_MasterRead_BufLO   
                                        (0271)    push  X
                                        (0272)    mov   X, SP
                                        (0273)    dec   X                                                           ;set up the pointer for correct param access
                                        (0274)    push  A
                                        (0275)    mov   A, reg[I2CHW_INT_REG]
                                        (0276)    push  A                                                           ;preserve flags prior to disabling int
                                        (0277)    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
                                        (0278) 
                                        (0279)    mov   A, [X + FlBufAdrLO]                                         ; move flrdbuf LOaddr to A
                                        (0280)    mov   [pI2CHW_MasterRead_BufLO], A
                                        (0281)    mov   A, [X + FlBufAdrHI]                                         ; move flrdbuf HIaddr to A
                                        (0282)    mov   [pI2CHW_MasterRead_BufHI], A
                                        (0283)    mov   A, [X + FlRdCntLO]                                          ; move flrdbuf LOcount to A
                                        (0284)    mov   [I2CHW_MasterRead_Count], A
                                        (0285)    mov   A, [X + FlRdCntHI]                                          ; move flrdbuf HIcount to A
                                        (0286)    mov   [I2CHW_MasterRead_CountHI], A
                                        (0287) 
                                        (0288)    dec   [I2CHW_MasterRead_Count]                                        ; since this will count throu zero
                                        (0289)    jnc    . + 4                                                                               ; only Read_CountHI if Read_Count rolled to 0xff
                                        (0290)    dec   [I2CHW_MasterRead_CountHI]
                                        (0291) 
                                        (0292)    and   [I2CHW_MasterStatus], ~0x87                                 ; clear the lower 3 (read status bits)& fMULTIMASTER_NAK_NEXT_WR
                                        (0293)    or    [I2CHW_MasterStatus],I2CHW_READFLASH                        ; set the flash status bit
                                        (0294) 
                                        (0295)    pop A
                                        (0296)    and A, I2CHW_INT_MASK                                               ; Only enable if it was previously enabled
                                        (0297)    jz  . + 5
                                        (0298)    M8C_EnableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
                                        (0299)    pop A
                                        (0300)    pop X
                                        (0301)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0302)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0303) ENDIF
0762: 7F       RET                      (0304)    ret
                                        (0305) 
                                        (0306) .ENDSECTION
                                        (0307) 
                                        (0308) .SECTION
                                        (0309) ;-----------------------------------------------------------------------------
                                        (0310) ;  FUNCTION NAME: I2CHW_bReadBusStatus
                                        (0311) ;
                                        (0312) ;  DESCRIPTION:
                                        (0313) ;     Returns the Status bits in the bStatus Register
                                        (0314) ;
                                        (0315) ;-----------------------------------------------------------------------------
                                        (0316) ;
                                        (0317) ;  ARGUMENTS:
                                        (0318) ;
                                        (0319) ;  RETURNS:
                                        (0320) ;     BYTE  bStatus -  Bus status data.  Use the following defined bits
                                        (0321) ;     returned in A.
                                        (0322) ;       I2CHW_RepStart:                     equ  0x01
                                        (0323) ;       I2CHW_NoStop:                       equ  0x02
                                        (0324) ;       I2CHW_BUS_BUSY:                     equ  0x04
                                        (0325) ;       I2CHW_LOST_ARB:                     equ  0x08
                                        (0326) ;       I2CHW_BUS_ERROR:                    equ  0x10
                                        (0327) ;       I2CHW_SLAVE_NAK:                    equ  0x20
                                        (0328) ;       I2CHW_ERROR                         equ  0x40
                                        (0329) ;       I2CHW_ISR_ACTIVE:                   equ  0x80
                                        (0330) ;
                                        (0331) ;  SIDE EFFECTS:
                                        (0332) ;    The A and X registers may be modified by this or future implementations
                                        (0333) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0334) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0335) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0336) ;    functions.
                                        (0337) ;          
                                        (0338) ;  THEORY of OPERATION or PROCEDURE:
                                        (0339) ;     Read the Bus Status register.
                                        (0340) ;
                                        (0341) 
                                        (0342)  I2CHW_bReadBusStatus:
                                        (0343) _I2CHW_bReadBusStatus:
                                        (0344)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0345)    RAM_SETPAGE_CUR >I2CHW_bStatus				                      ;Set the Page Pointer for LMM
0763: 51 01    MOV   A,[0x1]            (0346)    mov   A, [I2CHW_bStatus]                      ;return the status in A
                                        (0347)    RAM_EPILOGUE RAM_USE_CLASS_4
0765: 7F       RET                      (0348)    ret
                                        (0349) 
                                        (0350) .ENDSECTION
                                        (0351) 
                                        (0352) .SECTION
                                        (0353) ;-----------------------------------------------------------------------------
                                        (0354) ;  FUNCTION NAME: I2CHW_ReadMasterStatus
                                        (0355) ;
                                        (0356) ;  DESCRIPTION:
                                        (0357) ;     Returns the Status bits in the MasterStatus Register
                                        (0358) ;
                                        (0359) ;-----------------------------------------------------------------------------
                                        (0360) ;
                                        (0361) ;  ARGUMENTS:
                                        (0362) ;
                                        (0363) ;  RETURNS:
                                        (0364) ;     BYTE  MasterStatus -  Master status data.  Use the following defined bits
                                        (0365) ;     returned in A.
                                        (0366) ;         I2CHW_RD_NOERR:                   equ 1
                                        (0367) ;         I2CHW_RD_OVERFLOW:                equ 2
                                        (0368) ;         I2CHW_RD_INCOMPLETE:              equ 4
                                        (0369) ;         I2CHW_READFLASH:                  equ 8
                                        (0370) ;         I2CHW_WR_NOERR:                   equ 10h
                                        (0371) ;         I2CHW_WR_OVERFLOW:                equ 20h
                                        (0372) ;         I2CHW_WR_COMPLETE:                equ 40h
                                        (0373) ;         I2CHW_ISR_ACTIVE:                 equ 80h
                                        (0374) ;
                                        (0375) ;  SIDE EFFECTS:
                                        (0376) ;    The A and X registers may be modified by this or future implementations
                                        (0377) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0378) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0379) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0380) ;    functions.
                                        (0381) ;          
                                        (0382) ;  THEORY of OPERATION or PROCEDURE:
                                        (0383) ;     Read the status and control register.
                                        (0384) ;
                                        (0385) 
                                        (0386)  I2CHW_bReadMasterStatus:
                                        (0387) _I2CHW_bReadMasterStatus:
                                        (0388)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0389)    RAM_SETPAGE_CUR >I2CHW_bStatus				                      ;Set the Page Pointer for LMM
0766: 51 04    MOV   A,[0x4]            (0390)    mov   A, [I2CHW_MasterStatus]                                     ;return the status in A
                                        (0391)    RAM_EPILOGUE RAM_USE_CLASS_4
0768: 7F       RET                      (0392)    ret
                                        (0393) 
                                        (0394) .ENDSECTION
                                        (0395) 
                                        (0396) 
                                        (0397) .SECTION
                                        (0398) ;-----------------------------------------------------------------------------
                                        (0399) ;  FUNCTION NAME: I2CHW_ClrMasterRdStatus
                                        (0400) ;
                                        (0401) ;  DESCRIPTION:
                                        (0402) ;     Clears the Read Status bits in the MasterStatus Register.
                                        (0403) ;     Does not affect the RAM/FLASH Read bit
                                        (0404) ;
                                        (0405) ;-----------------------------------------------------------------------------
                                        (0406) ;
                                        (0407) ;  ARGUMENTS: none
                                        (0408) ;
                                        (0409) ;  RETURNS: none
                                        (0410) ;
                                        (0411) ;  SIDE EFFECTS:
                                        (0412) ;    The A and X registers may be modified by this or future implementations
                                        (0413) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0414) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0415) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0416) ;    functions.
                                        (0417) ;          
                                        (0418)  I2CHW_ClrMasterRdStatus:
                                        (0419) _I2CHW_ClrMasterRdStatus:
                                        (0420)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0421)    RAM_SETPAGE_CUR >I2CHW_MasterStatus				                 ;Set the Page Pointer for LMM
0769: 26 04 78 AND   [0x4],0x78         (0422)    and   [I2CHW_MasterStatus], ~0x87                                 ; clear the lower 3 (read status bits) & fMULTIMASTER_NAK_NEXT_WR
                                        (0423)    RAM_EPILOGUE RAM_USE_CLASS_4
076C: 7F       RET                      (0424)    ret
                                        (0425) 
                                        (0426) .ENDSECTION
                                        (0427) 
                                        (0428) .SECTION
                                        (0429) ;-----------------------------------------------------------------------------
                                        (0430) ;  FUNCTION NAME: I2CHW_ClrMasterWrStatus
                                        (0431) ;
                                        (0432) ;  DESCRIPTION:
                                        (0433) ;     Clears the Write Status bits in the MasterStatus Register.
                                        (0434) ;     Does not affect the RAM/FLASH Read bit
                                        (0435) ;
                                        (0436) ;-----------------------------------------------------------------------------
                                        (0437) ;
                                        (0438) ;  ARGUMENTS: none
                                        (0439) ;
                                        (0440) ;  RETURNS: none
                                        (0441) ;
                                        (0442) ;  SIDE EFFECTS:
                                        (0443) ;    The A and X registers may be modified by this or future implementations
                                        (0444) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0445) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0446) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0447) ;    functions.
                                        (0448) ;          
                                        (0449)  I2CHW_ClrMasterWrStatus:
                                        (0450) _I2CHW_ClrMasterWrStatus:
                                        (0451)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0452)    RAM_SETPAGE_CUR >I2CHW_MasterStatus				                 ;Set the Page Pointer for LMM
076D: 26 04 8F AND   [0x4],0x8F         (0453)    and   [I2CHW_MasterStatus], ~0x70                                 ; clear bits 10,20 (write status bits)
                                        (0454)    RAM_EPILOGUE RAM_USE_CLASS_4
0770: 7F       RET                      (0455)    ret
                                        (0456) 
                                        (0457) .ENDSECTION
                                        (0458) 
                                        (0459) 
                                        (0460) IF I2CHW_SLAVE_OPTION
                                        (0461) 
                                        (0462) 
                                        (0463) 
                                        (0464) .SECTION
                                        (0465) ;-----------------------------------------------------------------------------
                                        (0466) ;  FUNCTION NAME: I2CHW_InitSlaveWrite
                                        (0467) ;
                                        (0468) ;  DESCRIPTION:
                                        (0469) ;     Initializes a data buffer pointer for the Slave to use to deposit data, and
                                        (0470) ;     zeroes the value of a count byte for the same buffer.
                                        (0471) ;     Typically used to initialize a buffer to deposit data if the MASTER is 
                                        (0472) ;     ADDRESSED AS A SLAVE.  
                                        (0473) ;
                                        (0474) ;-----------------------------------------------------------------------------
                                        (0475) ;
                                        (0476) ;  ARGUMENTS:  [SP-5]   -- count of bytes to write
                                        (0477) ;              [SP-4]   -- Hi order part of address Wrbuf
                                        (0478) ;              [SP-3]   -- Low order part of the address Wrbuf 
                                        (0479) ;
                                        (0480) ;  RETURNS:  none
                                        (0481) ;
                                        (0482) ;  SIDE EFFECTS:
                                        (0483) ;    The A and X registers may be modified by this or future implementations
                                        (0484) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0485) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0486) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0487) ;    functions.
                                        (0488) ;          
                                        (0489) ;    Currently only the page pointer registers listed below are modified: 
                                        (0490) ;          CUR_PP
                                        (0491) ;    
                                        (0492) ;     IF a one byte buffer is established, set a flag to NAK the first written data byte.
                                        (0493) ;
                                        (0494) 
                                        (0495)  I2CHW_InitSlaveWrite:
                                        (0496) _I2CHW_InitSlaveWrite:
                                        (0497) 
                                        (0498) SlWrCnt:   equ -5
                                        (0499) SlWrBufHi: equ -4
                                        (0500) SlWrBufLo: equ -3
                                        (0501) 
                                        (0502)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0503)    RAM_PROLOGUE RAM_USE_CLASS_2
0771: 10       PUSH  X                  (0504)    push  X
0772: 4F       MOV   X,SP               (0505)    mov   X, SP
0773: 79       DEC   X                  (0506)    dec   X                                                           ;set up the pointer for correct param access
0774: 08       PUSH  A                  (0507)    push  A
0775: 5D DE    MOV   A,REG[0xDE]        (0508)    mov   A, reg[I2CHW_INT_REG]
0777: 08       PUSH  A                  (0509)    push  A                                                             ;preserve flags prior to disabling int
0778: 41 DE FE AND   REG[0xDE],0xFE     
                                        (0510)    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
                                        (0511) 
                                        (0512)    RAM_SETPAGE_CUR >I2CHW_bStatus						                              ;Set the Page Pointer for LMM
077B: 26 09 7F AND   [0x9],0x7F         (0513)    and    [I2CHW_SlaveStatus], ~fMULTIMASTER_NAK_NEXT_WR             ;reset the nak-next-written-byte flag.
                                        (0514) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0515)    mov   A, [X + SlWrBufHi]                                          ;move wrbuf addr to A
                                        (0516)    mov   [pI2CHW_SlaveWrite_BufHI], A
                                        (0517) ENDIF
077E: 52 FD    MOV   A,[X-3]            (0518)    mov   A, [X + SlWrBufLo]                                          ;move wrbuf addr to A
0780: 53 0A    MOV   [0xA],A            (0519)    mov   [pI2CHW_SlaveWrite_BufLO], A
0782: 52 FB    MOV   A,[X-5]            (0520)    mov   A, [X + SlWrCnt]                                              ;move A to Write_count
0784: 53 0B    MOV   [0xB],A            (0521)    mov   [I2CHW_SlaveWrite_Count], A
0786: 39 01    CMP   A,0x1              (0522)    cmp   A, 01                                                         ;if data buffer is one byte long or less
0788: A0 08    JZ    0x0791             (0523)    jz    I2CHW_SetNak1
078A: C0 06    JC    0x0791             (0524)    jc    I2CHW_SetNak1
078C: 26 09 8F AND   [0x9],0x8F         (0525)    and   [I2CHW_SlaveStatus], ~0x70                                  ;clear the 0x10, 0x20 (Write status bits)
078F: 8F A5    JMP   0x0735             (0526)    jmp   I2Cs_1_ResetFlgs
                                        (0527) 
                                        (0528) I2CHW_SetNak1:
0791: 2E 09 80 OR    [0x9],0x80         (0529)    or    [I2CHW_SlaveStatus], fMULTIMASTER_NAK_NEXT_WR               ;set the nak-next-written-byte flag.
0794: 26 09 8F AND   [0x9],0x8F         (0530)    and   [I2CHW_SlaveStatus], ~0x70                                  ; clear the 0x10, 0x20 (Write status bits)
0797: 80 01    JMP   0x0799             (0531)    jmp   I2Cs_1_ResetFlgs1
                                        (0532) 
                                        (0533) I2Cs_1_ResetFlgs1:
0799: 18       POP   A                  (0534)    pop A
079A: 21 01    AND   A,0x1              (0535)    and A, I2CHW_INT_MASK                                                 ; Only enable if it was previously enabled
079C: A0 04    JZ    0x07A1             (0536)    jz  . + 5
079E: 43 DE 01 OR    REG[0xDE],0x1      
                                        (0537)    M8C_EnableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
07A1: 18       POP   A                  (0538)    pop A
07A2: 20       POP   X                  (0539)    pop X
                                        (0540)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0541)    RAM_EPILOGUE RAM_USE_CLASS_2
07A3: 7F       RET                      (0542)    ret
                                        (0543) 
                                        (0544) .ENDSECTION
                                        (0545) 
                                        (0546) .SECTION
                                        (0547) ;-----------------------------------------------------------------------------
                                        (0548) ;  FUNCTION NAME: I2CHW_InitSlaveRamRead
                                        (0549) ;
                                        (0550) ;  DESCRIPTION:
                                        (0551) ;     Initializes a data buffer pointer for the Slave to use to retrieve data from,
                                        (0552) ;     and zeroes the value of a count byte for the same buffer.
                                        (0553) ;     Typically used to set up a buffer to pull RAM data from if the MASTER is ADDRESSED
                                        (0554) ;     AS A SLAVE.
                                        (0555) ;
                                        (0556) ;-----------------------------------------------------------------------------
                                        (0557) ;
                                        (0558) ;  ARGUMENTS:  [SP-5]  -- count of bytes to read
                                        (0559) ;              [SP-4]  -- Hi order part of addr to ReadBuf
                                        (0560) ;              [SP-3]  -- Low order part of the address to ReadBuf
                                        (0561) ;
                                        (0562) ;  RETURNS: none
                                        (0563) ;
                                        (0564) ;  SIDE EFFECTS:
                                        (0565) ;    The A and X registers may be modified by this or future implementations
                                        (0566) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0567) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0568) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0569) ;    functions.
                                        (0570) ;          
                                        (0571) ;    Currently only the page pointer registers listed below are modified: 
                                        (0572) ;          CUR_PP
                                        (0573) ;
                                        (0574)  I2CHW_InitSlaveRamRead:
                                        (0575) _I2CHW_InitSlaveRamRead:
                                        (0576) 
                                        (0577) SlRdCnt:     equ   -5
                                        (0578) SlRdBufHi:   equ   -4
                                        (0579) SlRdBufLo:   equ   -3
                                        (0580) 
                                        (0581)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0582)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0583)    RAM_SETPAGE_CUR >I2CHW_SlaveRead_Count
07A4: 10       PUSH  X                  (0584)    push  X
07A5: 4F       MOV   X,SP               (0585)    mov   X, SP
07A6: 79       DEC   X                  (0586)    dec   X                                                           ;set up the pointer for correct param access
07A7: 08       PUSH  A                  (0587)    push  A
07A8: 5D DE    MOV   A,REG[0xDE]        (0588)    mov   A, reg[I2CHW_INT_REG]
07AA: 08       PUSH  A                  (0589)    push  A                                                           ;preserve flags prior to disabling int
07AB: 41 DE FE AND   REG[0xDE],0xFE     
                                        (0590)    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
                                        (0591) 
                                        (0592) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0593)    mov   A, [X + SlRdBufHi]                                          ;move wrbuf addr to A
                                        (0594)    mov   [pI2CHW_SlaveRead_BufHI], A
                                        (0595) ENDIF
07AE: 52 FD    MOV   A,[X-3]            (0596)    mov   A, [X + SlRdBufLo]                                            ; move rdbuf addr to A
07B0: 53 0C    MOV   [0xC],A            (0597)    mov   [pI2CHW_SlaveRead_BufLO], A
07B2: 52 FB    MOV   A,[X-5]            (0598)    mov   A, [X + RdCnt]                                              ; move RamRead_count to A
07B4: 53 0E    MOV   [0xE],A            (0599)    mov   [I2CHW_SlaveRead_Count], A
07B6: 7A 0E    DEC   [0xE]              (0600)    dec   [I2CHW_SlaveRead_Count]                                     ; since we decrement through zero...
07B8: 26 09 F0 AND   [0x9],0xF0         (0601)    and   [I2CHW_SlaveStatus], ~0x0f                                  ; clear the lower 4 (read status bits)
                                        (0602) 
07BB: 18       POP   A                  (0603)    pop A
07BC: 21 01    AND   A,0x1              (0604)    and A, I2CHW_INT_MASK                                                ; Only enable if it was previously enabled
07BE: A0 04    JZ    0x07C3             (0605)    jz  . + 5
07C0: 43 DE 01 OR    REG[0xDE],0x1      
                                        (0606)    M8C_EnableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
07C3: 18       POP   A                  (0607)    pop A
07C4: 20       POP   X                  (0608)    pop X
                                        (0609) 
                                        (0610)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0611)    RAM_EPILOGUE RAM_USE_CLASS_2
07C5: 7F       RET                      (0612)    ret
                                        (0613) 
                                        (0614) .ENDSECTION
                                        (0615) 
                                        (0616) .SECTION
                                        (0617) ;-----------------------------------------------------------------------------
                                        (0618) ;  FUNCTION NAME: I2CHW_InitSlaveFlashRead
                                        (0619) ;
                                        (0620) ;  DESCRIPTION:
                                        (0621) ;     Initializes a flash data buffer pointer for the Slave to use to retrieve
                                        (0622) ;     data from, and zeroes the value of a count byte for the same buffer.
                                        (0623) ;     Typically used to set up a FLASH buffer to pull data from if the MASTER is 
                                        (0624) ;     ADDRESSED AS A SLAVE
                                        (0625) ; 
                                        (0626) ;-----------------------------------------------------------------------------
                                        (0627) ;
                                        (0628) ;  ARGUMENTS:  [SP-6]   -- Hi order part of flash Read count
                                        (0629) ;              [SP-5]   -- Low order part of flashRead counts
                                        (0630) ;              [SP-4]   -- Hi order part of the flash buf address
                                        (0631) ;              [SP-3]   -- Lo order part of flash buf address
                                        (0632) ;
                                        (0633) ;  RETURNS:
                                        (0634) ;
                                        (0635) ;  SIDE EFFECTS:
                                        (0636) ;    The A and X registers may be modified by this or future implementations
                                        (0637) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0638) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0639) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0640) ;    functions.
                                        (0641) ;          
                                        (0642) ;    Currently only the page pointer registers listed below are modified: 
                                        (0643) ;          CUR_PP
                                        (0644) ;
                                        (0645) ;     A user module parameter is used to conserve code
                                        (0646) ;     if flash buffers are un-needed.  The API call is left defined and capable of returning in
                                        (0647) ;     either case
                                        (0648) ;
                                        (0649)  I2CHW_InitSlaveFlashRead:
                                        (0650) _I2CHW_InitSlaveFlashRead:
                                        (0651) 
                                        (0652) SlFlRdCntHI:     equ   -6
                                        (0653) SlFlRdCntLO:     equ   -5
                                        (0654) SlFlBufAdrHI:    equ   -4
                                        (0655) SlFlBufAdrLO:    equ   -3
                                        (0656) 
                                        (0657) IF I2CHW_READ_FLASH
                                        (0658)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0659)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0660)    RAM_SETPAGE_CUR >pI2CHW_SlaveRead_BufLO   
                                        (0661)    push  X
                                        (0662)    mov   X, SP
                                        (0663)    dec   X                                                           ;set up the pointer for correct param access
                                        (0664)    push  A
                                        (0665)    mov   A, reg[I2CHW_INT_REG]
                                        (0666)    push  A                                                           ;preserve flags prior to disabling int
                                        (0667)    M8C_DisableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
                                        (0668) 
                                        (0669)    mov   A, [X + SlFlBufAdrLO]                                       ; move flrdbuf LOaddr to A
                                        (0670)    mov   [pI2CHW_SlaveRead_BufLO], A
                                        (0671)    mov   A, [X + SlFlBufAdrHI]                                       ; move flrdbuf HIaddr to A
                                        (0672)    mov   [pI2CHW_SlaveRead_BufHI], A
                                        (0673)    mov   A, [X + SlFlRdCntLO]                                        ; move flrdbuf LOcount to A
                                        (0674)    mov   [I2CHW_SlaveRead_Count], A
                                        (0675)    mov   A, [X + SlFlRdCntHI]                                        ; move flrdbuf HIcount to A
                                        (0676)    mov   [I2CHW_SlaveRead_CountHI], A
                                        (0677) 
                                        (0678)    dec   [I2CHW_SlaveRead_Count]                                     ; since this will count throu zero
                                        (0679)    jnc    . + 4                                                                               ; only Read_CountHI if Read_Count rolled to 0xff
                                        (0680)    dec   [I2CHW_SlaveRead_CountHI]
                                        (0681) 
                                        (0682)    and   [I2CHW_SlaveStatus], ~0x07                                  ; clear the lower 3 (read status bits)
                                        (0683)    or    [I2CHW_SlaveStatus],I2CHW_READFLASH                         ; set the flash status bit
                                        (0684) 
                                        (0685)    pop A
                                        (0686)    and A, I2CHW_INT_MASK                                                ; Only enable if it was previously enabled
                                        (0687)    jz  . + 5
                                        (0688)    M8C_EnableIntMask I2CHW_INT_REG, I2CHW_INT_MASK
                                        (0689)    pop A
                                        (0690) 	pop X
                                        (0691)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0692) 	RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0693) ENDIF
07C6: 7F       RET                      (0694)    ret
                                        (0695) 
                                        (0696) .ENDSECTION
                                        (0697) 
                                        (0698) .SECTION
                                        (0699) ;-----------------------------------------------------------------------------
                                        (0700) ;  FUNCTION NAME: I2CHW_bReadSlaveStatus
                                        (0701) ;
                                        (0702) ;  DESCRIPTION:
                                        (0703) ;     Returns the Status bits in the SlaveStatus Register
                                        (0704) ;
                                        (0705) ;-----------------------------------------------------------------------------
                                        (0706) ;
                                        (0707) ;  ARGUMENTS:
                                        (0708) ;
                                        (0709) ;  RETURNS:
                                        (0710) ;     BYTE  SlaveStatus -  Slave status data.  Use the following defined bits
                                        (0711) ;     returned in A.
                                        (0712) ;         I2CHW_RD_NOERR:                   equ 1
                                        (0713) ;         I2CHW_RD_OVERFLOW:                equ 2
                                        (0714) ;         I2CHW_RD_INCOMPLETE:              equ 4
                                        (0715) ;         I2CHW_READFLASH:                  equ 8
                                        (0716) ;         I2CHW_WR_NOERR:                   equ 10h
                                        (0717) ;         I2CHW_WR_OVERFLOW:                equ 20h
                                        (0718) ;         I2CHW_WR_COMPLETE:                equ 40h
                                        (0719) ;         I2CHW_ISR_ACTIVE:                 equ 80h
                                        (0720) ;
                                        (0721) ;  SIDE EFFECTS:
                                        (0722) ;    The A and X registers may be modified by this or future implementations
                                        (0723) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0724) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0725) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0726) ;    functions.
                                        (0727) ;          
                                        (0728) ;  THEORY of OPERATION or PROCEDURE:
                                        (0729) ;     Read the Slave Status and control register.
                                        (0730) ;
                                        (0731)  I2CHW_bReadSlaveStatus:
                                        (0732) _I2CHW_bReadSlaveStatus:
                                        (0733)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0734)    RAM_SETPAGE_CUR >I2CHW_SlaveStatus				                  ;Set the Page Pointer for LMM
07C7: 51 09    MOV   A,[0x9]            (0735)    mov   A, [I2CHW_SlaveStatus]                                     ;return the status in A
                                        (0736)    RAM_EPILOGUE RAM_USE_CLASS_4
07C9: 7F       RET                      (0737)    ret
                                        (0738) 
                                        (0739) .ENDSECTION
                                        (0740) 
                                        (0741) .SECTION
                                        (0742) ;-----------------------------------------------------------------------------
                                        (0743) ;  FUNCTION NAME: I2CHW_ClrSlaveRdStatus
                                        (0744) ;
                                        (0745) ;  DESCRIPTION:
                                        (0746) ;     Clears the Read Status bits in the SlaveStatus Register.
                                        (0747) ;     Does not affect the RAM/FLASH Read bit
                                        (0748) ;
                                        (0749) ;-----------------------------------------------------------------------------
                                        (0750) ;
                                        (0751) ;  ARGUMENTS: none
                                        (0752) ;
                                        (0753) ;  RETURNS: none
                                        (0754) ;
                                        (0755) ;  SIDE EFFECTS:
                                        (0756) ;    The A and X registers may be modified by this or future implementations
                                        (0757) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0758) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0759) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0760) ;    functions.
                                        (0761) ;
                                        (0762)  I2CHW_ClrSlaveRdStatus:
                                        (0763) _I2CHW_ClrSlaveRdStatus:
                                        (0764)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0765)    RAM_SETPAGE_CUR >I2CHW_SlaveStatus				                  ;Set the Page Pointer for LMM
07CA: 26 09 F8 AND   [0x9],0xF8         (0766)    and   [I2CHW_SlaveStatus], ~0x07                                 ; clear the lower 3 (read status bits)
                                        (0767)    RAM_EPILOGUE RAM_USE_CLASS_4
07CD: 7F       RET                      (0768)    ret
                                        (0769) 
                                        (0770) .ENDSECTION
                                        (0771) 
                                        (0772) .SECTION
                                        (0773) ;-----------------------------------------------------------------------------
                                        (0774) ;  FUNCTION NAME: I2CHW_ClrSlaveWrStatus
                                        (0775) ;
                                        (0776) ;  DESCRIPTION:
                                        (0777) ;     Clears the Write Status bits in the SlaveStatus Register.
                                        (0778) ;     Does not affect the RAM/FLASH Read bit
                                        (0779) ;
                                        (0780) ;-----------------------------------------------------------------------------
                                        (0781) ;
                                        (0782) ;  ARGUMENTS: none
                                        (0783) ;
                                        (0784) ;  RETURNS: none
                                        (0785) ;
                                        (0786) ;  SIDE EFFECTS:
                                        (0787) ;    The A and X registers may be modified by this or future implementations
                                        (0788) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0789) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0790) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0791) ;    functions.
                                        (0792) ;
                                        (0793)  I2CHW_ClrSlaveWrStatus:
                                        (0794) _I2CHW_ClrSlaveWrStatus:
                                        (0795)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0796)    RAM_SETPAGE_CUR >I2CHW_SlaveStatus				                  ;Set the Page Pointer for LMM
07CE: 26 09 8F AND   [0x9],0x8F         (0797)    and   [I2CHW_SlaveStatus], ~0x70                                 ; clear bits 10,20 (write status bits)
                                        (0798)    RAM_EPILOGUE RAM_USE_CLASS_4
07D1: 7F       RET                      (0799)    ret
                                        (0800) 
                                        (0801) .ENDSECTION
                                        (0802) 
                                        (0803) ENDIF
                                        (0804) 
                                        (0805) ; End of File I2CHWCommon.asm
FILE: G:\Dropbox\Hobby\PROGRA~1\PSOCPR~1\HP03S\HP03S\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) #include <m8c.h>        // Part specific constants and macros
(0006) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0007) 
(0008) void main(void)
(0009) {
(0010) 	M8C_EnableGInt;
__UserModules_end|__text_start|_main|_main:
    07D2: 71 01    OR    F,0x1
(0011) 	PWM16_EnableInt();    
    07D4: 10       PUSH  X
    07D5: 7C 02 46 LCALL _PWM16_EnableInt
(0012)   	PWM16_Start(); 
    07D8: 7C 02 4E LCALL _PWM16_Start
    07DB: 20       POP   X
(0013) 	
(0014) 	while(1)
(0015) 	{
(0016) 	
(0017) 	}
    07DC: 8F FF    JMP   0x07DC
(0018) }    07DE: 8F FF    JMP   0x07DE
