;;*****************************************************************************
;;*****************************************************************************
;;  ADC8.asm
;;  Version: 1.1, Updated on 2012/3/2 at 9:12:17
;;  Generated by PSoC Designer 5.2.2551
;;
;;  DESCRIPTION: ADC8 User Module software implementation file.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "ADC8.inc"
;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------

export _ADC8_Start
export  ADC8_Start
export _ADC8_Stop
export  ADC8_Stop
export _ADC8_StartADC
export  ADC8_StartADC
export _ADC8_StopADC
export  ADC8_StopADC
export _ADC8_fIsDataAvailable
export  ADC8_fIsDataAvailable
export _ADC8_bGetData
export  ADC8_bGetData
export _ADC8_ClearFlag
export  ADC8_ClearFlag
export _ADC8_bGetDataClearFlag
export  ADC8_bGetDataClearFlag
export _ADC8_bCal
export  ADC8_bCal


.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADC8_Start
;
;  DESCRIPTION:
;  Applies power setting to the module's analog blocks
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: 
;     A has Power Level to use
; 
;  RETURNS: None
;
;-----------------------------------------------------------------------------
 ADC8_Start:
_ADC8_Start:
   RAM_PROLOGUE RAM_USE_CLASS_1
;Turn on Power to analog block
   mov   reg[ADC8_ACE_CR2],A

   mov   A, ADC8_ADC_CR
   cmp   A, 68h
   jnz   .Column1
.Column0:
   mov   reg[CMP_CR0],11h  ;specify column interrupt
   mov   reg[DEC_CR0],11h   ;gate the comp1
   jmp   .SkipCol1
.Column1:
   mov   reg[CMP_CR0],22h  ;specify column interrupt
   mov   reg[DEC_CR0],22h   ;gate the comp1
.SkipCol1:

   mov   reg[PWM_CR], (PWM_High+PWM_Low)              
;Turn on Power to ADC Control
   or    reg[ADC8_ADC_CR], ADC8_ON
   RAM_EPILOGUE RAM_USE_CLASS_1
   ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADC8_Stop
;
;  DESCRIPTION:
;  Removes power setting to the module's analog blocks.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: None
;
;  RETURNS:   None
;
;-----------------------------------------------------------------------------
 ADC8_Stop:
_ADC8_Stop:
   RAM_PROLOGUE RAM_USE_CLASS_1
;Turn off Power to analog block
   and   reg[ADC8_ACE_CR2],~ADC8_ON
;Turn off Power to ADC Control
   and   reg[ADC8_ADC_CR], ~ADC8_ON
   RAM_EPILOGUE RAM_USE_CLASS_1
   ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADC8_StartADC
;
;  DESCRIPTION:
;  Starts the A/D convertor
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: None
;
;  RETURNS: None
;
;-----------------------------------------------------------------------------
 ADC8_StartADC:
_ADC8_StartADC:
   RAM_PROLOGUE RAM_USE_CLASS_4
   RAM_SETPAGE_CUR >ADC8_bfStatus
   call ADC8_StopADC
   mov  reg[ADC8_CNT_DR1],ffh ;reload Counter
   or   reg[ADC8_CNT_CR0],01h ;start counter
; clr interrupt
   and   reg[INT_CLR0],~ADC8_ADCMask  ;clear residue ACol1 interrupt
; enable interupt
   or    reg[ADC8_ADCIntReg],ADC8_ADCMask  ;enable ACol1 interrupt
   mov   [ADC8_bfStatus],0
;Start PWM
   or    reg[PWM_CR],01h
   RAM_EPILOGUE RAM_USE_CLASS_4
   ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADC8_StopAD
;
;  DESCRIPTION:
;  Completely shuts down the A/D is an orderly manner.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:  None
;
;  RETURNS: None
;-----------------------------------------------------------------------------
 ADC8_StopADC:
_ADC8_StopADC:
   RAM_PROLOGUE RAM_USE_CLASS_1
; disable interupt
   and   reg[ADC8_ADCIntReg],~ADC8_ADCMask  ;disable ACol1 interrupt
; turn off pwm
   and   reg[PWM_CR],~01h


; stop counter
   and  reg[ADC8_CNT_CR0],~ADC8_ON      ;stop counter
   RAM_EPILOGUE RAM_USE_CLASS_1
   ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADC8_fIsDataAvailable
;
;  DESCRIPTION:
;  Returns the status of the Data Available flag
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: None
;
;  RETURNS:
;  A  Returns data status  A == 0 no data available
;                          A != 0 data available
;
;-----------------------------------------------------------------------------
 ADC8_fIsDataAvailable:
_ADC8_fIsDataAvailable:
   RAM_PROLOGUE RAM_USE_CLASS_4
   RAM_SETPAGE_CUR >ADC8_bfStatus
   mov   A,[ADC8_bfStatus]                     ; Get status byte
   RAM_EPILOGUE RAM_USE_CLASS_4
   ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADC8_bGetDataClearFlag
;  FUNCTION NAME: ADC8_bGetData
;
;  DESCRIPTION:
;  Returns the data from the A/D.  Does not check if data is available.
;  bGetDataClearFlag clears the result ready flag as well.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: None
;
;  RETURNS:
;    A: The ADC result.
;
;-----------------------------------------------------------------------------
 ADC8_bGetDataClearFlag:
_ADC8_bGetDataClearFlag:
   RAM_PROLOGUE RAM_USE_CLASS_4
   RAM_SETPAGE_CUR >ADC8_bfStatus
   mov   [ADC8_bfStatus],0
   mov   A,[ADC8_bResult]
   RAM_EPILOGUE RAM_USE_CLASS_4
   ret
 ADC8_bGetData:
_ADC8_bGetData:
   RAM_PROLOGUE RAM_USE_CLASS_4
   RAM_SETPAGE_CUR >ADC8_bfStatus
   mov   A,[ADC8_bResult]
   RAM_EPILOGUE RAM_USE_CLASS_4
   ret
.ENDSECTION


.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADC8_ClearFlag
;
;  DESCRIPTION:
;  Clears the data ready flag.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: None
;
;  RETURNS: None
;
;------------------------------------------------------------------------
 ADC8_ClearFlag:
_ADC8_ClearFlag:
   RAM_PROLOGUE RAM_USE_CLASS_4
   RAM_SETPAGE_CUR >ADC8_bfStatus
   mov   [ADC8_bfStatus],0
   RAM_EPILOGUE RAM_USE_CLASS_4
   ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADC8_bCal
;
;  DESCRIPTION:
;  Adjusts the trim till the ADC value matchs the argument value.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: 
;    A contains the target value of the conversion 
;    X contains the Voltage Source for the calibration
;
;  RETURNS: None
;
;-----------------------------------------------------------------------------
PMux_Save:  equ -5
AMux_Save:  equ -4
Desired:	equ -3
Toggle:		equ -2
Closest:	equ -1

ADC8_bCal:
_ADC8_bCal:
   RAM_PROLOGUE RAM_USE_CLASS_4
   RAM_PROLOGUE RAM_USE_CLASS_2
   RAM_SETPAGE_CUR >ADC8_bfStatus

   add  SP, 2	                        	;create some extra stack space
   push A		                        	;Save the arguments 
   push X		                        	;on the stack
   mov  X, SP	                        	;get the stack pointer
   mov  A, reg[ADC8_ACE_CR1]
   mov  [X-4], A							;save the original value of ADC_CR1
   mov  A, reg[AMX_IN]
   mov  [X-3], A							;save the origianl value of AMX_IN
   and  [X-3], 7Fh
   M8C_SetBank1
   mov  A, reg[ABF_CR0]
   M8C_SetBank0
   and  A, 80h
   or   [X-3], A							;save the original value of ABF_CR0
   mov  A, [X-1]
   call SetInput							;Set the input to desired reference source

   add  SP,1 
   mov  X,SP ;X points to new desired cal valueouput

   mov  [X + Toggle],80h

   M8C_SetBank1 ;Set Cap for Largest Value
   mov  reg[ADC8_ADC_TR],00h
   M8C_SetBank0

.Repeat: ;repeat
   M8C_SetBank1
   mov  A,reg[ADC8_ADC_TR]
   xor  A,[X + Toggle] ; toggle trim
   mov  reg[ADC8_ADC_TR],A
   M8C_SetBank0
   
   call ADC8_StartADC ; readADC

.GetData: 
   tst  [ADC8_bfStatus],ffh
   jz   .GetData
   mov  A,[ADC8_bResult]

   cmp  A,[X + Desired]
   jnz  .NotZero ; if ADC == Desired
   call ADC8_StopADC
   mov  [X+Closest], A
   jmp  .Done

.NotZero:
   jc   .LessThan       ; elseif ADC > Desired (cap is too large)
   mov  [X + Closest],A ; closest = ADC
   jmp  .AllDone

.LessThan: ; else ADC < Desired (Cap is too small)
   M8C_SetBank1
   mov  A,reg[ADC8_ADC_TR]
   xor  A,[X + Toggle] ; toggle trim
   mov  reg[ADC8_ADC_TR],A
   M8C_SetBank0
.AllDone:
   add  A,0 ; toggle = toggle/2
   rrc  [X+ Toggle]
.Until:
   jnz  .Repeat ;until toggle is done
   call ADC8_StopADC ;return( Closest)
      
.Done:
   mov  A, [X+PMux_Save]						    
   mov  reg[ADC8_ACE_CR1], A			;restore original value of ACE_CR1
   mov  A, [X+AMux_Save]
   and  A, 0Fh
   mov  reg[AMX_IN], A								;restore original value of AMX_IN
   mov  A, [X+AMux_Save]
   and  A, 80h
   M8C_SetBank1
   mov  reg[ABF_CR0], A								;restore original value of ABF_CR0
   M8C_SetBank0
   mov  A,[X + Closest]								;Get the return value
   add  SP,-5
   RAM_EPILOGUE RAM_USE_CLASS_2
   RAM_EPILOGUE RAM_USE_CLASS_4
   ret
.ENDSECTION


SetInput:
   and   A, 10h
   jnz   .PortInput
   and   [X-1], 07h
   mov   A, reg[ADC8_ACE_CR1]
   and   A, F8h
   or    A, [X-1]
   mov   reg[ADC8_ACE_CR1], A
   ret

.PortInput:
   mov   A, ADC8_ADC_CR
   cmp   A, 68h
   jnz   .Column1
   and   [X-1], 03h
   mov   A, reg[AMX_IN]
   and   A, FCh
   or    A, [X-1]
   mov   reg[AMX_IN], A
   ret

.Column1:
   mov   A, [X-1]
   and   A, 80h
   M8C_SetBank1
   mov   reg[ABF_CR0], A
   M8C_SetBank0
   jz    .Even
   and   reg[AMX_IN], FCh
   jmp   .SkipEven
.Even:
   and   reg[AMX_IN], F3h
.SkipEven:
   and   [X-1], 0Fh
   mov   A, reg[AMX_IN]
   or    A, [X-1]
   mov   reg[AMX_IN], A
   ret
